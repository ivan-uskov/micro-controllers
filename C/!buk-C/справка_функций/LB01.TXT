

                    ЧАСТЬ 2.  ОПИСАНИЕ  ФУНКЦИЙ  БИБЛИОТЕКИ  СИ


               ABORT

            #include <process.h>  требуется только для объявления
                                  функции
            #include <stdlib.h>   использует  либо  <process.h>,
                                  либо <stdlib.h>
            void abort();

               Описание.

               Функция  abort  распечатывает  сообщение  "Abnormal program
         termination" (аварийное (непредвиденное) завершение программы)  в
         stderr,  затем оканчивает вызванный процесс, возвращая управление
         процессу, который инициировал вызванный процесс (обычно  операци-
         онной системе). Функция abort не обновляет буферы потоков.

               Возвращаемое значение.

               Возвращается статус выхода 3 к parent-процессу  либо к опе-
         рационной системе.
               См.также  execl,  execle,  execip,  execlpe, execv, execve,
         execvp, execvpe, exit, _exit, signal, spawnl,  spawnle,  spawnlp,
         spawnlpe, spawnv, spawnve, spawnvp, spawnvpe.

               Пример:

            #include <stdio.h>

            main(args, argv)
            int argc;
            char *argv[];
            {
            FILE *stream;
            if ((stream=fopen(argv[argc-1],"r"))==NULL) {
               frpintf(stderr,
                       "%s couldn't open file %s\n", argv[0],
                       argv[argc-1]);
               abort();
               }

               /*  Замечание.  Имя программы хранится в argv[0] только для
         версии MS DOS 3.0 и старших; в ранних  версиях  argv[0]  содержит
         строку "С". */

               }

               Образец командной строки:

               update employ.dat

               На выходе:


            C:\BIN\UPDATE.EXE  couldn't open file employ.dat.

               Abnormal program termination.
               (Непредвиденное завершение программы).

               ABS

            #include <stdlib.h>          требуется   только    для
                                         объявления функции
            int abs(n);
            int n;                       целое значение

               Описание.

               Функция  abs  возвращает  абсолютное значение своего целого
         аргумента n.

               Возвращаемое значение.

               Функция abs возвращает абсолютное значение своего  аргумен-
         та. Возвращаемого значения в случае ошибки нет.
               См. также cabs, fabs, labs.

               Пример:

            #include <stdlib.h>

            int x = -4, y;

            y = abs(x);
            printf("%d\t%d\n", x, y);.

               На выходе:

            -4       4.


               ACCESS

            #include <io.h>          требуется только для объявления
                                     функции

            int access(pathname, mode);
            char *pathname;          path-имя файла или директория
            int mode;                разрешенный доступ

               Описание.

               Для  файлов  функция  access определяет, существует или нет
         определенный файл, может ли он быть доступен  в  заданном  режиме
         mode.  Возможные  значения mode и их обозначения в вызовах access
         приведены ниже.


            ЗНАЧЕНИЕ             СМЫСЛ ЗНАЧЕНИЯ

                06         Проверка   на  доступ  по  чтению   и
                           записи

                04         Проверка   на  доступ  по  чтения

                02         Проверка   на  доступ  по  записи

                00         Проверка   только на существование


               В MS DOS все существующие файлы имеют доступ по чтению, по-
         этому режимы 00 и 04 вырабатывают один и тот же результат. Анало-
         гично, режимы 06 и 02 являются эквивалентными, поскольку в MS DOS
         доступ по записи предполагает доступ по чтению.
               Для директориев access определяет, существуют или  нет  за-
         данные  директории;  под  управлением MS DOS все директории имеют
         доступ по чтению и записи.

               Возвращаемое значение.

               Функция access возвращает значение 0, если файл  имеет  за-
         данный  режим  mode.  Возвращаемое  значение -1 свидетельствует о
         том, что названный файл не существует или недоступен  в  заданном
         mode, и errno устанавливается в одно из следующих значений:

           ЗНАЧЕНИЕ                  СМЫСЛ ЗНАЧЕНИЯ

            EACCES               Доступ  запрещен; установленный  статус
                                 для  файла  не допускает заданного  до-
                                 ступа

            ENOENT               Файл или path-имя не найдено


               См.также chmod, fstat, open, stat.

               Пример:

            #include <io.h>
            #include <fcntl.h>

            int fh;
            .
            .
            .
            /* проверка доступа по записи */
            if ((access("data",2))==-1 {
                   perror("data file not writable");
                   exit(1);
                   }

            else
                   fh=open("data", O_WRONLY);



               ACOS

            #include <math.h>

            double acos(x);
            double x;

               Описание.

               Функция acos возврaщaет aрккосинус x в интервaле от 0 до n.
         Знaчение x должно быть между -1 и 1.

               Возврaщaемое знaчение.

               Функция acos возврaщaет результaт aрккосинусa. Если x мень-
         ше -1 или больше 1, acos устaнaвливaет errno в EDOM, печaтaет со-
         общение об ошибке DOMAIN в stderr и возврaщaет 0.
               Обрaботкa ошибок может быть  модифицировaнa  при  изменении
         процедуры matherr.
               См.тaкже asin, atan, atan2, cos, matherr, sin, tan.

               Пример:

               В следующем примере прогрaммa выдaет подскaзки для вводa до
         тех пор, покa введенное знaчение не будет в интервaле от -1 до 1.

            #include <math.h>

            int errno;

            main()
                {
                float x,y;

                for (errno=EDOM;errno==EDOM;y=acos(x)) {
                    printf("Cosine=");
                    scanf("%f",&x);
                    errno = 0;
                    }
                printf("Arc cosine of %f = %f\n",x,y);
                }

            Обрaзец выводa:

            Cosine = 3
            acos: DOMAIN error
            Cosine = -1.0
            Arc cosine of -1.000000 = 3.141593


               ALLOCA

            #include <malloc.h>    требуется только для объявления
                                   функции


            char *alloca(size);
            unsigned size;         захваченные байты из стека

               Описание.

               Процедура alloca захватывает байты size из стека программы.
         Захваченное  пространство  автоматически освобождается при выходе
         из функции, вызвавшей alloca.

               Возвращаемое значение.

               Процедура alloca возвращает указатель char  на  захваченное
         пространство.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.  Чтобы
         получить  указатель на тип, отличный от char, используется преоб-
         разователь типа  возвращаемого  значения.  Возвращается  значение
         NULL, если пространство не было захвачено.
               См.также calloc, malloc, realloc.

               Предупреждение.  Значение указателя, возвращаемого процеду-
         рой alloca, не может быть аргументом для free. Так как alloca об-
         рабатывает стек, она должна использоваться только в простых  опе-
         раторах  выделения  и не должна использоваться в выражениях-аргу-
         ментах функций.

               Пример:

            #include <malloc.h>
            int *intarray;

            /* захватывает память в стеке для 10 целых */

            intarray=(int*)alloca(10*sizeof(int));


               ASCTIME

            #include <time.h>

            char *asctime(time);
            struct tm *time;       указатель на структуру,
                                   объявленную в <time.h>

               Описание.

               Функция  asctime преобразует время, хранимое как структура,
         в символьную строку. Значение time обычно  получается  из  вызова
         gmtime  или  localtime, которые возвращают указатель на структуру
         tm, объявленную в <time.h> (cм. gmtime для описания полей  струк-
         туры  tm).  Результирующая строка, выработанная asctime, содержит
         26 символов и имеет форму, приведенную ниже в примере:

               Mon Jan 02 02:03:55 1980\n\0


               Используется 24 часа. Все  поля  имеют  постоянную  ширину.
         Символ  новой строки ('\n') и нулевой символ ('\0') занимают  две
         последние позиции в строке.

               Возвращаемое значение.

               Функция asctime возвращает указатель на  символьную  строку
         результата. Возвращаемого значения в случае ошибки нет.
               См.также ctime, ftime, gmtime, localtime, time, tzset.

               Замечание. Функции asctime и ctime используют один и тот же
         статистически захваченный буфер для хранения в нем строки резуль-
         тата. Каждый вызов одной из этих  процедур  уничтожает  результат
         предыдущего вызова.

               Пример:

            #include <time.h>
            #include <stdio.h>

            struct tm *newtime;
            long ltime;
            .
            .
            .
            time(&ltime);  /*взять время в секундах*/
            newtime=localtime(&ltime); /*преобразовать к структуре
                                        tm  и  напечатать  местное
                                        время в виде строки*/
            printf("the current date and time are %s\n",
                 asctime(newtime));


               ASIN

            #include <math.h>

            double asin(x);
            double x;

               Описaние.

               Функция  asin вычисляет арксинус x в интервале -n/2 до n/2.
         Значение x должно быть между -1 и 1.

               Возвращаемое значение.

               Функция asin возвращает результат арксинуса. Если x  меньше
         -1  или больше 1, asin устанавливает errno в EDOM, печатает сооб-
         щение об ошибке DOMAIN в stderr и возвращает 0.
               Обрaботкa ошибок может быть  модифицировaнa  при  изменении
         процедуры matherr.
               См.тaкже acos, atan, atan2, cos, matherr, sin, tan.


               Пример:

            #include <math.h>

            int errno;

            main()

               {
               float x,y;
               for (errno=EDOM; errno==EDOM; y=asin(x)) {
                    printf("Sine=");
                    scanf("%f", &x);
                    errno = 0;
                            }
               printf("Arc sine of %f\n",x,y);
               }

               На выходе:

            Sine = -1.001
            asin: DOMAIN error
            Sine = -1
            Arc sine of -1.000000=-1.570796


               ASSERT

            #include <assert.h>

            void assert(expression);

               Описание.

               Процедура  assert  печатает диагностическое сообщение и за-
         вершает вызванный процесс, если expression ложно,  0.  Диагности-
         ческое сообщение имеет форму:

            Assertion failed:  file <filename>, line <linenumber>,

         где filename  -  имя  исходного файла, linenumber - номер строки,
         которая ошибочна.
               Если expression истинно (ненулевое), никакого  действия  не
         выполняется.
               Процедура assert обычно используется для обнаружения  логи-
         ческих ошибок в программе. Выражение expression должно быть зада-
         но  таким образом, чтобы оно было истинным, если программа выпол-
         няется как намечено. После того  как  отлажена  программа,  может
         быть  использован специальный "no debug" идентификатор NDEBUG для
         удаления вызовов assert из программы. Если NDEBUG определен  (лю-
         бым  значением)  опцией  командной  строки  /D  или  с директивой
         #define, препроцессор языка Си удаляет все вызовы assert  из  ис-
         ходной программы.

               Возвращаемое значение.


               Возвращаемого значения нет.

               Замечание. Процедура assert реализована как макро.

               Пример:

            #include <stdio.h>
            #include <assert.h>

            analyse_string (string)
            char *string;

            {
           /*  проверка строки перед обработкой  */

            assert (string != NULL);      /*  не может быть NULL,
                                            здесь   должна   быть
                                            строка */
            assert (*string != '\0');     /*    не   может   быть
                                             пустой */
            .
            .
            .
            }.


               ATAN - ATAN2

            #include <math.h>

            double atan(x);     вычисляет арктангенс x
            double x;

            double atan2(y,x);  вычисляет арктангенс y/x
            double x;
            double y;

               Описание.

               Обе  функции atan и atan2 возвращают результат арктангенса.
         Если оба аргумента atan2 равны 0, функция устанавливает  errno  в
         EDOM,  печатает  сообщение об ошибке DOMAIN в stderr и возвращает
         0.
               Обрaботкa ошибок  может  быть  модифицировaнa  при  исполь-
         зовaнии процедуры matherr.
               См.тaкже acos, asin, cos, matherr, sin, tan.

               Пример:

            #include <math.h>

            printf("%.7f\n", atan(1.0));            /* n/4 */
            printf("%.7f\n", atan2(-1.0,1.0));     /* -n/4 */


               На выходе:

            0.7853982
            -0.7853982


               ATOF-ATOL

               #include <match.h>     Использует  либо <match.h>,
               #include <stdlib.h>    либо <stdlib.h>.

               double atof (string);  преобразует строку  string в
                                      double

               char *string           строка,  подлежащая преобра-
                                      зованию
               int atoi (string)      преобразует строку string  в
                                      int

               long atol (string)     преобразует строку string  в
                                      long

               char *string           строка, подлежащая  преобра-
                                      зованию

               Описание.

               Эти функции преобразуют символьную строку в значение с пла-
         вающей  точкой  двойной  точности (atof), в целое значение (atoi)
         или в длинное целое значение (atol).
               Исходная строка string  представляет  собой  последователь-
         ность  символов, которые могут быть интерпретированы как числовое
         значение определенного типа.
               Функция прекращает чтение исходной строки  как только  поя-
         вится  первый  символ,  который не может быть воспринят как часть
         числа (им может быть NULL-символ, завершающий строку).
               Функция atof предполагает, что строка string имеет  следую-
         щую форму:

               [whitespace][sign][digits][{d|D|E}[sign]digits]  ,

         где  [whitespase]  состоит из пробелов  и/или  знаков  табуляции,
         которые игнорируются; [sign] означает "+" или "-";  [digits]   -
         -  одна или несколько десятичных цифр. Если перед десятичной точ-
         кой нет цифр, то хотя бы одна цифра должна стоять после нее.  Де-
         сятичные  цифры  могут  следовать за показателем степени, который
         состоит из буквы (d,D,e или E) и десятичного целого со знаком.
               Функции atoi и atol не обрабатывают  десятичные  точки  или
         показатели степени. Аргумент string для этих функций имеет вид:

               [whitespace][sign]digits     ,

         где  whitespace,  sign,  digits обозначают то же, что и для atof.

               Возвращаемое значение.


               Каждая из функций возвращает значение типа double, int  или
         long,  получаемое в результате интерпретации входных символов как
         чисел.

               Возвращаемое значение равно 0 (0L для atol), если  вход  не
         может  быть  преобразован  в  значение данного типа. Возвращаемое
         значение не определено в случае  переполнения.
               См. также ecvt, fcvt, gcvt.

               Пример:

               Следующие  примеры показывают, как числа, записанные в виде
         строк, могут быть преобразованы в числовые значения при использо-
         вании функций atof, atoi, atol:

               #include <math.h>

               extern long atol (\ );
               main (\ )
                     {
                     char *s;
                     double x;
                     int i;
                     long l;

                     s=" -2309.12E-15";
                     x=atof(s);
                     printf("%e\t",x);

                     s="7.8912654773d210";
                     x=atof(s);
                     printf("%e\t",x);

                     s="-9885";
                     i=atoi(s);
                     printf("%d\t",i);

                     s="98854 dollars";
                     l=atol(s);
                     printf("%ld\n",l);
                     }

               BDOS

            #include <dos.h>

            int bdos(dosfn, dosdx, dosal);
            int dosfn;                        номер функции
            unsigned int dosdx;               значение регистра DX
            unsigned int dosal;               значение регистра AL

               Описание.

               Функция bdos выполняет системный вызов MS DOS, номер  кото-

         рого определен в dosfn, после размещения соответственно в регист-
         рах DX и AL значений dosdx и dosal. Функция bdos выполняет коман-
         ду INT 21H для осуществления системного вызова.
               Функция   bdos   задается  для  использования  при  вызовах
         DOS-системных вызовов, которые не принимают аргументов  или толь-
         ко принимают их в регистры DX(DH,DL) и/или AL.

               Возвращаемое значение.

               Функция bdos возвращает значение регистра AX,  запомненного
         системным вызовом.
               См.также intdos, intdosx.

               Замечание. Этот вызов не может использоваться для осуществ-
         ления системных вызовов, в которых указываются ошибки посредством
         установки  флага  переноса.  Т.к. Си-программы не имеют доступа к
         этому флагу, статус возвращаемого значения не может быть  опреде-
         лен. В этом случае используется функция intdos.

               Пример:

               В  следующем  примере выводится подсказка 9 функцией MS DOS
         (вывод строки). Поскольку значение регистра AL не является  необ-
         ходимым,  то  передается 0. Этот пример работает правильно только
         для малой и средней моделей памяти, так как bdos не меняет значе-
         ния сегментов регистров.

            #include <dos.h>

            char *buffer = "Enter file name :$";

            /* AL не является необходимым, поэтому передается 0 */

            bdos(9,(unsigned)buffer,0);

               BESSEL

            #include <math.h>

            double j0(x);

            double j1(x);

            double jn(n,x);

            double y0(x);

            double y1(x);

            double yn(n,x);

            double x;           значение с плавающей точкой
            int n;              целый порядок


               Описание.

               Процедуры j0, j1, jn вычисляют соответственно функции  Бес-
         селя первой степени порядка - 0, 1 и n.
               Процедуры  y0, y1, yn вычисляют соответственно функции Бес-
         селя второй степени порядка - 0,1 и n. Аргумент x должен быть по-
         ложительным.

               Возвращаемое значение.

               Эти функции возвращают результат функций Бесселя для x. Ес-
         ли x является отрицательным для y0, y1, yn, процедура  устанавли-
         вает errno в EDOM, печатает сообщение об ошибке DOMAIN в stderr и
         возвращает отрицательное значение HUGE.
               Обрaботкa  ошибок  может  быть модифицировaнa при изменении
         процедуры matherr.
               См.также matherr.

               Пример:

            #include <math.h>

            double x, y, z;
            .
            .
            .
            y = j0(x);
            z = yn(3,x);


               BSEARCH

            #include <search.h>    требуется только для объявления
                                   функции

            char *bsearch(key,base,num,width,compare);
            char *key;             ключ поиска
            char *base;            указатель  на  поисковую   базу
                                   данных
            unsigned num,width;    число и размер элементов
            int (*compare)();      указатель на функцию  сравнения

               Описание.

               Функция bsearch производит двоичный поиск в отсортированном
         массиве из num элементов, размер  каждого  элемента  равен  width
         байт.  Base  -  указатель на начало массива, key - значение ключа
         поиска.
               Аргумент compare является указателем на процедуру,  постав-
         ляемую  пользователем,  которая сравнивает два элемента массива и
         возвращает значение, определяющее их отношение. В течении  поиска
         функция  bsearch  может  вызывать процедуру compare один или нес-
         колько раз, передавая в каждом вызове указатели на  два  элемента
         массива. Процедура должна сравнивать элементы, а затем возвращать
         одно из следующих значений.


              ЗНАЧЕНИЕ            СМЫСЛ ЗНАЧЕНИЯ

            меньше 0         element1 меньше, чем element2

               0             element1 равен element2

            больше 0         element1 больше, чем element2


               Возвращаемое значение.

               Функция  bsearch  возвращает  указатель на первое вхождение
         ключа key в массив, на который указывает base.
               Если key не найден, функция возвращает NULL.
               См. также lfind, lsearch, gsort.

               Пример:

               /* Функция bsearch производит двоичный поиск  в  отсортиро-
         ванном  массиве  для  элемента  "key"  и  возвращает указатель на
         структуру, в которой находится ключ key, или возвращает NULL, ес-
         ли ключа нет. */

            #include <search.h>
            #include <string.h>
            #include <stdio.h>
            int compare();

               /* должна быть объявлена как функция */

            main (argc, argv)
                 int argc;
                 char **argv;
                 {

                  char **result;
                  char *key = "PATH";

               /* следующий  оператор  находит  аргумент,  начинающийся  с
         "PATH", в предположении, что аргументы лексикографически отсорти-
         рованы */

                  result = (char **)bsearch((char *)&key,
                           (char *)argv, argc, sizeof(char *),
                           compare);
                  if (result)
                     printf ("%s found\n", *result);
                  else
                     printf("PATH not found!\n");
                 }

            int compare (arg1, arg2)
                char **arg1, **arg2;

                {

                 return(strncmp(*arg1, *arg2, strlen(*arg1)));
                }.

               CABS

            #include <math.h>

            double cabs(z);
            struct  complex  z;  содержит  вещественную  и  мнимую
                                 части

               Описание.

               Функция  cabs  вычисляет  абсолютное  значение комплексного
         числа. Комплексное число должно быть структурой с типом  complex,
         объявленной в <math.h>, следующим образом:
            struct complex  {
                    double x,y;
                    };

               Вызов cabs эквивалентен следующему:

               sgrt(z.x*z.x + z.y*z.y)

               Возвращаемое значение.

               Функция cabs возвращает абсолютное значение как описано вы-
         ше.  При переполнении функция вызывает процедуру matherr, возвра-
         щает значение HUGE и устанавливает errno в ERANGE.
               См.также abs, fabs, labs.

               Пример:

            #include <math.h>

            struct complex value;
            double d;

            value.x = 3.0;
            value.y = 4.0;

            d = cabs(value);


               CALLOC

            #include <malloc.h>    требуется только для объявления
                                   функции

            char *calloc(n,size);
            unsigned n;            количество элементов
            unsigned size;         длина каждого элемента в байтах
            Описание

               Функция calloc захватывает пространство для хранения масси-

         ва из n элементов, каждый длиной size байт. Каждый элемент иници-
         ализируется в 0.

               Возвращаемое значение.

               Функция calloc возвращает  указатель  char  на  захваченное
         пространство.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.  Чтобы
         получить  указатель на тип, отличный от char, используется преоб-
         разователь типа возвращаемого значения.
               Возвращается значение NULL, если осталось недостаточно  па-
         мяти.
               См.также free, haloc, hfree, malloc, realloc.

               Пример:

            #include <malloc.h>

            long *lalloc;
                 .
                 .
                 .
         /*  захватывает достаточное количество места для 40 длинных
         целых и инициализирует их в 0 */

            lalloc=(long*)calloc(40, sizeof(long));


               CEIL

            #include <math.h>

            double ceil(x);
            double x;        значение с плавающей точкой

               Описание.

               Функция ceil возвращает значение double, представляющее на-
         именьшее целое, которое больше или равно x.

               Возвращаемое значение.

               Функция ceil  возвращает  double  результат.  Возвращаемого
         значения в случае ошибки нет.

               См.также floor, fmod.


               Пример:

            #include <math.h>

            double y;
            .

            .
            .
            y = ceil(1.05);    /* y = 2.0 */
            y = ceil(-1.05);   /* y = -1.0 */


               CGETS

            #include <conio.h>   требуется только  для  объявления
                                 функции


            char *cgets(str);
            char *str;           память для хранения данных

            Описание.

               Функция  cgets читает строку символов прямо с консоли и за-
         поминает строку и ее длину в местоположении, указанном  str.  Str
         должно быть указателем на массив символов. Первый элемент массива
         -  str[0] должен содержать максимальную длину (в символах) читае-
         мой строки. Массив должен быть достаточно большим,  чтобы  содер-
         жать  строку, символ окончания '\0' и  два дополнительных  байта.
         Функция  cgets продолжает считывать символы, пока не будет прочи-
         тана  комбинация  "ВК-ПС"  или определенное количество  символов.
         Строка  запоминается,  начиная с str[2]. Если  комбинация "ВК-ПС"
         прочитана, перед  запоминанием  она  заменяется  нулевым символом
         '\0'.
               Функция  cgets во втором элементе массива str[1] запоминает
         действительную длину строки.

               Возвращаемое значение.

               Функция cgets возвращает указатель к началу строки, которая
         находится в str[2]. Возвращаемого значения в случае ошибки нет.
               См.также getch, getche.

               Пример:

            #include <conio.h>

            char *result;
            int numread;
            .
            .
            .
            *buffer=80; / *максимальное количество символов */

            /* Внимание. *buffer эквивалентно *buffer[0] */

               /* следующие операторы вводят строку с клавиатуры и находят
         ее длину: */

                result=cgets(buffer);
                numread=buffer[1];


               /* result указывает на строку, numread - на ее длину  ("ВК"
         не считается, т.к. заменяется нулевым символом */.

               CHDIR

            #include <direct.h>  требуется  только  для объявления
                                 функции

            int chdir(pathname);
            char *pathname;      path-имя  нового  рабочего дирек-
                                 тория

               Описание.

               Функция chdir изменяет текущий рабочий директорий на дирек-
         торий, определяемый по pathname; pathname должен ссылаться на су-
         ществующий директорий.

               Возвращаемое значение.

               Функция  chdir возвращает значение 0, если рабочий директо-
         рий успешно изменен. Возвращаемое значение -1 указывает на  ошиб-
         ку;  в  этом случае errno устанавливается в ENOENT, указывая, что
         заданное path-имя не может быть найдено. Ошибки не возникают, ес-
         ли pathname определяет текущий рабочий директорий.
               См.также mkdir, rmdir, system.

               Пример:

            #include <direct.h>

            /* следующий оператор изменяет текущий рабочий
            ** директорий на директорий корня   */

            chdir("/"); /* Замечание: эквивалентно chdir("\\") */



               CHMOD

            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только для объявления
                                  функции

            int chmod(pathname,pmode);
            char *pathname;       path-имя существующего файла
            int pmode;            разрешенный доступ для файла

               Описание.

               Функция chmod изменяет разрешенный доступ для файла, задан-
         ного path-именем. Разрешенный доступ управляет чтением и  записью
         файла. Константное выражение pmode состоит из одной или обеих ма-

         нифестных констант S_IWRITE и S_IREAD, определенных в <sys\stat.h>.
         Любое  другое  значение  для pmode игнорируется. Когда заданы обе
         константы, они объединяются логическим оператором ИЛИ (:). Значе-
         ния аргументов pmode представлены ниже.


            ЗНАЧЕНИЕ                      СМЫСЛ ЗНАЧЕНИЯ

            S_IWRITE                     разрешена запись

            S_IREAD                      разрешено чтение

            S_IREAD : S_IWRITE           разрешены чтение и запись

               Если разрешение на запись не задано, файл  доступен  только
         для  чтения.  В MS DOS все файлы доступны для чтения, поэтому не-
         возможно задание разрешения  только  на  запись.  Поэтому  режимы
         S_IWRITE и S_IREAD : S_IWRITE являются эквивалентными.

               Возвращаемое значение.

               Функция  chmod возвращает значение 0, если разрешенный дос-
         туп успешно изменен. Возвращаемое значение -1 свидетельствует  об
         ошибке;  в  этом случае errno устанавливается в ENOENT, указывая,
         что определенный файл не может быть найден.
               См.также access, creat, fstat, open, stat.


               Пример:

            #include <sys\types.h>
            #include <sys.stat.h>
            #include <io.h>
            int result;
            .
            .
            .
            result=chmode("data",S_IREAD);
               /* создать файл только для чтения */
            if (result==-1)
               perror("can't change file mode");



               CHSIZE

            #include <io.h>      требуется  только для  объявления
                                 функции

            int chsize(handle,size);
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            long size;           новая длина файла в байтах

               Описание.


               Функция  chsize увеличивает или уменьшает файл, связанный с
         handle-ром, до размера, определяемого аргументом size. Файл  дол-
         жен  быть  открыт  в  режиме, который разрешает запись. Если файл
         увеличивается, к нему добавляются нулевые символы '\0'. Если файл
         уменьшается,  все  данные от конца укороченного файла до первона-
         чальной длины файла теряются.

               Возвращаемое значение.

               Функция chsize возвращает значение 0, если файл успешно из-
         менен.  Возвращаемое  значение  -1  свидетельствует  об ошибке  и
         errno устанавливается в одно из следующих значений:

            ЗНАЧЕНИЕ             СМЫСЛ ЗНАЧЕНИЯ

            EACCES         Заданный  файл  определен  только   для
                           чтения. Для версий MS DOS 3.0 и старших,
                           EACCES свидетельствует о принудительной
                           блокировке.(Определенный файл  заблоки-
                           рован для доступа)

            EBADF          Неверный файловый handle

            ENOSPC         На  устройстве не  осталось  свободного
                           места

               См.также close, creat, open.

               Пример:

            #include <io.h>
            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>

            #define MAXSIZE 32768L

            int fh, result;
            .
            .
            .
            fh=open("data", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);

            .
            .
            .
            /* перед закрытием файла нужно убедиться, что он
            ** не длиннее 32К
            */
            if (lseek(fh,LO,2)>MAXSIZE)
               result=chsize(fh,MAXSIZE);


               _CLEAR87


            #include <float.h>

            unsigned int _clear87();  получает  и  очищает слово
                                      статуса  плавающей точки

               Описание.

               Функция _clear87 получает и стирает слово статуса плавающей
         точки. Слово статуса плавающей точки является  комбинацией  слова
         статуса  8087/80287 и других состояний, обнаруживаемых 8087/80287
         handler-ом, таких как переполнение и потеря значимости стека пла-
         вающей точки.

               Возвращаемое значение.

               Биты в возвращаемом значении  обозначают  статус  плавающей
         точки.  Смотрите  include-файл <float.h> для полного описания би-
         тов, возвращаемых функцией _clear87.
               Замечание. Большинство из математических библиотечных функ-
         ций модифицирует слово статуса 8087/80287 с  непредсказуемым  ре-
         зультатом.  Возвращаемые  значения  функций  _clear87 и _status87
         становятся более достоверными после выполнения нескольких  опера-
         ций  с  плавающей  точкой  с известными состояниями слова статуса
         плавающей точки.
               См.также _control87, _status87.

               Пример:

            #include <stdio.h>
            #include<float.h>

            double a = 1e-40,b;
            float x,y;

            main()
              {
              printf("status=%.4x - clear\n",_clear87());
              y = a;

               /* запомненное в y является неточным и с потерянной  значи-
         мостью */
              printf("status=%.4xx - inexact, underflow\n",
                     _clear87());
              b = y;    /* y является неправильным */
              printf("status=%.4x - denormal\n", _clear87());
              }


               CLEARERR

            #include <stdio.h>
            void clearerr(stream);

            FILE  *stream;          указатель на структуру FILE


               Описание.

               Функция  clearerr переустанавливает для потока stream инди-
         катор ошибки и индикатор конца файла (EOF) в 0. Индикаторы ошибок
         автоматически не очищаются; если для потока установлен  индикатор
         ошибки,  то операции над потоком будут возвращать значения ошибок
         до тех пор, пока функции clearerr или rewind не будут вызваны.
               См. также функции eof, feof, ferror, perror.

               Пример:

            #include <stdio.h>
            #include <stdlib.h>

            FILE *stream;
            int c;

               /* следующие операторы читают данные из потока и проверяют,
         возникла или нет ошибка при чтении. Перед  чтением  поток  должен
         быть предварительно открыт */.
            if ((c=getc(stream))==EOF)
            {  if (ferror(stream))
               {  fprintf(stderr, "write error\n");
                  clearerr(stream);
               }
            }


            CLOSE

            #include <io.h>     требуется  только  для  объявления
                                функции.
            int close(handle);
            int handle;         handle-р,  ссылающийся на открытый
                                файл.

               Описание.

               Функция   close  закрывает  все  файлы,  ассоциированные  с
         handle.

               Возвращаемое значение.

               Эта функция возвращает 0, если файл успешно закрыт. Возвра-
         щаемое значение -1 свидетельствует об ошибке; функция errno уста-
         навливается в EBADF, что свидетельствует о неправильном аргументе
         handle-ра файла.
               См. также chsize, creat, dup, dup2, open, unlink.

               Пример:

            #include <io.h>
            #include <fcntl.h>


            int fh;

            fh = open("data", O_RDONLY);
            .
            .
            .
            close(fh);.


               _CONTROL87

            #include <float.h>

            unsigned int _control87(new,mask); получает слово уп-
                                               равления плавающей
                                               точки

            unsigned int new;                  новые    значения
                                               битов       слова
                                               управления

            unsigned int mask;                 устанавливаемая
                                               маска   для новых
                                               битов слова управ-
                                               ления

               Описание.

               Функция _control87 получает и устанавливает слово  управле-
         ния  плавающей  точки. Слово управления плавающей точки позволяет
         изменять в программе режимы точности, округления и  бесконечности
         для  математического пакета программ с плавающей точкой. Исключи-
         тельные состояния с плавающей точкой также можно маскировать  или
         размаскировать, используя для этого функцию _control87.
               Если  значение  для mask равно 0, тогда _control87 получает
         слово управления с плавающей точкой. Если mask  ненулевая,  уста-
         навливается  новое  значение для слова управления следующим обра-
         зом: для любого бита равного 1 в mask соответствующий бит  в  new
         используется для обновления слова управления словами. Это записы-
         вается так:

                fpcntrl=((fpcntrl & ~mask) : (new & mask)),

         где fpcntrl является словом управления с плавающей точкой.

                Возвращаемое значение.

               Биты  в возвращаемом значении обозначают состояние управле-
         ния с плавающей точкой. См. include-файл  <float.h>  для  полного
         описания битов, возвращаемых _control87.
               См.также _clear87, _status87.



               Пример:

            #include <stdio.h>
            #include<float.h>

            double a = .1;

            main()
               {
               /* получает слово управления */
               printf("control=%.4x\n", _control87(0,0));
               printf("a*a=.01=%.15e\n",a*a);

               /* устанавливает точность в 24 бита */
               _control87(PC_24, MCW_PC);
               printf("a*a=.01(rounded to 24 bits)=%.15e\n",a*a);

               /* восстанавливает к первоначальному умолчанию */
               _control87(CW_DEFAULT, 0xffff);
               printf("a*a=.01=%.15e\n",a*a);
               }


               COS-COSH

            #include <math.h>

            double cos(x);      вычисляет косинус x
            double cosh(x);     вычисляет гиперболический косинус
                                x
            double x;           радиан

               Описание.

               Функции  cos и cosh возвращают соответственно косинус и ги-
         перболический косинус x.

               Возвращаемое значение.

               Функция cos возвращает косинус x. Если x большой, в резуль-
         тате может возникнуть частичная потеря значимости. В этом  случае
         cos  вырабатывает  ошибку PLOSS, но сообщения не печатает. Если x
         настолько большой, что теряется общая значимость  результата,  то
         cos печатает сообщение об ошибке TLOSS в stderr и возвращает 0. В
         обоих случаях errno устанавливается в ERANGE.
               Функция cosh возвращает гиперболический косинус x. Если ре-
         зультат  большой,  cosh  возвращает значение HUGE и устанавливает
         errno в ERANGE.
               Обрaботкa ошибок  может  быть  модифицировaнa  при  исполь-
         зовaнии процедуры matherr.
               См.также  acos, asin, atan, atan2, matherr, sin, sinh, tan,
         tanh.

               Пример:

            #include <math.h>


            double x,y;
            .
            .
            .

            y = cos(x);
            y = cosh(x);


               CPRINTF

           #include <conio.h>      требуется только для объявления
                                   функции
           int cprintf(format-string[,argument...]);
           char *format-string;   строка управления форматом

               Описание.

               Функция cprints форматирует и печатает различные символы  и
         значения прямо на консоль, используя для выводимых символов функ-
         цию  putch.  Каждый  arguments (если он есть) преобразовывается и
         выводится  согласно  соответствующей   спецификации   формата   в
         format-string.  Format-string  имеет ту же самую форму и функцию,
         что и аргумент format-string для функции printf (См.описание фун-
         кции printf для получения подробной информации о format-string  и
         аргументах).

               Возвращаемое значение.

               Функция cprintf возвращает число напечатанных символов.
               См.также fprintf, printf, sprintf, vprintf.
               Замечание!  В отличии от функций sprintf, printf и sprintf,
         функция cprintf на выходе не транслирует символы ПС в  комбинацию
         "ВК-ПС".

               Пример:

            #include <conio.h>

            int i=-16, j=29;
            unsigned int k=511;

           /* следующий оператор напечатает i = -16, j = 0x1d, k = 511 */
            cprintf("i=%d, j=%#x, k=%u\n", i,j,k);


               CPUTS

            #include <conio.h>     требуется только для объявления
                                   функции

            void cputs(str);
            char *str;             указатель на выводимую строку


               Описание.

               Функция  cputs  записывает  строку,  оканчивающуюся нулевым
         символом и на которую указывает str, прямо на консоль.
               Замечание. В строке комбинация "Возврат каретки  -  Перевод
         строки" после записи автоматически не появляется.

               Возвращаемое значение.

               Возвращаемого значения нет.

               См.также putch.

               Пример:

            #include <conio.h>

            char *buffer = "Insert data disk in drive a: \r\n";

            /* следующий оператор выводит подсказку на консоль */.

            cputs(buffer);.

               CREAT

            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только для объявления
                                  функций.

            int creat(pathname, pmode);
            char *pathname;       path-имя нового файла
            int pmode;            разрешенный режим доступа

               Описание.

               Функция creat либо создает новый файл, либо открывает и об-
         новляет  (усекает  до длины 0) существующий файл. Если существует
         файл, определяемый path-именем, то создается новый файл с  задан-
         ным  режимом  доступа и являющийся открытым для записи. Если файл
         существует и его режим доступа позволяет  запись,  тогда  функция
         creat  усекает файл к длине 0, уничтожая все содержимое, и однов-
         ременно открывает файл.
               Разрешенный режим доступа - pmode - применяется только  для
         вновь  созданных  файлов. Новый файл получает установленный режим
         доступа после первого его закрытия. Целое выражение pmode состоит
         из  одной  или  нескольких  манифестных  констант  -  S_IWRITE  и
         S_IREAD,  объявленных  в <sys\stat.h>. Если задаются обе константы,
         они объединяются при помощи логического OR (:). Значение аргумен-
         та pmode приводится ниже.

            КОНСТАНТА              СМЫСЛОВОЕ  ЗНАЧЕНИЕ

            S_IWRITE               разрешает запись

            S_IREAD                разрешает чтение


            S_IREAD:S_IWRITE       разрешают чтение и запись

               Если запись не разрешена, файл предназначен только для чте-
         ния. В MS DOS нельзя  разрешить  только  запись.  Поэтому  режимы
         S_IWRITE и S_IREAD: S_IWRITE являются эквивалентными.
               В версиях MS DOS 3.0 и старших файлы, открываемые при помо-
         щи  creat, всегда открываются в совмещенном режиме (compatibility
         mode).
               Функция creat перед установкой  флага  доступа  присваивает
         pmode маске доступа (подробно об этом смотрите umask).

               Возвращаемое значение.

               В  случае успешного вызова эта функция возвращает handle на
         созданный файл. Возвращаемое значение -1 свидетельствует об ошиб-
         ке; errno устанавливается в одно из следующих значений:


            ВОЗВРАЩАЕМАЯ              СМЫСЛОВОЕ  ЗНАЧЕНИЕ
            ВЕЛИЧИНА

            EACCES           Path-имя   определяет    существующий
                             файл   только   для    чтения     или
                             определяет директорий вместо файла

            EMFILE           другие  handle-ры  файла не пригодны,
                             т.к. много открытых файлов

            ENOENT           path-имя не найдено.

               См. также chmod, chsize, close,  dup,  dup2,  open,  sopen,
         umask.
               Замечание.  Процедура  create  обеспечивает  первоначальную
         совместимость с предыдущими библиотеками. Вызов open  при  помощи
         значений O_CREAT и O_TRUNC, определенных в аргументе oflag, явля-
         ется зквивалентным и предпочтительным для нового кода.

               Пример:

            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>

            int fh;

            fh = creat("data", S_IREAD|S_IWRITE);

            if (fh == -1)
                perror("Couldn't create data file");.



               CSCANF

            #include <conio.h>     требуется только для объявления
                                   функции

            int cscanf(format-string[,argument...]);
            char *format-string;   строка управления форматом

               Описание.

               Функция cscanf читает данные прямо с консоли в место, зада-
         ваемое  arguments  (если они есть), используя для чтения символов
         функцию getch. Каждый аргумент argument должен быть указателем на
         переменную с типом, который соответствует  определенному  типу  в
         format-string. Format-string управляет интерпретацией полей ввода
         и  имеет  ту же самую форму и функцию, что аргумент format-string
         для функции scanf (см. описание функции scanf для получения  под-
         робной информации о format-string).

               Возвращаемое значение.

               Функция  scanf  возвращает  число успешно преобразованных и
         назначенных полей. Возвращаемое значение не содержит прочитанных,
         но не назначенных полей. При попытке чтения конца файла возвраща-
         ется значение EOF. Возвращаемое значение 0 означает,  что  назна-
         ченных полей нет.
               См.также fscanf, scanf, sscanf.

               Пример:

            #include <conio.h>

            int result;
            char buffer [20];
            .
            .
            .
            cprintf("Please enter file name: ");

         /*  следующий  оператор  запоминает  введенную с клавиатуры
         строку */

            result = csanf("%19s", buffer);

         /* result - число верно введенных полей. Он равен  0,  если
         нет соответствия */


               CTIME

            #include <time.h>   требуется только для объявления
                                функции
            char *ctime(time);
            long *time;         указатель на хранимое время


               Описание.

               Функция  ctime преобразует время, хранимое как long- значе-
         ние, в символьную строку. Значение time обычно получается из  вы-
         зова функции time, которая возвращает количество секунд, пройден-
         ных от значения времени по Гринвичу, т.е. с 1 января 1980 года.
               Строка  результата, выработанная по ctime, содержит 26 сим-
         волов и имеет форму, приведенную ниже в примере:

               Mon Jan 02 02:03:55 1980\n\0

               Используется 24 часа. Все  поля  имеют  постоянную  ширину.
         Символ  новой строки ('\n') и нулевой символ ('\0') занимают  две
         последние позиции в строке.
               В MS DOS даты раньше 1980 года  не  понимаются.  Если  time
         представляет дату перед 1 января 1980 года, ctime возвращает сим-
         вольную строку, представленную 00:00:00 January 1,1980.

               Возвращаемое значение.

               Функция ctime возвращает указатель на символьную строку ре-
         зультата. Возвращаемого значения в случае ошибки нет.
               См.также asctime, ftime, gmtime, localtime, time.

               Замечание. Функции asctime и ctime используют один и тот же
         статистически захваченный буфер для хранения в нем строки резуль-
         тата.  Каждый  вызов  одной из этих процедур уничтожает результат
         предыдущего вызова.

               Пример:

            #include <time.h>
            #include <stdio.h>

            long time;

            time(&ltime);
            printf("the time is %s\n",ctime(&ltime));


               DIIEEETOMSBIN-DMSBINTOIEEE


            #include <math.h>

            int dieeetomsbin(src8,dst8); преобразует число двойной
                                         точности формата  IEEE  к
                                         двоичному двойному форма-
                                         ту MS

            int dmsbintoieee(src8,dst8); преобразует число двойной
                                         точности в  формате  MS к
                                         числу в формате IEEE

               Описание.

               Процедура dieeetomsbin преобразует число двойной точности в

         формате IEEE к двоичному формату Microsoft.
               Процедура dmsbintoieee преобразует число двойной точности в
         двоичном формате Microsoft к IEEE формату.
               Эти процедуры позволяют программам Си,  которые  записывают
         числа  с  плавающей точкой в формате IEEE, использовать численные
         данные в полях данных случайного доступа,  созданные  при  помощи
         Microsoft  BASIC,  который  записывает числа с плавающей точкой в
         двоичный формат Microsoft и наоборот.
               Аргумент  src8   является   указателем   на   преобразуемое
         double-значение.  Результат записывается в расположение, заданное
         аргументом dst8.

               Возвращаемое значение.

               Эти функции возвращают 0, если преобразование  было  успеш-
         ным, и 1 - если преобразование повлекло переполнение.
               См.также fieeetomsbin, fmsbintoieee.

               Замечание.  Эти процедуры не обрабатывают IEEE NAN и беско-
         нечность. Необычные IEEE трактуются в преобразованиях как 0.


               DIFFTIME


            #include <time.h>   требуется  только  для  объявления
                                функции

            double difftime(time2,time1);
            time_t time2;       тип time_t, объявленный в <time.h>


               Описание.

               Функция difftime вычисляет разность между time2 и time1.


               Возвращаемое значение.

               Функция difftime возвращает пройденное время в секундах  от
         time1 до time2 как число с двойной точностью.
               См.также time.


               Пример:

            #include <time.h>

            int mark[10000];

            main()
                {
               /*  это - пример употребления времени посредством использо-
         вания difftime. Она вычисляет, сколько времени ей  потребовалось,
         чтобы найти простые числа от 3 до 10000. Для вывода простого чис-

         ла  уничтожается  самый  внешний цикл и комментарии ограничителей
         вокруг "printf("%d\t",n);"*/

                time_t start, finish;
                register int i, loop, n, num, step;

                time(&start);
                for(loop=0; loop<1000; ++loop)
                   for(num=0,n=3;n<10000;n+=2)
                      if(!mark[n]) {
                          /* printf("%d\t",n); */
                          step=2*n;
                          for(i=3*n;i<10000;i+=step)
                                mark[i]=-1;
                          ++num;
                          }
                time(&finish);

                /*  в "sieve" печается в среднем 1000 циклов */


                printf("\nProgram takes %f seconds to find %d
                       primes.\n",
                       difftime(finish,start)/1000,num);
                }

               На выходе:

            Program takes 0.482000 seconds to find 1228 primes.


               DOSEXTERR


            #include <dos.h>

            int dosexterr(buffer);
            struct DOSERROR *buffer;

               Описание.

               Функция dosexterr получает значение регистра, возвращаемого
         системным вызовом MS DOS 59H, и записывает это значение в  струк-
         туру,  на  которую  указывает  buffer. Эта функция полезна, когда
         системные вызовы вырабатываются в версиях MS DOS 3.0 и старших  и
         которые предлагают расширенную обработку ошибок.  Более  подробно
         системные  вызовы  MS DOS описаны в руководстве "Microsoft MS DOS
         Programmer's Reference Manual".
               Тип структуры DOSERROR объявлен в  <dos.h>  и  представляет
         следующее:

            struct DOSERROR {
                   int exterror;
                   char class;
                   char action;

                   char locus;
                   };

               Аргумент  NULL-указателя посредством dosexterr определяет в
         AX возвращаемое значение.

               Возвращаемое значение.

               Функция dosexterr возвращает значение в регистр  AX  (иден-
         тично   значению в поле структуры exterror).
               См.также perror.

               Пример:

            #include <dos.h>
            #include <fcntl.h>
            #include <stdio.h>

            struct DOSERROR doserror;
            int fd;

            if ((fd=open("test.dat",O_RDONLY))==-1 {
               dosexterr(&doserror);
               printf("error=%d,class=%d,action=%d,locus=%d\n",
                       doserror.exterror, doserror.class,
                       doserror.action, doserror.locus);
               }


               DUP - DUP2

            #include <io.h>      требуется  только для  объявления
                                 функций

            int dup(handle);     создает   второй   handle-р   для
                                 открытого файла
            int handle;          handle-р, ссылающийся на открытый
                                 файл

            int dup2(handle1, handle2);
                                 форсирует handle1 для  ссылки  на
                                 handle2 файла

            int handle1;         handle-р, ссылающийся на открытый
                                 файл
            int handle2;         любое значение handle

               Описание.

               Функции  dup и dup2 вызывают второй handle-р файла, связан-
         ный с  открытым  файлом.  Операции  в  файле  могут  пересылаться
         handle-ром, тогда как все handle-ры, связанные с заданным файлом,
         используют тот же самый указатель на файл. Создание нового handle
         не влияет на тип доступа файла.
               Функция dup возвращает следующий доступный handle-р для за-

         данного  файла.  Функция  dup2 форсирует (force) заданный handle,
         т.е. handle2, чтобы сослаться на тот же самый  файл,  на  который
         ссылается handle1. Если во время вызова handle2 связан с открытым
         файлом, то этот файл закрывается.

               Возвращаемое значение.

               Функция  dup  возвращает новый handle-р файла. Функция dup2
         возвращает 0 в случае успеха. Если возникает ошибка, обе  функции
         возвращают  -1 и errno устанавливается в одно из следующих значе-
         ний.

            ВЕЛИЧИНА                 СМЫСЛОВОЕ  ЗНАЧЕНИЕ

            EBADF               Неверный handle-р файла

            EMFILE              Другие   handle-ры файла  для него
                                не доступны, т.к.  много  открытых
                                файлов

               См. также close, creat, open.


               Пример:

            #include <io.h>
            #include <stdlib.h>

            int fh;
            .
            .
            .
               /* выбирает другой handle-р файла, чтобы сослаться  на  тот
         же самый файл, на который указывает handle1 (stdout) */

            fh = dup(1);

            if (fh == -1)
               perror("dup(1) failure");

               /*  создает  handle3 файла для ссылки на тот же самый файл,
         на который ссылается handle 1 (stdout). Если handle3 файла  явля-
         ется также открытым, он закрывается первым */

            fh = dup2(1,3);

            if (fh != 0)
               perror("dup2(1,3) failure");.


               ECVT


               #include <stdlib.h>      требуется    только    для
                                        объявления функции

               char *ecvt(value, ndigits, decptr,signptr);

               double value;            преобразуемое число

               int ndigits;             количество    запоминаемых
                                        цифр

               int *decptr;             указатель  на  запомненное
                                        положение десятичной точки

               int *signptr;            указатель  на  запомненный
                                        индикатор  знака


               Описание.
               Функция  ecvt  преобразовывает  число  с плавающей точкой в
         символьную строку. Value - это число с плавающей точкой,  которое
         должно быть преобразовано. Ecvt запоминает цифры ndigits из value
         как строку и добавляет к ней нулевой символ ('\0'). Если количество
         цифр в value превышает ndigits, последняя значащая цифра округля-
         ется. Если цифр меньше, чем ndigits, строка дополняется нулями.
               В  строке хранятся только цифры. Положение десятичной точки
         и знака в value может быть определено  после  вызова  функции  из
         decptr и signptr. Аргумент decptr указывает на целое число, опре-
         деляющее положение десятичной точки относительно начала строки. 0
         или  отрицательное значение означают, что десятичная точка распо-
         ложена левее первой цифры. Аргумент signptr указывает  на  целое,
         определяющее  знак  преобразуемого  числа.  Если signptr равно 0,
         число положительное, иначе - отрицательное.


               Возвращаемое значение.

               Функция ecvt возвращает указатель на строку цифр. В  случае
         ошибки возвращаемого значения нет.
               См.также atof, atoi, atol, fcvt, gcvt.

               Замечание.  Функции ecvt и fcvt используют для преобразова-
         ния один и тот же статически распределенный буфер. Каждое обраще-
         ние к одной из этих процедур уничтожает результат предыдущего об-
         ращения.


               Пример:

               #include <stdlib.h>

               int decimal, sign;
               char *buffer;
               int preciision=10;


               buffer=ecvt(3.1415926535,precision,&decimal,&sign);
                  /*буфер содержит "3141592654",decimal=1,sign=0*/



               EOF

            #include <io.h>      требуется только  для  объявления
                                 функции

            int eof(handle);
            int handle;          handle-р, ссылающийся на открытый
                                 файл

               Описание.

               Функция eof определяет достижение конца  файла  для  файла,
         ассоциированного с handle.

               Возвращаемое значение.

               Эта функция возвращает значение 1, если текущая позиция яв-
         ляется  концом файла; 0 - в противном случае. Возвращаемое значе-
         ние -1 свидетельствует об ошибке; errno устанавливается в  EBADF,
         инициируя при этом неверный handle файла.
               См. также clearerr, feof, ferror, perror.

               Пример:

            #include <io.h>
            #include <fgntl.h>

            int fh, count;
            char buf[10];

            fh = open("data", O_RDONLY);

               /* следующий оператор проверяет перед чтением условие конца
         файла */

            while (!eof(fh))
            { count = read(fh, buf, 10);
              .
              .
              .
              }.


               EXECL - EXECVPE


            #include  <process.h>       требуется    только    для
                                        объявления функций

            int execl(pathname, arg0, arg1 ... ,argn, NULL);

            int execle(pathname, arg0, arg1 ... ,argn, NULL, envp);

            int execlp(pathname, arg0, arg1 ... ,argn, NULL);


            int execlpe(pathname, arg0, arg1 ... ,argn, NULL, envp);

            int execv(pathname, argv);

            int execve(pathname, argv, envp);

            int execvp(pathname, argv);

            int exevpe(pathname, argv, envp);

            char *pathname;                 path-имя  выполняемого
                                            файла
            char *arg0, *arg1, ..., *argn;  список  указателей  на
                                            аргументы
            char *argv[];                   массив  указателей  на
                                            аргументы
            char *envp[];                   массив  указателей  на
                                            установленное  окруже-
                                            ние
               Описание.

               Функции  exec  загружают  и  выполняют новый child-процесс.
         Когда вызов произошел успешно, child-процесс размещается в  памя-
         ти,  занятой  вызвавшим  процессом.  Для  загрузки  и  выполнения
         child-процесса должно быть доступно достаточно памяти.
               Pathname может определять полный  path  (из  корня),  часть
         path (из текущего рабочего директория) или просто имя файла.
               Если pathname не имеет расширения для имени файла  или если
         оно не заканчивается точкой (.), тогда функции exec устанавливают
         расширение  .EXE. Если pathname имеет расширение, то используется
         только это расширение. Если pathname заканчивается  точкой,  exec
         осуществляет  поиск  pathname  без  расширения. Процедуры execlp,
         execlpe, execvpe осуществляют поиск для pathname (используя те же
         самые процедуры) в директориях, определенных переменной
         окружения PATH.
               Аргументы для нового процесса передаются  как  аргументы  в
         вызове exec путем задания одного или более указателей на символь-
         ные  строки. Эти символьные строки образуют список аргументов для
         child-процесса. Общая длина строк, определяющая список аргументов
         для нового процесса, не может превышать 128 байтов. Нулевой  сим-
         вол окончания '\0 'для  каждой строки в эту длину не засчитывает-
         ся,а символы пробела (автоматически вставляемые для аргументов) -
         засчитываются.
               Указатели аргументов могут передаваться как отдельные аргу-
         менты  (в execl, execle, execlp, execlpe) или как массив указате-
         лей (в execv, execve, execvp, execvpe). По крайней мере один  ар-
         гумент  -  arg0 или argv[0] - должен быть передан child-процессу.
         По соглашению этот аргумент является копией  аргумента  pathname.
         (Другое  значение  не  будет воспринято как ошибка). В версиях MS
         DOS, ранних от 3.0, передаваемое значение arg0 или argv[0]  явля-
         ется не доступным для использования в child-процессе. Однако, для
         версий  MS  DOS  3.0  и  старших   pathname доступно как arg0 или
         argv[0].
               Вызовы execl, execle, execlp, execlpe  обычно  используются

         тогда,  когда  количество  аргументов  известно заранее. Аргумент
         arg0 обычно является указателем на pathname. Аргументы от arg1 до
         argn указывают на символьные строки, образующие новый список  ар-
         гументов. Идущий за аргументом argn NULL-указатель определяет ко-
         нец списка аргументов.
               Обычно  вызовы  execv, execve, execvp, execvpe используются
         тогда, когда число аргументов для нового процесса является  пере-
         менным.  Указатели на аргументы пересылаются как массив argv. Ар-
         гумент argv[0] обычно является указателем на pathname.  Аргументы
         от  argv[1] до argv[n] указывают на символьные строки, образующие
         новый список аргументов. Аргумент argv[n+1] должен быть NULL-ука-
         зателем для определения конца списка аргументов.
               Файлы, открытые до вызова exec, остаются открытыми и в  но-
         вом  процессе.  В вызовах execl, execlp, execv, execvp child-про-
         цесс наследует окружение parent-процесса. Вызовы execle, execlpe,
         execve, execvpe позволяют  пользователю  изменять  окружение  для
         child-процесса,  передавая  список установленного окружения через
         аргумент envp.
               Аргумент envp является массивом указателей на char,  каждый
         элемент  которого (исключая последний элемент) указывает на стро-
         ку, которая заканчивается нулем и определяет  переменную  окруже-
         ния. Обычно эта строка имеет форму:

               NAME = value   ,

         где  NAME -  имя  переменной  окружения,  value  - значение стро-
         ки  (заметим, что  value не заключается в кавычки "..."). Послед-
         ним элементом массива envp должен быть NULL.
               Если значением envp является NULL, child-процесс  наследует
         установленное окружение parent-процесса.

               Возвращаемое значение.

               Функции  exec  не  имеют  нормального возврата в вызывающий
         процесс. Если из функции exec происходит возврат, то это означает
         ошибку и возвращаемое значение равно  -1.  Переменная  errno  при
         этом устанавливается в одно из следующих значений:


            ЗНАЧЕНИЕ               СМЫСЛ ЗНАЧЕНИЯ


            E2BIG          Список аргументов превышает  128  байт,
                           или    пространство,    требуемое   для
                           информации окружения, превышает 32К

            EACCES         Блокировка  или  разделение файла  (для
                           версий 3.0 и старших)

            EMFILE         Много  открытых файлов (специфицирован-
                           ный файл должен  быть  открыт,    чтобы
                           начать его выполнение)

            ENOENT         Файл или path-имя не найдено


            ENOEXEC        Заданный файл  не является  выполняемым
                           или имеет неверный формат

            ENOMEM         Доступной   памяти  не  достаточно  для
                           выполнения child-процеса; или доступная
                           память    является   запорченной;   или
                           существуют неверные блоки, указывающие,
                           что parent-процесс неверно размещен

               См.  также  abort,  exit,  _exit,  onexit, spawnl, spawnle,
         spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, system.
               Замечание. Вызовы exec не сохраняют текстовый режим  преоб-
         разования  для открытых файлов. Если child-процесс должен исполь-
         зовать файлы, унаследованные  от  parent-процесса,  тогда  должна
         быть  использована процедура setmode для установки требуемого ре-
         жима преобразования для этих файлов.
               Установки сигналов прерывания не сохраняются  в  child-про-
         цессе,  созданном вызовом процедуры exec. Эти установки переуста-
         навливаются по умолчанию в child-процессе.

               Пример:

            #include <process.h>
            #include <stdio.h>

            extern char **environ;

            char *args[4];
            int result;

            args[0] = "child";
            args[1] = "one";
            args[2] = "two";
            args[3] = NULL;

               /*  все  следующие  операторы  позволяют выполнять процесс,
         названный "child.exe", и передать ему три аргумента. */


            result = execl("child.exe", "child", "one", "two",
                           NULL);
            result = execle("child.exe", "child", "one", "two",
                           NULL, environ);
            result = execlp("child.exe", "child", "one", "two",
                           NULL);
            result = execv("child.exe", args);
            result = execve("child.exe", args, environ);
            result = execvp("child.exe", args);.


               EXIT - _EXIT

            #include <process.h>   требуется только для объявления
                                   функции
            #include <stdlib.h>    использует  либо  <process.h>,

                                   либо <stdlib.h>

            void exit(status);     завершает процесс  после закры-
                                   тия файла

            void _exit(status);    завершает процесс  без обновле-
                                   ния буферов потока
            int status;            статус выхода


               Описание.

               Функции exit и _exit завершают вызванный процесс. Перед за-
         вершением  процесса функция exit обновляет все буферы и закрывает
         все открытые файлы. Функция _exit завершает все процессы без  об-
         новления буферов потока. Значение status обычно устанавливается в
         0  для указания нормального выхода и устанавливается в любое дру-
         гое значение для определения  ошибки.  Поскольку  вызовы  exit  и
         _exit  не возвращают значения, младший байт status является возв-
         ратом для ожидающего parent-процесса. Если  нет  parent-процесса,
         то значение status теряется.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См.также  abort,  execl,  execle,  execlp,  execv,  execve,
         execvp,  onexit,  spawnl,  spawnle,  spawnlp,  spawnv,   spawnve,
         spawnvp, system.

               Пример:

            #include <process.h>
            #include <stdio.h>

            FILE *stream;
            .
            .
            .

               /*  следующие  операторы вызывают завершение процесса после
         обновления буферов и закрытия открытых файлов */

            if((stream=fopen("data","r"))==NULL) {
                fprintf(stderr,"couldn't open data file\n");
                exit (1);
                }
               /* следующие операторы вызывают немедленное завершение про-
         цесса, если файл не может быть открытым */

            if((stream=fopen("data","r"))==NULL)

                {

                fprintf(stderr,"couldn't open data file\n");
                _exit (1);

                }


               EXP


            #include <math.h>

            double exp(x);
            double x;          значение с плавающей точкой

               Описание.

               Функция exp возвращает экспоненциальную функцию своего  ар-
         гумента x с плавающей точкой.

               Возвращаемое значение.

               Функция exp возвращает e в степени x. При переполнении фун-
         кция  возвращает  HUGE и устанавливает errno в ERANGE, при потере
         значимости exp возвращает 0, но не устанавливает errno.
               См.также log.

               Пример:

            #include <math.h>

            double x,y;
            .
            .
            .
            y = exp(x);.



               _EXPAND


            #include <malloc.h>    требуется только для объявления
                                   функции

            char *_expand(ptr,size);
            char *ptr;             указатель на ранее  захваченный
                                   блок памяти
            unsigned size;         новый размер в байтах


               Описание.

               Функция _expand изменяет размер  ранее  захваченных  блоков
         памяти,  пытаясь  расширить  или сузить блок без передвижения его
         местоположения в heap.
               Аргумент ptr указывает на начало блока. Аргумент size зада-
         ет новый размер блока в байтах. Содержимое блоков не изменяется.
               Аргумент ptr также указывает на освобождающийся блок до тех

         пор, пока не будут внешне вызваны calloc, _expand, halloc, malloc
         или realloc, либо пока блок будет свободен.
               Если ptr указывает на освобожденный блок, то этот блок  ос-
         тается свободным и после вызова _expand.

               Возвращаемое значение.

               Функция  _expand возвращает char-указатель на перезахвачен-
         ный блок памяти. В отличии от realloc, _expand не может  передви-
         гать  блок и изменять его размеры. Это означает, что аргумент ptr
         для _expand является тем же самым, что и  возвращаемое  значение,
         если  памяти  достаточно, чтобы расширить блок без его передвиже-
         ния.
               Возвращается значение NULL, если  памяти  недостаточно  для
         расширения блока. В этом случае объект, на который указывает ptr,
         будет расширен настолько, насколько позволяет его расположение.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.
               Новый размер объекта может быть проверен функцией _msize.
               Чтобы получить указатель, тип которого отличен от char, ис-
         пользуется преобразователь типа возвращаемого значения.
               См.также calloc, free, halloc, malloc, _msize, realloc.


               Пример:

            #include <stdio.h>
            #include <malloc.h>

            main()

              {
               long *oldptr;
               unsigned int newsize=64000;

               oldptr=(long*)malloc(10000*sizeof(long));
               printf("Size of memory block pointed to by
                      oldptr=%u\n", _msize(oldptr));

               if (_expand(oldptr,newsize)!= NULL)
                 printf("expand was able to increase block
                        to %u\n", _msize(oldptr));

               else
                printf("expand was able to increase block to
                       only %u\n", _msize(oldptr));
               }



               FABS

               #include <math.h>

               double fabs(x);
               double x;                    значение с плавающей точкой

               Описание:

               Функция fabs возвращает абсолютное значение своего аргумен-
         та с плавающей точкой.

               Возвращаемое значение:

               Функция fabs возвращает абсолютное значение своего аргумен-
         та. Возвращаемого значения в случае ошибки нет.
               См.также abs, cabs, labs.

               Пример:

               #include <math.h>

               double x,y;
               .
               .
               .
               y = fabs(x);.


               FCLOSE-FCLOSEALL

               #include <stdio.h>
               int fclose(stream);          закрывает открытый поток.
               FILE *stream;                указатель на структуру FILE.
               int fcloseall();             закрывает все открытые потоки.

               Описание.

               Функции  fclose, fcloseall закрывают соответственно поток и
         потоки. Перед закрытием все буферы, связанные с потоками,  обнов-
         ляются.  При  закрытии потока буферы, захваченные системой, осво-
         бождаются. Буферы, определенные функцией setbuf, автоматически не
         освобождаются .
               Функция fclose закрывает  заданный  поток  stream.  Функция
         fcloseall  закрывает  все  открытые потоки  за исключением stdin,
         stdout, stderr, stdaux, stdprn.

               Возвращаемое значение.

               Функция fclose возвращает 0, если поток удачно закрыт. Фун-
         кция fcloseall возвращает общее число закрытых потоков. В  случае
         ошибки обе функции возвращают значение EOF.
               См. также функции close, fdopen, fflush, fopen, freopen.


               Пример:

               #include <stdio.h>
               FILE *stream;
               int numclosed;
               stream=fopen("data", "r");
               .
               .
               .
               /* следующий оператор закроет поток */
               fclose (stream);
               /* следующий оператор закрывает все потоки, за исключением
               stdin, stdout, stderr, stdaux, stdprn */
               numclosed=fcloseall();


               FCVT

               #include <stdlib.h>          требуется только для  объявле-
                                            ния функ-
                                            ции.
               char fcvt (value, ndec, decptr, signptr);
               double value;                преобразуемое число.
               int ndec;                    количество цифр после десятич-
                                            ной точки.
               int *decptr;                 указатель на запомненную пози-
                                            цию десятичной точки.
               int *signptr;                указатель на запомненный инди-
                                            катор знака.

               Описание:

               Функция  fcvt  преобразует  число с плавающей точкой в сим-
         вольную строку. Value - число с плавающей точкой,  которое  нужно
         преобразовать.  Функция  fcvt  запоминает  цифры  из value в виде
         строки и добавляет к ней нулевой символ ('0\').
               В аргументе ndec запоминается количество цифр  после  деся-
         тичной точки.
               Если  количество цифр после десятичной точки в value превы-
         шает ndec, число  округляется,  как  это  делается  в  формате  F
         FORTRAN. Если цифр меньше, чем в ndec, строка дополняется нулями.
               В  строке хранятся только цифры. Позиция десятичной точки и
         знак числа value могут быть  получены  после  вызова  функции  из
         decptr  и  signptr.  Аргумент decptr указывает на целое значение,
         задающее позицию десятичной точки, считая от начала строки. 0 или
         отрицательное целое значение означают, что десятичная точка лежит
         левее самой первой цифры. Аргумент  signptr  указывает  на  целое
         значение, определяющее знак value: если целое signptr установлено
         в 0, то value - положительное, если целое signptr - ненулевое, то
         value - отрицательное.

               Возвращаемое значение:

               Функция fcvt возвращает указатель на строку цифр. Возвраща-
         емого значения в случае ошибки нет.
               См.также atol, atof, atoi, ecvt, gcvt.


               Замечание!  Функции ecvt и fcvt используют для преобразова-
         ния один и тот же статически распределенный буфер. Каждое обраще-
         ние к одной из этих процедур уничтожает результат предыдущего об-
         ращения.

               Пример.

               #include <stdlib.h>
               int decimal, sign;
               char *buffer;
               int precision = 10;
               buffer = fcvt (3.1415926535, precision,&decimal,&sign);
               /*buffer ="31415926535", decimal=1, sign=0*/


                FDOPEN

               #include <stdio.h>
               FILE *fdopen (handle,type);
               int handle;                  Handle-р, ссылающийся на отк-
                                            рытый файл.
               char type;                   Разрешенный тип доступа.

               Описание:

               Функция fdopen связывает поток ввода/вывода с файлом, иден-
         тифицированным  handle,  что позволяет сделать файл, открытый как
         низкоуровневый, форматированным и буферизованным. Более  подробно
         этот процесс описан в разделе 4.7 "Ввод и вывод" данного руковод-
         ства.  Символьная строка type определяет тип доступа к требуемому
         файлу следующим образом:

            ТИП                   ОПИСАНИЕ

            "r"          Открыть  для  чтения.  (Этот файл  должен
                         существовать).

            "w"          Открыть пустой файл для записи; если этот
                         файл  ранее  существовал,  его содержимое
                         уничтожается.

            "a"          Открыть файл для  записи  (добавления)  в
                         конец  файла.  Создать  файл заново, если
                         его нет.

            "r+"         Файл открыт  одновременно  для  чтения  и
                         записи. Файл должен существовать.

            "w+"         Открыть  пустой  файл для чтения и записи.
                         Если  этот   файл   существует,  то    его
                         сожержимое уничтожается.

            "a+"         Файл для  чтения  и  добавления.   Создать
                         файл  заново, если его нет.


               Замечание! Нужно внимательно применять  режимы  "w",  "w+",
         так  как они могут уничтожить существующие файлы. Специфицирован-
         ный type должен быть совместим с режимами доступа или sharing-ре-
         жимом, с которым файл был открыт. За поддержку этой совместимости
         отвечает пользователь.
               Если файл открыт с типом "a" или "a+", все операции  записи
         выполняются  в  конец файла, хотя при использовании функций fseek
         или rewind  возможно перемещение файлового указателя; однако, пе-
         ред выполнением любых операций записи он  всегда  возвращается  в
         конец  файла.  Таким  образом, существующие данные не смогут быть
         перезаписанными. Когда специфицированы типы "r+", "w",  "a",  од-
         новременно допускается чтение и запись. (Говорят, что файл открыт
         для обновления). Поэтому  при переключении чтения на запись и на-
         оборот,  нужно использовать функции fseek или rewind. Для функции
         fseek (при необходимости) может быть специфицирована текущая  по-
         зиция.
               Дополнительно к значениям, приведенным выше, может быть до-
         бавлен один из следующих символов к строке type, чтобы специфици-
         ровать режим преобразования символов новой строки.

            Символ               Значение

              t          Открыть   в   текстовом   (транслирующем)
                         режиме; ввод комбинации "Возврат  каретки
                         - перевод   строки"   преобразовывать   к
                         единственному  символу "перевод  строки".
                         Вывод  символа "перевод строки"  преобра-
                         зовывать в комбинацию "Возврат каретки  -
                         перевод строки".

              b          Открыть  в   двоичном   (нетранслирующем)
                         режиме; предшедствующие    преобразования
                         подавляются.

               Если t или b в строке type не заданы, то режим преобразова-
         ния определяется переменной _fmode, устанавливаемой по умолчанию.


               Возвращаемое значение.

               Функция  fdopen  возвращает  указатель на открытый поток. В
         случае ошибки значение указателя равно NULL.
               См. также dup, dup2,  fclose,  fcloseall,  fopen,  freopen,
         open.

               Пример:

               #include <stdio.h>
               #include <fcntl.h>
               FILE *stream;
               int fh;
               fh=open("data", O_RDONLY);
               /*  следующий  оператор  позволяет связать поток с открытым
         файлом */

               stream = fdopen(fh, "r");.


               FEOF

               #include <stdio.h>
               int feof(stream);
               FILE *stream;                указатель на структуру FILE.

               Описание.

               Функция feof определяет, достигнут ли конец заданного пото-
         ка. Если конец файла (EOF) достигнут, то операции чтения  возвра-
         щают индикатор конца файла  пока поток не будет закрыт или вызва-
         на функция rewind.

               Возвращаемое значение.

               Если  текущая  позиция является концом файла (EOF), функция
         feof возвращает ненулевое значение. Если текущая позиция не явля-
         ется концом файла - возвращается значение 0. Функция feof  ошибок
         не возвращает.
               См. также clearerr, eof, ferror, perror.

               Замечание! Функция feof реализуется как макро.

               Пример:

               #include <stdio.h>
               char string[100];
               FILE *stream;
               /*  следующие  операторы  обеспечивают  ввод строк, пока не
         встретится EOF */
               while (!feof(stream))
               if (fscanf(stream, "%s", string))
               process (string);.


               FERROR

               #include <stdio.h>
               int ferror (stream);
               FILE *stream;                указатель на структуру FILE.


               Описание.

               Функция ferror проверяет ошибки чтения и  записи  заданного
         потока. При возникновении ошибки индикатор ошибки stream остается
         установленным  до тех пор, пока поток не закроется или "разрушит-
         ся" (rewound)  или же пока не будет вызвана функция clearerr.


               Возвращаемое значение.


               В случае обнаружения ошибки в потоке  функция ferror  возв-
         ращает ненулевое значение. Возвращаемое значение 0 свидетельству-
         ет об отсутствии ошибки.
               См. также clearerr, eof, ferror, perrpr.
               Эта функция реализуется как макро.

               Пример:

               #include <stdio.h>
               FILE *stream;
               char *string;
               .
               .
               .

               /*  следующие  операторы вводят данные в поток и проверяют,
         не возникла ли ошибка при записи. Перед записью данных  в  поток
         он должен быть предварительно открыт */
               fprintf (stream, "%s\n", string);
               if (ferror(stream))
               { fprintf (stderr, "write error\n");
               clearerr (stream;
                                }

               FFLUSH


               #include <stdio.h>
               int fflush (stream);
               FILE *stream;                указатель на структуру FILE.

               Описание.

               Если заданный поток stream открыт для вывода, то содержимое
         буфера,  связанного с потоком stream функции fflush, записывается
         в соответствующий файл. Если поток открыт для ввода,  то  функция
         fflush  очищает содержимое буфера. После вызова функции поток ос-
         тается открытым. Для  небуферизованного  потока  применение  этой
         функции не эффективно.

               Возвращаемое значение.

               Функция  fflush  возвращает 0, если буфер успешно обновлен.
         Это же значение возвращается, когда поток  не  имеет  буфера  или
         когда  он открыт только для чтения. В случае возникновения ошибки
         возвращается значение EOF.
               См. также fclose, fflushall, setbuf.

               Замечание! Буферы автоматически обновляются, когда они пол-
         ны, когда поток закрывается или  произошло  нормальное  окончание
         работы программы без закрытия потока.

               Пример:

               #include <srtio.h>

               FILE *stream;
               char buffer[BUFSIZ];
               .
               .
               .
               /*  следующие  два оператора обновляют буфер потока и уста-
         навливают новый буфер для потока */
               fflush (stream);
               setbuf (stream, buffer);.


               _FFREE

               #include <malloc.h>          требуется только для  объявле-
                                            ния  функции.
               void _ffree(ptr);
               char far *ptr;               указатель на захваченный блок
                                            памяти.

               Описание.

               Функция  _ffree  освобождает  блок памяти вне умалчиваемого
         сегмента данных. Аргумент ptr указывает на ранее захваченный блок
         памяти посредством вызова функции _fmalloc.
               Числом освободивщихся байтов является число байтов, опреде-
         ленных при захвате (размещении) блока. После вызова освободивший-
         ся блок вновь пригоден для захвата.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См.также _fmalloc, free, maloc.

               Замечание! Попытка освободить неверный  ptr  (указатель  не
         захватывается посредством _fmalloc) может привести к последующему
         захвату и вызвать ошибки.

               Пример:

               #include <malloc.h>
               #include <stdio.h>
               char far *alloc;
               /* Захватывает 100 байтов и затем освобождает их */
               if ((alloc=_fmalloc(100))==NULL)
               /* проверяет на правильность указателя */
               printf("unable to allocate memory\n");
               else   {
               .
               .
               .
               _ffree(alloc);
               /* освобождает память для heap */
               }



               FGETC-FGETCHAR


               #include <stdio.h>
               int fgetc (stream);          читает символ из потока.
               FILE *stream                 указатель на структуру FILE.
               int fgetchar();              читает символ из stdin.

               Описание.

               Функция  fgetc  читает отдельный текущий символ из входного
         потока stream и увеличивает соответствующий  указатель  (если  он
         есть)  для  указания  следующего  считываемого  символа.  Функция
         fgetchar является эквивалентной функции fgetc(stdin).

               Возвращаемое значение.

               Эти две функции возвращают считанный символ. В случае  воз-
         никновения ошибки или достижения конца файла  возвращается значе-
         ние EOF; однако, значение EOF может быть воспринято как целая ве-
         личина,  тогда  нужно использовать функции ferror и feof для про-
         верки ошибки или конца файла.
               См. также fputc, fputchar, getc, getchar.

               Замечание! Процедуры fgetc  и  fgetchar  идентичны  getc  и
         getchar, но они являются функциями, а не макро.

               Пример:

               #include <stdio.h>
               FILE *stream;
               char buffer[81]; int i; int ch;
               . . .
               /* следующие операторы выбирают строку из потока */
               for (i=0;  (i<80)  &&  ((ch=fgetc(stream))  !=EOF)  &&
               (ch!='\n'); i++)
               buffer[i]=ch;
               buffer[i]='\0';
               /* В вышеприведенных  операторах для сбора строки из потока
         stdin   вместо   fgetc(stream)   должна  быть  применена  функция
         fgetchar(). То же эквивалентно для fgetc(stdin). */


               FGETS


               #include <stdio.h>
               char *fgets(string, n, stream);читает  строку  из  потока
                                              stream.
               char *string;                  память для хранения данных.
               int n;                         число сохраняемых символов.
               FILE *stream;                  указатель на структуру FILE.



               Описание.

               Функция  fgets  читает  строку  из входного потока stream и
         располагает ее в string. Символы считываются, начиная  с  текущей
         позиции stream, до символа новой строки '\n'  или до конца потока,
         либо пока число считанных символов не станет равным n-1.  Резуль-
         тат  размещается в string, а затем к нему добавляется символ null
         -'\0'. Символ новой строки также включается в string. Если в нача-
         ле считывания n равнялось 1, то string будет пустой (""). Функция
         fgets аналогична библиотечной функции gets, однако, gets заменяет
         символ новой строки нулевым символом.

               Возвращаемое значение.

               Функция fgets возвращает указатель на строку string. В слу-
         чае ошибки или конца файла  возвращается значение NULL. Для опре-
         деления того, что произошло - ошибка или конец файла, используют-
         ся функции feof и ferror.
               См. также fputs, gets, puts.

               Пример:

               include <stdio.h>
               FILE *stream;
               char line[100], *result;
               /* следующий оператор выбирает строку  символов  из  потока
         stream. Может быть считано не более 99 символов  либо все символы
         до символа новой строки '\n', включая и его. */
               result = fgets(line, 100, stream);.


               FIEEETOMSBIN-FMSBINTOIEEE


               #include <math.h>
               int  fieeetomsbin(src4,dst4);преобразует число с плавающей
                                            точкой в формате.
                                            IEEE в двоичный формат с пла-
                                            вающей точкой MS.
               int fmsbintoieee(src4,dst4); преобразует число  в  двоичном
                                            формате MS  с плавающей точкой
                                            в  число с  плавающей точкой в
                                            формате IEEE.

               Описание.

               Процедура  fieeetomsbin  преобразовывает  число с одинарной
         точностью и с плавающей точкой в формате IEEE к двоичному формату
         Microsoft.
               Процедура fmsbintoieee преобразовывает  число  с  плавающей
         точкой в двоичном формате Microsoft к формату IEEE.
               Эти  процедуры  позволяют программам Си, которые записывают
         числа с плавающей точкой в формат  IEEE,  использовать  численные
         данные  в  полях  данных случайного доступа, созданные при помощи
         Microsoft BASIC, который записывает числа с  плавающей  точкой  в
         двоичный формат Microsoft и наоборот.

               Аргумент  scr4  указывает  на преобразуемое float-значение.
         Результат записывается в расположение, заданное аргументом dst4.

               Возвращаемое значение.

               Эти функции возвращают 0, если преобразование было успешным
         и 1, если преобразование повлекло переполнение.
               См.также dieeetomsbin, dmsbintoieee.

               Замечание! Эти процедуры не обрабатывают IEEE NAN и  беско-
         нечность. Необычные IEEE трактуются в преобразованиях как 0.


               FILELENGTH


               #include <io.h>              требуется только для объявле-
                                            ния функции.
               long filelength(handle);
               int handle;                  handle-р, ссылающийся на  от-
                                            крытый файл.

               Описание.

               Функция filelength возвращает в байтах длину файла, связан-
         ного с заданным handle.

               Возвращаемое значение.

               Функция filelength возвращает длину файла в байтах. Возвра-
         щаемое значение -1L свидетельствует об ошибке  и errno устанавли-
         вается в EBADF, чтобы указать на неверный файловый handle.
               См.также chsize, fileno, fstat, stat.

               Пример:

               #include <io.h>
               #include <stdio.h>
               #include <stdlib.h>
               FILE *stream;
               long length;
               stream=fopen("data","r");
               .
               .
               .
               /*  следующие операторы пытаются определить ** длину файла,
         связанного с потоком stream */
               length=filelength(fileno(stream));
               if(length==-1L)
               perror("filelength failed");.




               FILENO

               #include <stdio.h>
               int fileno (stream);
               FILE *stream;                указатель на структуру FILE.

               Описание.

               Функция fileno возвращает  текущий  handle  (номер)  файла,
         связанный  с потоком stream. Если поток связан более  чем с одним
         handle-ром  и когда поток предварительно открыт, в качестве возв-
         ращаемого значения определяется handle.

               Возвращаемое значение.

               Функция fileno возвращает handle-р файла; в случае ошибки -
         возвращаемого значения нет. Если поток stream не задан как откры-
         тый файл, тогда возвращаемое значение не определено.
               См. также fdopen, filelength, fopen, freopen.

               Замечание! Fileno реализуется как макро.

               Пример:

               #include <stdio.h>
               int result;
               /* следующий оператор определяет handle  файла  для  потока
         stderr*/
               result= fileno(stderr);      /* результат равен 2 */


               FLOOR


               #include <math.h>
               double floor(x);
               double x;                    значение с плавающей точкой.

               Описание.

               Функция floor возвращает значение с плавающей точкой, пред-
         ставляющее наибольшее целое, которое меньше или равно x.

               Возвращаемое значение.

               Функция floor возвращает результат с плавающей точкой. Воз-
         вращаемого значения в случае ошибки нет.
               См.также ceil, fmod.

               Пример:

               #include <math.h>
               double y;
               .
               .
               .
               y = floor(2.8); /* y = 2.0 */

               y = floor(-2.8); /* y = -3.0 */


               FLUSHALL


               #include <stdio.h>
               int flushall();

               Описание.

               Функция  flushall  записывает содержимое всех буферов, свя-
         занных с открытыми input потоками, в соответствующие  файлы.  Все
         буферы, связанные с открытыми потоками, очищаются; следующая опе-
         рация  чтения  (если  она есть) считывает новые данные из входных
         файлов в буферы. После вызова функции flushall  все потоки  оста-
         ются открытыми.

               Возвращаемое значение.

               Данная   функция  возвращает  количество  открытых  потоков
         (входных и выходных). В случае ошибки возвращаемого значения нет.
               См. также fflush.

               Замечание! Буферы автоматически обновляются, когда они пол-
         ны, когда потоки закрываются или происходит нормальное завершение
         работы программы без закрытия потоков.

               Пример:

               #include <stdio.h>
               int numopen;
               .
               .
               .
               /* следующий оператор ожидает любой ввод/вывод во все пото-
         ки */
               numopen=flushall();.


               _FMALLOC


               #include <malloc.h>          требуется только для  объявле-
                                            ния  функции.
               char far *_fmalloc(size);
               unsigned size;               количество  байтов в захвачен-
                                            ном блоке.

               Описание.

               Функция  _fmalloc  захватывает  вне  умалчиваемого сегмента
         данных блок памяти, по крайней мере не меньший, чем блок из  size
         байтов.  (Блок может быть больше, чем из size байтов, принадлежа-
         щих пространству, которое требуется для выравнивания).


               Возвращаемое значение.

               Функция _fmalloc возвращает far-указатель на char. В  памя-
         ти, на которую указывает возвращаемое значение, гарантировано вы-
         равнивание  для хранения любого типа объекта. Чтобы получить ука-
         затель на тип, отличный от char, используется преобразователь ти-
         па возвращаемого значения.
               Функция _fmalloc возвращает far-указатель на char. Если вне
         умалчиваемого сегмента данных памяти не достаточно, то захват па-
         мяти будет повторен снова, используя и этот сегмент. Если  памяти
         снова недостаточно, возвращаемое значение равно NULL.
               См.также _ffree, _fmsize, malloc, realloc.

               Пример:

               #include <malloc.h>
               int *intarray;
               /* захватывает пространство для 20 целых */
               intarray=(int*)_fmalloc(20*sizeof(int));.


               FMOD


               #include <math.h>
               double fmod(x,y);
               double x; значение с плавающей точкой.
               double y;

               Описание.

               Функция  fmod вычисляет остаток от деления x на y с плаваю-
         щей точкой, где x=iy+f, i - целое, f - имеет тот же знак, что  x;
         а абсолютное значение x меньше, чем абсолютное значение y.

               Возвращаемое значение.

               Функция  fmod возвращает остаток с плавающей точкой. Если y
         равно 0, функция возвращает 0.
               См.также ceil, fabs, floor.

               Пример:

               #include <math.h>
               double x,y,z;
               x = -10.0;
               y = 3.0;
               z = fmod(x,y); /* z = -1.0 */.


               _FMSIZE


               #include <malloc.h>          требуется только для  объявле-

                                            ния  функции.
               unsigned _fmsize(ptr);
               char far *ptr;               указатель на блок памяти.


               Описание.

               Функция  _fmsize  возвращает  размер в байтах блока памяти,
         захваченного посредством вызова _fmalloc.


               Возвращаемое значение.

               Функция _fmsize возвращает размер в байтах как  беззнаковое
         целое.
               См.также   _ffree,   _fmalloc,   malloc,   _msize,  _nfree,
         _nmalloc, _nmsize.

               Пример:

               #include <malloc.h>
               #include <stdio.h>
               main()
               {
               char far *stringarray;
               stringarray=_fmalloc(200*sizeof(char));
               if (stringarray != NULL)
                   printf("%u bytes allocated\n",
                       _fmsize(stringarray));
               else
                   printf("Allocation request failed.\n");
               }


               FOPEN


               #include <stdio.h>
               FILE *fopen(pathname, type);
               char *pathname;              path-имя файла.
               char *type;                  разрешенный тип доступа.

               Описание.

               Функция fopen  открывает  файл,  определяемый  path-именем.
         Символы  в строке type определяют тип доступа, требуемый для фай-
         ла, следующим образом.

            РЕЖИМ                   ОПИСАНИЕ

            "r"          открыть файл для чтения.(Этот файл должен
                         существовать).

            "w"          открыть пустой файл для записи; если этот
                         файл  ранее  существовал,  его содержимое

                         уничтожается.

            "a"          открыть файл для  записи  (добавления)  в
                         конец. Если данного файла нет, то вначале
                         он создается.

            "r+"         открыть файл одновременно  для  чтения  и
                         записи. Файл должен существовать.

            "w+"         открыть  пустой файл для чтения и записи.
                         Если этот  файл  ранее  существовал,  его
                         сожержимое уничтожается.

            "a+"         открыть  файл  для  чтения и  добавления.
                         Если файла нет, вначале он создается.

               Замечание! Нужно внимательно применять  режимы  "w",  "w+",
         так как они могут уничтожить существующие файлы.

               Если файл открыт при помощи типа "a" или "a+", все операции
         записи выполняются в конец файла. При использовании функций fseek
         или rewind  возможно перепозиционирование указателя на файл; нес-
         мотря  на это, указатель на файл перед выполнением любых операций
         записи всегда возвращается в конец файла. Таким образом,  сущест-
         вующие  данные  не  будут  перезаписаны.  При использовании типов
         "r+', "w+", "a+" допускается одновременно чтение и запись. (Гово-
         рится, что файл открывается для обновления). Поэтому, при  перек-
         лючении  чтения  на запись и наоборот  нужно использовать функции
         fseek или rewind. Для функции  fseek  (при  необходимости)  может
         быть точно определена текущая позиция.
               Дополнительно  к  значениям, описанным выше, может быть до-
         бавлен в строке type один из следующих символов, чтобы специфици-
         ровать способ преобразования символа новой строки.


            Символ               Значение

              t          открыть   в   текстовом   (преобразующем)
                         режиме;  при  вводе  комбинация  "Возврат
                         каретки      -      перевод       строки"
                         преобразовывается к единственному символу
                         "перевода  строки".  При  выводе   символ
                         перевода   строки   преобразовывается   в
                         комбинацию ВК-ПС.

              b          открыть   в   двоичном  (непреобразующем)
                         режиме; выше описанные преобразования  не
                         осуществляются.


               Если t или b в строке type не задается, режим  преобразова-
         ния  определяется переменной _fmode и режимом, устанавливаемым по
         умолчанию.



               Возвращаемое значение.

               Функция fopen возвращает указатель на открытый файл. Значе-
         ние указателя NULL свидетельствует об ошибке.
               См.также  fclose,  fcloseall,   fdopen,   ferror,   fileno,
         freopen, open, setmode.

               Пример:

               #include <stdio.h>
               main (argc, argv)
               int argc;
               char *argv[];
               {
               FILE *stream;
               /*  применение  fopen  позволяет открыть файл, имя которого
         хранится в указателе argv[argc-1]; если это не удается, программа
         распечатывает сообщение об ошибке */
               if ((stream= fopen(argv[argc-1]), "r"))==NULL)
                  { fprintf (stderr, "%s не может открыть файл %s\n",
                             argv[0], argv[argc-1]);
                   exit(1);
               }
               /* Замечание! Имя программы хранится в argv[0]  только  для
         версий  MS  DOS  3.0  и последующих; в предыдущих версиях MS DOS,
         argv[0] содержится в строке "Си" */
               Образец командной строки:

               update employ.dat

               На выходе будет сообщение:

               "C:\BIN\UPDATE.EXE не может открыть файл employ.dat ".


               FP_OFF - FR_SEG

               #include <dos.h>
               unsigned FP_OFF(longptr);
               unsigned FP_SEG(lohgptr);
               char far *longptr;          long-указатель на адрес памяти.

               Описание.

               Макро FP_OFF и FP_SEG могут  использоваться  соответственно
         для   установки  разветвления  или  взятия  сегмента  посредством
         long-указателя longptr.

               Возвращаемое значение.

               Макро FP_OFF возвращает беззнаковое целое значение,  предс-
         тавляющее разветвление.
               Макро  FP_SEG возвращает беззнаковое целое значение, предс-
         таляющее адрес сегмента.
               См.также segread.


               Пример.

               #include <dos.h>

               char far *p;
               unsigned int seg_val;
               unsigned int off_val;
               .
               .
               .
               seg_val=FP_SEG(p);
               off_val=FP_OFF(p);



               _FPRESET

               #include <float.h>
               void _fpreset();             переинициализирует математиче-
                                            ский пакет с плавающей точкой.

               Описание:

               Функция  _fpreset переинициализирует математический пакет с
         плавающей точкой. Эта функция обычно используется  с  процедурами
         signal, system или с семейством процедур exec, spawn.
               Если программа вместе с функцией signal захватывает сигналы
         ошибок  с  плавающей  точкой (SIGFPE), то она при вызове _fpreset
         благополучно восстанавливается из ошибок с плавающей точкой и вы-
         полняет longjmp.

               Замечание!  В  версиях  MS  DOS,  более  ранних  чем   4.0,
         child-процесс, выполнимый в exec, spawn или system, может воздей-
         ствовать  на  состояние  с плавающей точкой parent-процесса, если
         используется 8087 или 80287 сопроцессор. Поэтому, если  использу-
         ется сопроцессор 8087 либо 80287, рекомендуются помнить, что:
               * exec, spawn, system не могут вызываться в процессе вычис-
         ления выражения с плавающей точкой;
               *  _fpreset  должна  быть вызвана после этих процедур, если
         child-процесс может выполнить требуемую операцию.

               Возвращаемое значение:

               Возвращаемого значения нет.
               См.также execl, execle,  execlp,  execlpe,  execv,  execve,
         execvp,  execvpe,  signal,  spawnl,  spawnle,  spawnlp, spawnlpe,
         spawnv, spawnve, spawnvp, spawnvpe.

               Пример.

               #include <stdio.h>
               #include <signal.h>
               #include <setjmp.h>
               #include <float.h>


               int fphandler ();
               jmp_buf mark;
               double a = 1.0, b = 0.0, c;

               main()
               {
               if(signal(SIGFPE, fphandler)==(int(*)())-1)
                   abort();
               if(setjmp(mark)==0)  {
                   c = a/b;
                   printf("Should never get here\n");
                   }
               printf("Recovered from floating-point error\n");
               }

               int fphandler(sig,num)
               int sig,num;

               {
               printf("signal=%d subcode =%d\n",sig,num);
               _fpreset();
               /* переинициализирует пакет с плавающей точкой */
               longjmp(mark,-1);
               }

               FPRINTF

               #include <stdio.h>

               int fprintf (stream, format-string [, argument ...]);

               FILE *stream; указатель на структуру FILE.

               char *format-string; строка управления форматом.

               Описание:

               Функция fprintf форматирует и печатает в выходной поток на-
         боры символов и значений. Каждый аргумент (если он есть) преобра-
         зуется и выводится согласно заданной спецификации формата в стро-
         ке формата. Строка формата (format-string) обладает той же формой
         и функцией, что и аргумент строки формата функции printf.

               Возвращаемое значение:

               Эта функция возвращает количество напечатанных символов.
               См. также cprintf, fscanf, printf, sprintf.

               Пример.

               #include <stdio.h>

               FILE *stream;
               int i = 10;

               double fp = 1.5;
               char *s = "это строка";
               char c = '\n';

               stream = fopen("result", "w");

               /* форматирование и печать различных данных */

               fprintf (stream, "%s%c", s, c);
               /* печать выражения "это - новая строка", а  затем  символа
         новой строки */

               fprintf (stream, "%d\n", i);
               /* печать числа 10, а затем символа новой строки */

               fprintf (stream, "%f", fp);
               /* печать числа 1.500000 */


               FPUTC-FPUTCHAR.

               #include <stdio.h>
               int fputc (c, stream); записывает символ в поток stream.
               int c; записываемый символ.

               FILE *stream; указатель на структуру FILE.

               int fputchar (c); записывает символ в поток stdout.
               int c; записываемый символ.


               Описание:

               Функция  fputc  записывает  отдельный символ "с" в выходной
         поток stream. Функция fputchar является эквивалентной  к  функции
         fputc(c, stream).

               Возвращаемое значение:

               Эти  обе функции возвращают записанный символ. Возвращаемое
         значение EOF свидетельствует об ошибке; однако, поскольку  значе-
         ние  EOF является также истинным целым значением, то для проверки
         соглашений об ошибке используют функцию ferror.

               Замечание! Процедуры fputc  и  fputchar  идентичны  putc  и
         putchar, но они являются функциями, а не макро.
               См. также fgetc, fgetchar, putc, putchar.

               Пример.

               #include <stdio.h>

               FILE *stream;
               char buffer[81];
               int i;

               int ch;


               .
               .
               .
               /*  Следующие  операторы записывают содержимое буфера в по-
         ток. Заметим, что вывод представлен как  побочный  эффект  внутри
         второго выражения, а также тело оператора пусто. */

               for (i = 0; (i < 81) &&
                 ((ch = fputc(buffer[i], stream)) != EOF); i++)
                            ;

               /*  В  приведенном выше операторе для записи буфера в поток
         stdout можно было бы использовать вместо "fputc (stream)" функцию
         "fputchar ()".*/


               FPUTS

               #include <stdio.h>
               int fputs  (string,  stream);  записывает  строкe  в  поток
         stream.
               char *string; выводимая строка.
               FILE *stream; указатель на структуру FILE.

               Описание:

               Функция  fputs копирует строку в конец потока stream. Нуле-
         вой символ окончания '\0' не копируется.

               Возвращаемое значение:

               Функция fputs возвращает последний записанный символ.  Если
         вводимая  строка string пустая, возвращается значение 0. Значение
         EOF свидетельствует об ошибке.
               См. также fgets, gets, puts.

               Пример.

               #include <stdio.h>

               FILE *stream;
               int result;
               .
               .
               .
               /* Следующий оператор записывает строку в поток */

               result = fputs("файл данных должен быть обновлен\n",stream).



               FREAD


               #include <stdio.h>
               int fread (buffer, size, count, stream);

               char *buffer; память для размещения данных.
               int size; размер в байтах.
               int count; максимальное число объектов для чтения.

               FILE *stream; указатель на структуру FILE.

               Описание:

               Данная функция читает  объекты  размера  size  по  счетчику
         count из входного потока stream и располагает их в буфере buffer.
         Указатель  на  файл,  связанный  с потоком stream (если он есть),
         увеличивается на число прочитанных байтов. Если  выбранный  поток
         открыт  в  текстовом  режиме,  комбинация "ВК - ПС" заменяется на
         символ "ПС". Эта замена не влияет ни на указатель на файл, ни  на
         возвращаемое значение.

               Возвращаемое значение:

               Функция  fread  возвращает  число действительно прочитанных
         объектов, которое меньше, чем count,  если  при  чтении  возникла
         ошибка или встретился конец файла.
               См. также fwrite, read.

               Пример:

               #include <stdio.h>

               FILE *stream;
               long list[100];
               int numread;

               stream = fopen("data", "r+b");

               /*  следующий оператор позволяет считать 100 двоичных длин-
         ных целых из потока stream */

               numread = fread((char *)list, sizeof(long), 100, stream);.


               FREE

               #include <maloc.h> требуется только для объявления функции.

               void free(ptr);
               char *ptr; указатель на захваченный блок памяти.

               Описание:

               Функция free освобождает блок памяти. Аргумент ptr указыва-
         ет на ранее захваченный блок памяти  посредством  вызова  calloc,
         malloc,  realloc. Числом освобожденных байтов является число бай-
         тов, определенных при захвате блока (или перезахвате). После  вы-

         зова освободившийся блок доступен для захвата.


               Возвращаемое значение:

               Возвращаемого значения нет.
               См.также calloc, malloc, realloc.

               Замечание!  Попытка  освободить  неверный ptr (указатель не
         захватывается посредством вызова calloc, malloc или realloc)  мо-
         жет привести к следующему захвату и вызвать ошибку.

               Пример.

               #include <malloc.h>
               #include <stdio.h>

               char *alloc;

               /* захватывает 100 байтов и освобождает их */

               if ((alloc=malloc(100))==NULL

               /* проверяет на правильность указателя */

               printf("unable to allocate memory\n");
               else {
               .
               .
               .
               free(alloc);

               /* освобождает память для heap */

               }


               _FREECT

               #include  <malloc.h>  требуется только для объявления функ-
         ции.

               unsigned int _freect(size);
               unsigned int size; размер объекта в байтах.


               Описание:

               Функция _freect сообщает о количестве памяти, пригодной для
         размещения динамической памяти, и возвращает приблизительное  ко-
         личество вызовов в программе malloc для размещения объекта задан-
         ного размера в умалчиваемом сегменте данных.



               Возвращаемое значение:

               Функция _freect возвращает число  вызовов  как  беззнаковое
         целое.
               См.также calloc, _expand, malloc, _memavl, _msize, realloc.


               Пример.

               main()
               {
               int i;
               printf("Approximate # of times program can call
                     malloc\n");
               printf("to allocate a single integer=%u\n\n",
                     _freect(sizeof(int)));

               /*  вызывает 1000 раз malloc, размещая каждый раз отдельное
         целое */

               for (i=0; i<1000; ++i)
               malloc(sizeof(int));

               printf("Approximate # of times program can call
                     malloc\n");
               printf("to allocate a single integer=%u\n",
                     _freect(sizeof(int)));

               }


               FREOPEN

               #include <stdio.h>
               FILE *freopen (pathname, type, stream);

               char *pathname; path-имя нового файла.
               char *type; разрешенный тип доступа.

               FILE *stream; указатель на структуру FILE.


               Описание:

               Функция freopen закрывает текущий файл, связанный с потоком
         stream, и переназначает этот поток в файл, определяемый path-име-
         нем. Эта функция обычно применяется для переадресации  предоткры-
         тых  потоков stdin, stdout, stderr, stdaux, stdprn в файлы, опре-
         деляемые пользователем. Новый файл, связанный с потоком, открыва-
         ется в режиме type, который определен следующим образом:


            ТИП                   ОПИСАНИЕ

            "r"          открыть файл для чтения.(Этот файл должен
                         существовать).


            "w"          открыть пустой файл для записи; если этот
                         файл  ранее  существовал,  его содержимое
                         уничтожается.

            "a"          открыть файл для  записи  (добавления)  в
                         конец. Если данного файла нет, то вначале
                         он создается.

            "r+"         открыть файл одновременно  для  чтения  и
                         записи. Файл должен существовать.

            "w+"         открыть  пустой файл для чтения и записи.
                         Если этот  файл  ранее  существовал,  его
                         сожержимое уничтожается.

            "a+"         открыть  файл  для  чтения и  добавления.
                         Если файла нет, вначале он создается.

               Замечание! Нужно внимательно применять  режимы  "w",  "w+",
         так как они могут уничтожить существующие файлы.

               Если файл открыт при помощи типа "a" или "a+", все операции
         записи выполняются в конец файла. При использовании функций fseek
         или rewind  возможно перепозиционирование указателя на файл; нес-
         мотря  на это, указатель на файл перед выполнением любых операций
         записи всегда возвращается в конец файла. Таким образом,  сущест-
         вующие  данные  не  будут  перезаписаны.  При использовании типов
         "r+', "w+", "a+" допускается одновременно чтение и запись. (Гово-
         рится, что файл открывается для обновления). Поэтому  при  перек-
         лючении  чтения  на запись и наоборот  нужно использовать функции
         fseek или rewind. Для функции  fseek  (при  необходимости)  может
         быть точно определена текущая позиция.
               Дополнительно  к  значениям, описанным выше, может быть до-
         бавлен в строке type один из следующих символов, чтобы специфици-
         ровать способ преобразования символа новой строки.

            Символ               Значение

              t          открыть   в   текстовом   (преобразующем)
                         режиме;  при  вводе  комбинация  "Возврат
                         каретки      -      перевод       строки"
                         преобразовывается к единственному символу
                         "перевода  строки".  При  выводе   символ
                         перевода   строки   преобразовывается   в
                         комбинацию ВК-ПС.

              b          открыть   в   двоичном  (непреобразующем)
                         режиме; выше описанные преобразования  не
                         осуществляются.

               Если t или b в строке type не задается, режим  преобразова-
         ния  определяется переменной _fmode и режимом, устанавливаемым по
         умолчанию.



               Возвращаемое значение:

               Функция freopen  возвращает  указатель  на  вновь  открытый
         файл.  Если  возникла ошибка, прежний файл закрывается  и функция
         возвращает значение указателя NULL.
               См. также fclose, fcloseall, fdopen, fileno,  fopen,  open,
         setmode.

               Пример.

               #include <stdio.h>

               FILE *stream;
               .
               .
               .
               /* следующий оператор закрывает поток stdout и переназнача-
         ет этот поток указателю потока. */

               stream = freopen ("data2", "w+", stdout);.


               FREXP

               #include <math.h>

               double frext(x,expptr);
               double x; значение с плавающей точкой.
               int *expptr; указатель на целую экспоненту.

               Описание:

               Функция  frexp  разрывает  значение с плавающей точкой x на
         мантиссу m и экспоненту n, так что абсолютное значение  m  больше
         или  равно 0.5 и меньше 10 и x равен m, умноженную на 2 в степени
         n. Целое значение экспоненты n хранится в расположении, указанном
         по expptr.


               Возвращаемое значение:

               Функция frext возвращает мантиссу m. Если x равен 0,  функ-
         ция  возвращает 0 для мантиссы и экспоненты. Возвращаемого значе-
         ния в случае ошибки нет.
               См.также ldex, modf.

               Пример.

               #include <math.h>

               double x,y;
               int n;
               .
               .
               .

               x = 16.4;
               /* y будет равен .5125, n будет равно 5 */
               y = frexp(x,&n);


               FSCANF.

               #include <stdio.h>
               int fscanf (stream, format-string [, argument ...]);

               FILE *stream; указатель на структуру FILE.
               char *format-string; строка управления форматом.

               Описание:

               Функция fscanf считывает данные из текущей  позиции  потока
         stream  в место, определяемое заданием аргументов arguments (если
         они есть).
               Каждый аргумент должен быть указателем на переменную и тип,
         которые соответствуют типу, заданному в  строке  формата.  Строка
         формата  управляет интерпретацией полей ввода и имеет ту же самую
         форму и назначение, что и аргумент  строки  формата  для  функции
         scanf. (Описание функции scanf приводится ниже в данной части ру-
         ководства).


               Возвращаемое значение:

               Данная  функция  возвращает  число удачно преобразованных и
         правильно назначенных полей. Возвращаемое  значение  не  включает
         полей,  прочитанных,  но  не  назначенных. При попытке считывания
         конца файла  возвращается значение EOF. Возвращаемое  значение  0
         обозначает, что нет назначенных полей.
               См. также cscanf, fprintf, scanf, sscanf.


               Пример.

               #include <stdio.h>

               FILE *stream;
               long l;
               float fp;
               char s[81];
               char c;

               stream = fopen ("data", "r");
               .
               .
               .
               /* ввод различных данных */

               fscanf (stream, "%s", s);

               fscanf (stream, "%c", &c);


               fscanf (stream, "%ld", &l);

               fscanf (stream, "%f", &fp);.


               FSEEK.

               #include <stdio.h>
               int fseek (stream, offset, origin);

               FILE *stream; указатель на структуру FILE.

               long offset; число байтов от origin.
               int origin; начальная позиция.

               Описание:

               Функция  fseek перемещает указатель, соответствующий потоку
         stream, на новое  место  расположения,  отстоящее  от  origin  на
         offset  байтов. Следующая операция в потоке выполняется над новым
         месторасположением.
               Если поток открыт для обновления,  то  следующей  операцией
         будет либо чтение, либо запись.
               Аргумент origin может быть одной из следующих констант, оп-
         ределенных в <stdio.h>.


            ORIGIN                ОПРЕДЕЛЕНИЕ
          (источник, начало)

            SEEK-SET              начало файла.

            SEEK-CUR              текущая позиция указателя на
                                  файл.

            SEEK-END              конец файла.

               Функция  fseek используется для перемещения указателя в лю-
         бое место файла. Указатель может быть также  размещен  за  концом
         файла.  Однако,  попытка  расположить  указатель до начала  файла
         приведет к ошибке.

               Возвращаемое значение:

               Функция fseek возвращает значение 0, если указатель успешно
         перемещен. В случае ошибки  возвращается любое  ненулевое  значе-
         ние.  Для  устройств, не совместимых с операцией seek, (таких как
         терминал и печать), возвращаемое значение неопределено.
               См. также ftell, lseek, rewind.

               Замечание! Для потоков, открытых в  текстовом  (преобразую-
         щем)  режиме, применение fseek является ограниченным, т.к. комби-
         нации ВК - ПС могут стать причиной выработки непредвиденного  ре-
         зультата.

               Ниже приведены операции (действия) fseek, гарантирующие ра-
         боту с потоками, открытыми в текстовом режиме:
               * смещение origin на величину offset, равную нулю;

               *  смещение  от начала файла на значение offset, полученное
         после вызова функции ftell.

               Пример.

               #include <stdio.h>

               FILE *stream;
               int result;

               stream = fopen("data", "r");
               .
               .
               .
               /* следущий оператор возвращает указатель на файл к  началу
         файла */

               result = fseek(stream, 0L, SEEK_SET);.


               FSTAT


               #include <sys\types.h>
               #include <sys\stat.h>

               int fstat(handle,buffer);
               int handle; handle-р, ссылающийся на открытый файл.
               struct  stat  *buffer; указатель на структуру хранения  ре-
         зультатов.

               Описание:

               Функция  fstat  получает информацию об открытом файле, свя-
         занным с данным handle-ром, и запоминает ее в структуре, на кото-
         рую указывает buffer. Структура,  тип  stat  которой  объявлен  в
         <sys\stat.h>, содержит следующие поля:


           Поле                              Значение

         st_mode           Битовая маска для информации  о  режиме
                           файла. Бит  S_IFCHR    устанавливается,
                           если  handle  ссылается на  устройство.
                           Бит    S_IFREG   устанавливается,  если
                           handle ссылается на обычный файл.  Биты
                           чтения/записи  пользователей устанавли-
                           ваются  соответственно  режиму  доступа
                           для файла.

         st_dev            Либо номер устройства диска,содержащего

                           файл,  либо  handle - в  случае другого
                           устройства.

         st_rdev           Либо номер устройства диска,содержащего
                           файл,  либо  handle - в  случае другого
                           устройства
                           (аналогично st_dev).

         st_nlink          Всегда 1.

         st_size           Размер файла  в байтах.

         st_atime          Время последней модификации файла.

         st_mtime          Время последней модификации файла
                           (аналогично st_atime).

         st_ctime          Время последней модификации файла
                           (аналогично st_atime и st_mtime).


               В  структуре  типа stat существуют три дополнительных поля,
         которые для MS DOS не имеют смысла.

               Возвращаемое значение:

               Функция fstat возвращает значение 0, если информация о ста-
         тусе файла получена. Возвращаемое значение -1 свидетельствует  об
         ошибке;  в  этом  случае errno устанавливается в EBADF, определяя
         тем самым неверный файловый handle.
               См.также access, chmode, filelength, stat.

               Замечание! Если заданный handle  ссылается  на  устройство,
         поля размера и времени в структуре stat не имеют смысла.

               Пример.

               #include <fcntl.h>
               #include <sys\types.h>
               #include <sys\stat.h>
               #include <stdio.h>

               struct stat buf;
               int fh, result;

               fh=open("tmp/data", O_RDONLY);
               .
               .
               .
               result=fstat(fh,&buf);

               if (result==0)
                   printf("file size is %ld\n",buf.st_size);



               FTELL

               #include <stdio.h>

               long ftell (stream);
               FILE *stream; указатель на структуру FILE.

               Описание:

               Функция  ftell  получает  текущую позицию указателя на файл
         (если он есть), связанного с потоком stream.  Позиция  выражается
         как смещение offset от начала потока stream.

               Возвращаемое значение:

               Эта  функция  возвращает  текущую  позицию. В случае ошибки
         возвращается значение -1L. Для устройств, не совместимых с опера-
         цией seek (таких как терминалы и печать), или когда поток  stream
         не  ссылается на открытый файл, возвращаемое значение неопределе-
         но.
               См. также fseek, lseek, tell.

               Замечание! Значение, возвращаемое fteel, физически не отра-
         жает байтового смещения offset для потока, открытого в  текстовом
         режиме,  т.к. текстовый режим преобразует комбинации ВК - ПС. Ис-
         пользуйте функцию ftell вместе с fseek, чтобы корректно запомнить
         и восстановить месторасположения указателя на файл.

               Пример.

               #include <stdio.h>

               FILE *stream;

               long position;

               stream = fopen ("data", "rb");
               .
               .
               .
               position = fteel(stream);.


               FTIME

               #include <sys\types.h>
               #include <sys\timeb.h>

               void ftime(timeptr);
               struct timeb *timeptr; указатель на структуру, описанную  в
         <sys\timeb.h>.

               Описание:

               Функция  ftime  высвечивает  текущее  время  и хранит его в

         структуре, на которую указывает timeptr. Структура timeb  описана
         в  <sys\timeb.h>. Она  содержит  4  поля: time, millitm, timezone,
         dstflag, которые имеют следующие значения:

            ПОЛЕ                             ЗНАЧЕНИЕ

            time                Время,  в  секундах,  прошедшее от
                                значения   00:00:00   времени   по
                                Гринвичу, т.е. с 1января 1970 г.

            millitm             Сотая доля секунды.

            timezone            Разность  в минутах (в направлении
                                к западу) между значением  времени
                                по  Гринвичу  и  местным временем.
                                Значение  timezone определяется из
                                значения timezone (см. tzset).

            dstflag             Ненулевое  значение,   если   зона
                                перехода  на  зимнее/летнее  время
                                присутствует   в   зоне   местного
                                времени,  которое  определяется из
                                значения   глобальной   переменной
                                daylight ( см. tzset.)


               Возвращаемое значение:

               Функция ftime задает значения полей структуры, определенной
         по timeptr. Возвращаемого значения нет.
               См. также asctime, ctime, gmtime, localtime, time, tzset.
               Пример.

               #include <sys\types.h>
               #include <sys\timeb.h>
               #include <stdio.h>
               #include <time.h>

               main()
               {
               struct timeb timebuffer;
               char *timeline;
               time(&timebuffer);

               timeline = ctime(&(timebuffer, time));

               printf ("The time is %.19s.%hu %s",
                        timeline,   timebuffer.millitm,
                        &timeline[20]);
               }

               На выходе будет следующая информация:

               The time is Wed Dec 04 17:58:29.420 1985.



               FWRITE

               #include <stdio.h>

               int fwrite(buffer, size, count, stream);
               char *buffer; указатель на записываемые данные.
               int size; размер элемента в байтах.
               int count; максимальное число записываемых элементов.
               FILE *stream; указатель на структуру типа FILE.

               Описание:

               Функция fwrite записывает элементы  count  длиной  size  из
         buffer  в  выходной поток stream. Указатель на файл, связанный со
         stream, увеличивается на число записанных байтов.
               Если заданный stream открыт в текстовом режиме, каждый воз-
         врат каретки заменяется парой "Возврат каретки - перевод строки".
         Для возвращаемого значения такая замена не выполняется.

               Возвращаемое значение:

               В случае ошибки, т.е. если число полностью записанных  эле-
         ментов  меньше,  чем  count,  тогда функция fwrite возвращает это
         число.
               См. также fread, write.

               Пример.

               #include <stdio.h>

               FILE *stream;
               long list[100];
               int numwritten;

               stream = fopen("data", "r+b");
               .
               .
               .
               /* следующий оператор записывает 100 длинных целых в  поток
         в двоичном формате */

               numwritten   =   fwrite((char  *)list,  sizeof(long),  100,
         stream);.


               GCVT

               #include <stdio.h> требуется только для объявления функций.

               char gcvt(value, ndec, buffer);
               double value; преобразуемое значение.
               int ndec; количество запоминаемых значащих цифр.

               char *buffer; память для хранения результата.


               Описание:

               Функция gcvt преобразовывает значение  с  плавающей  точкой
         value  в  символьную  строку  и  запоминает  эту  строку в буфере
         buffer. Буфер buffer должен быть достаточно большим,  чтобы  смог
         разместить  преобразованное  значение  вместе  с нулевым символом
         окончания '\0', который добавляется автоматически. Переполнение не
         контролируется.
               Функция  gcvt пытается обработать ndec значащих цифр в фор-
         мате FORTRAN F. Если это не удается,  она  обрабатывает  значащие
         цифры в формате FORTRAN E. При преобразовании ведущие нули подав-
         ляются.

               Возвращаемое значение:

               Функция  gcvt возвращает указатель на строку цифр. В случае
         ошибки  нет возвращаемого значения.
               См. также atof, atoi, atol, ecvt, fcvt.

               Пример:

               #include <stdio.h>

               char buffer[50];
               int precision = 7;

               /* в буфере содержится "-314150.0" */

               gcvt (-3.1415e5, precision, buffer);.


               GETC - GETCHAR

               #include <stdio.h>

               int getc (stream); читает символ из потока stream.

               FILE *stream; указатель на структуру FILE.

               int getchar(); читает символ из stdin.

               Описание:

               Макро getc читает отдельный символ из текущей позиции пото-
         ка stream и изменяет соответствующий указатель на файл для указа-
         ния следующего символа. Макро getchar идентична getc(stdin).


               Возвращаемое значение:

               Макро getc и getchar возвращают прочитанный символ. Возвра-
         щаемое значение EOF свидетельствует об ошибке или об условии дос-
         тижения конца файла. Для определения категории ошибки используют-
         ся функции ferror или feof.

               См. также fgetc, fgetchar, getch,  getche,  putc,  putchar,
         ungetc.

               Замечание!   Процедуры   getc,   getchar  идентичны  fgetc,
         fgetchar, но они являются макро, а не функциями.

               Пример.

               #include <stdio.h>

               FILE *stream;
               char buffer[81];
               int i, ch;
               .
               .
               .
               /* следующие операторы позволяют выбирать требуемую  вводи-
         мую строку из stdin */

               for (i = 0; (i < 80) && ((ch = getchar ()) != EOF) &&
                  (ch != '\n'); i++)
                  buffer [i] = ch;

               buffer[i] = '\0';

               /*  для ввода строк из потока stdin в операторах, приведен-
         ных выше, можно вместо "getchar ()"  использовать  "getc(stdin)".
         */


               GETCH

               #include <conio.h> требуется только для объявления функции.

               int getch();

               Описание:

               Функция  getch  читает без эхо-отображения отдельный символ
         прямо  с  консоли.  Напечатанные  (введенные)  символы  не  имеют
         эхо-отображения.  Если  введен  CONTROLL-C, система выполняет INT
         23H.

               Возвращаемое значение:

               Функция getch возвращает прочитанный символ.  Возвращаемого
         значения в случае ошибки нет.
               См.также cgets, getche, getchar.


               Пример.

               #include <conio.h>
               #include <ctype.h>


               int ch;

               /*  в этом цикле берутся символы с клавиатуры, пока не вст-
         ретится "не пробельный" символ.  Предшествующие  символы  пробела
         отбрасываются. */


               GETCHE

               #include <conio.h> требуется только для объявления функции.

               int getche ();

               Описание:

               Функция  getche читает отдельный символ с консоли и выраба-
         тывает эхо для прочитанного символа.  Если  вводится  CONTROLL-C,
         система выполняет INT 23H (выход по CONTROLL-C).

               Возвращаемое значение:

               Функция  getche возвращает символ. Возвращаемого значения в
         случае ошибки нет.
               См.также cgets, getch, getchar.

               Пример.

               #include <conio.h>
               #include <ctype.h>

               int ch;

               /* берет символ с клавиатуры, вырабатывает его  эхо-отобра-
         жение  на консоли. Если это символ верхнего регистра, преобразует
         его к символу нижнего регистра и записывает старый символ */.

               ch = getche();

               if (isupper (ch))
                  cprintf ("\b%c", _tolower(ch));


               GETCWD


               #include <direct.h> требуется только для  объявления  функ-
         ции.


               char *getcwd(pathbuf,n);
               char *pathbuf; память для path-имени.
               int n; максимальная длина path-имени.



               Описание:

               Функция  getcwd  получает полное path-имя текущего рабочего
         директория и запоминает его в pathbuf. Целый аргумент n определя-
         ет максимальную длину для path-имени. Возникает ошибка, если дли-
         на path-имени, включая нулевой символ окончания, превышает n.
               Аргумент pathbuf может быть NULL; буфер  размером  n  будет
         автоматически  захватываться  посредством malloc и использоваться
         для хранения path-имени. Этот буфер позже может  быть  освобожден
         при  использовании возвращаемого значения функции getchar (указа-
         тель на захваченный буфер) посредством функции free.

               Возвращаемое значение:

               Функция getcwd возвращает  pathbuf.  Возвращаемое  значение
         NULL свидетельствует об ошибке  и errno устанавливается в одно из
         следующих значений:

         Значение                      Его смысл

         ENOMEM               Памяти недостаточно для размещения    n
                              байт  (когда  аргумент  NULL  задан как
                              pathbuf).

         ERANGE               Path-имя длинее, чем n символов.

               См.также chdir, mkdir, rmdir.

               Пример.

               #include <direct.h>
               #include <stdlib.h>

               char buffer [51];

               /*  следующий  оператор записывает имя текущего рабочего **
         директория (длиной до 50 символов) в буфер */

               if (getcwd(buffer,50)==NULL)
                   perror("getcwd error");


               GETENV.

               #include <stdlib.h> требуется только для  объявления  функ-
         ции.

               char *getenv(varname);
               char *varname; имя переменной окружения.

               Описание:

               Функция  getenv возвращает указатель на значение переменной
         окружения для соответствующего имени varname этой переменной. Пе-
         ременные окружения определяют окружение,  в  котором  выполняется
         процесс  (например,  поиск  path для библиотек, которые линкуются
         вместе с программой).


               Возвращаемое значение:

               Функция getenv возвращает указатель  на  значение  (строку)
         переменной  окружения, содержащую текущее зачение строки varname.
         Возвращается значение NULL, если заданная переменая в текущий мо-
         мент не определена.
               См. также putenv.

               Замечание! Запись в таблице переменных окружения непосредс-
         твенно не может быть изменена. Если запись  нужно  изменить,  ис-
         пользуется функция putenv. Чтобы модифицировать возвращаемое зна-
         чение и при этом не затронуть таблицу переменных окружения, нужно
         использовать функции strdup или strcpy, которые позволяют копиро-
         вание строки.
               Функции  getenv  и  putenv используют глобальную переменную
         environ для  доступа  к  таблице  переменных  окружения.  Функция
         putenv  может  изменять  значение environ, делая недействительным
         аргумент "envp" для функции "main".

               Пример.

               #include <stdlib.h>

               char *pathvar;

               /* следующий оператор получает значение переменной  окруже-
         ния PATH */

               pathvar = getenv("PATH");

               /* Если в окружении есть запись "PATH  =  A:\BIN;  B:\BIN",
         то указатель pathvar будет ссылаться на "A:\BIN; B:\BIN". Если пе-
         ременной окружения PATH нет,указатель pathvar будет равен NULL.*/


               GETPID

               #include  <process.h> требуется только для объявления функ-
         ции.
               int getpid();

               Описание:

               Функция getpid возвращает  идентификатор  процесса  (номер)
         ID, который уникально определяет вызываемый процесс.

               Возвращаемое значение:

               Функция  getpid возвращает идентификатор процесса ID. Возв-
         ращаемого значения в случае ошибки нет.
               См.также mktemp.


               Пример.

               #include <process.h>
               #include <string.h>
               #include <stdio.h>

               char filename[9], pid[5];
               .
               .
               .

               strcpy(filename, "FILE");
               strcat(filename, itoa(getpid(), pid, 10));

               /* печатается "FILExxxxx", где xxxxx является **  идентифи-
         катором процесса id */

               printf("File name is %s\n", filename);


               GETS

               #include <stdio.h>

               char *gets(buffer);
               char *buffer; память для хранения вводимой строки.

               Описание:

               Функция  gets  читает  строку  из потока стандартного ввода
         stdin и запоминает ее в буфере buffer. Строка состоит  из  набора
         символов и заканчивается символом новой строки '\n'. Перед возвра-
         том функция gets замещает символ новой строки символом '\0', в от-
         личии от функции fgets, которая сохраняет символ новой строки.


               Возвращаемое значение:

               Функция  возвращает  свой аргумент. Значение указателя NULL
         свидетельствует об ошибке или достижении конца файла. Для опреде-
         ления категории ошибки используются функции ferror или feof.
               См. также fgets, fputs, puts.


               Пример.

               #include <stdio.h>

               char line[100];
               char *result;

               /* следующий оператор выбирает строку из потока stdin */

               result = gets(line);.



               GETW


               #include <stdio.h>

               int getw (stream);

               FILE *stream; указатель на структуру FILE.

               Описание:

               Функция getw читает двоичное значение типа int из специаль-
         ного потока stream и изменяет соответствующий указатель  на  файл
         (если  он есть), чтобы указать на следующий непрочитанный символ.
         Эта функция не предполагает специального выравнивания объектов.


               Возвращаемое значение:

               Эта функция возвращает считанное целое значение. Возвращае-
         мое значение EOF свидетельствует об ошибке или о достижении конца
         файла; однако, значение EOF может быть воспринято как целая вели-
         чина, поэтому для проверки конца файла или условия ошибки исполь-
         зуются функции ferror и feof.
               См. также putw.

               Замечание! Функция getw обеспечивает совместимость с преды-
         дущими библиотеками. Необходимо заметить, что проблемы  переноси-
         мости  могут возникать вместе с getw, если в системах различаются
         размеры int и порядок байтов внутри int.

               Пример.

               #include <stdio.h>
               #include <stdlib.h>

               FILE *stream;
               int i;
               .
               .
               .
               /* следующий оператор считывает слово из  потока  stream  и
         проверяет наличие ошибки */

               i = getw(stream);

               if (ferror(stream))
               { fprintf(stderr, "getw failed\n");
               clearerr (stream);
               }.


               GMTIME

               #include <time.h>

               struct tm *gmtime(time);

               long *time; указатель на хранимое время.


               Описание:

               Функция  gtime  преобразует время, хранимое как long-значе-
         ние, к структуре. Long-значение time представляет  секунды,  про-
         шедшие  от 00:00:00 значения времени по Гринвичу, т.е. с 1 января
         1980 года. Это значение обычно получается из вызова функции time.
               Функция gmtime разрывает  значение  time  и  хранит  его  в
         структуре  типа tm, объявленной в <time.h>. Результат в структуре
         отражает значение времени по Гринвичу, а не местное время.

               Поля в структуре типа tm хранят следующие значения:

              Поле                Хранимое значение

            tm_sec           Секунды

            tm_min           Минуты

            tm_hour          Часы (от 0 до 24)

            tm_mday          День месяца (от 1 до 31)

            tm_mon           Месяцы (от 0 до 11; январь=0)

            tm_year          Год (текущий год минус 1900)

            tm_wday          День недели (от 0 до 6;
                             воскресенье = 0)

            tm_yday          День года (от 0 до 365;
                             1 января = 0)

            tm_isdst         Ненулевое значение, если  осуществлен
                             переход на летнее/зимнее время, иначе
                             0.

               В MS DOS даты раньше 1980 года  не  понимаются.  Если  time
         представляет  дату  ранее  1  января 1980 года, gmtime возвращает
         символьную строку, представленную 00:00:00 January 1,1980.
               Возвращаемое значение:

               Функция gmtime возвращает указатель на результат,  хранимый
         в структуре. Возвращаемого значения в случае ошибки нет.
               См.также asctime, ftime, ctime, localtime, time.

               Замечание! Функции gmtime и localtime используют один и тот
         же  статистически захваченный буфер для хранения в нем строки ре-
         зультата. Каждый вызов одной из этих процедур уничтожает  резуль-
         тат предыдущего вызова.


               Пример.

               #include <time.h>

               struct tm *newtime;
               long ltime;

               time(&ltime);
               newtime=gmtime(&ltime);
               printf("Greenwich mean time is %s\n",
                       asctime(newtime));


               HALLOC

               #include  <malloc.h>  требуется только для объявления функ-
         ции.

               char huge *halloc(n,size);
               long n; число элементов.
               unsigned size; длина каждого элемента в байтах.

               Описание:

               Функция halloc захватывает память  для  huge-массива  из  n
         элементов,  каждый длиной size байтов. Каждый элемент инициализи-
         рован в 0.
               Если размер массива меньше чем 128, то размер элемента мас-
         сива должен быть степенью 2.

               Возвращаемое значение:

               Функция halloc возвращает char-huge указатель на  захвачен-
         ное пространство.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.  Чтобы
         получить  указатель на тип, отличный от char, используется преоб-
         разователь типа  возвращаемого  значения.  Возвращаемое  значение
         равно NULL, если осталось недостаточно памяти.
               См.также calloc, free, hfree, malloc, realloc.

               Пример.

               #include <malloc.h>

               long huge *lalloc;
               .
               .
               .

               /*  захватывает пространство, достаточное для 80000 длинных
         целых, и инициализирует их в 0 */

               lalloc=(long huge*)halloc(80000L,sizeof(long));






               HFREE

               #include <malloc.h> требуется только для  объявления  функ-
         ции.

               void hfree(ptr);
               char huge *ptr; указатель на захваченный блок памяти.

               Описание:

               Функция  hfree освобождает блок памяти. Аргумент ptr указы-
         вает на ранее захваченный блок памяти посредством вызова halloc.
               Числом освобожденных байтов является число байтов,  опреде-
         ленных  при захвате блока. После вызова освободившиеся блоки при-
         годны к размещению.

               Возвращаемое значение:

               Возвращаемого значения нет.
               См.также halloc.

               Замечание! Попытка освободить неверный  ptr  (указатель  не
         захватывается  посредством вызова halloc) может привести к после-
         дующему захвату и вызвать ошибку.

               Пример.

               #include <malloc.h>
               #include <stdio.h>

               char huge *alloc;

               /* захватывает 80000 байтов и освобождает их */

               alloc=halloc(80000L, sizeof (char));
               .
               .
               .
               if (alloc !=NULL)

               /* проверяет на правильность указателя */

               hfree(alloc);

               /* освобождает память для heap */

.


               HYPOT

               #include <math.h>

               double hypot(x,y);
               double x,y; значение с плавающей точкой.

               Описание:

               Функция hypot  вычисляет  длину  гипотенузы  прямоугольного
         треугольника с заданной длиной двух сторон x и y. Вызов hypot эк-
         вивалентен следующему:
               sqrt(x*x + y*y);


               Возвращаемое значение:

               Функция  hypot  возвращает длину гипотенузы. В случае пере-
         полнения результата, hypot устанавливает errno в ERANGE и возвра-
         щает значение HUGE.
               См.также cabs.

               Пример.

               #include <math.h>

               double x,y,z;

               x = 3.0;
               y = 4.0;
               z = hypot(x,y);
               printf("Hypotenuse=%2.1f\n",z);

               На выходе:

               Hypotenuse = 5.0

.


               INP

               #include <conio.h>      требуется  только   для  объявления
                                       функции
               int inp(port);
               unsigned port;          номер порта

               Описание.

               Функция  inp читает 1 байт из порта ввода, определенного по
         port. Аргумент port может быть любым беззнаковым целым  числом  в
         пределах от 0 до 65535.

               Возвращаемое значение.

               Функция inp возвращает прочитанный байт из port. Возвращае-
         мого значения в случае ошибки нет.
               Смотри также output.


               Пример:

               #include <conio.h>
               unsigned port;
               char result;
               .
               .
               .
               /*  следующий оператор вводит тот байт из порта, на который
         установлен port */

               result=inp(port);
               INT86
               #include <dos.h>
               int int86(intno,inregs,outregs);
               int ntno;                     номер (число) прерывания зна-
               union REGS *inregs;           чения  регистров  при вызове
               union REGS *outregs;          значения  регистров  при воз-
                                             врате

               Описание.

               Функция int86 выполняет прерывание 8086 программного  обес-
         печения,  которое  определено номером прерывания intno. Перед вы-
         полнением прерывания int86 копирует содержимое inregs в соответс-
         твующие регистры. После возврата прерывания функция копирует зна-
         чение текущего регистра в outregs. Она также копирует статус  пе-
         реносимого  флага  системы  в поле cflag, содержащееся в outregs.
         Аргументы inregs и outregs являются объединениями типа REGS.  Тип
         объединения объявлен в include-файле <dos.h>. Использование функ-
         ции int86 предназначено для вызовов прерываний DOS.



               Возвращаемое значение.

               Возвращаемым значением является значение в регистре AX пос-
         ле возврата прерывания. Если поле cflag в outregs ненулевое, воз-
         никает ошибка и переменная _doserrno также устанавливает соответ-
         ствующий код ошибки.
               Смотри также bdos, intdos, intdosx, int86x.

               Пример:

               #include <signal.h>
               #include <dos.h>
               #include <stdio.h>
               #include <process.h>

               /*  прерывание  номер 0х23, подхватываемое процедурой обра-
         ботки прерываний int_handler.  Замечание:  Значения  в  структуре
         regs не имеют смысла для этого прерывания. */

               #define CNTRL_C 0x23
               int int_handler(int);
               union REGS regs;
               .
               .
               .
               signal (SIGINT, int_handler);
               .
               .
               .
               int86 (CNTRL_C, &regs, &regs);


               INT86X

               #include <dos.h>
               int int86x(intno,inregs,outregs,segregs);
               int intno;                    номер (число) прерываний
               union REGS *inregs;           значение  регистров  при
                                             вызове
               union REGS *outregs;          значение  регистров  при
                                             возврате
               struct SREGS *segregs;        значение  сегментов  при
                                             вызове



               Описание.

               Функция int86x выполняет прерывание 8086 программного обес-
         печения,  которое  определено номером прерывания intno. В отличие
         от функции int86, функция int86x принимает значения регистра сег-
         мента в segregs, позволяя программам, использующим сегменты  дан-
         ных  большой  модели или far-указатели, определять, какой сегмент
         или указатель должен быть использован в процессе системного вызо-
         ва. Перед выполнением определенного  прерывания  int86x  копирует
         содержимое inregs и segregs в соответствующие регистры. В segregs
         используются  только  значения  регистров DS и ES. После возврата

         прерываний функция копирует значения текущего регистра в  outregs
         и  перезаписывает DS. Она также копирует состояние (статус) пере-
         носимого флага системы в поле cflag, содержащееся в outregs.  Ар-
         гументы  inregs и outregs являются объединениями типа REGS. Аргу-
         мент segregs является структурой типа SREGS. Эти типы объявлены в
         include-файле <dos.h>. Использование функции int86x предназначено
         для прямого вызова прерываний DOS, которые берут аргумент  в  ре-
         гистре  ES  или значение регистра DS, которое отличается от умал-
         чиваемого сегмента данных.

               Возвращаемое значение.

               Возвращаемым значением является значение в регистре AX пос-
         ле возвращения прерываний. Если поле flag в outregs является  не-
         нулевым, возникает ошибка и переменная _doserrno также устанавли-
         вает соответствующий код ошибки.
               См.также bdos, intdos, intdosx, int86, segread, FP_SEG.

               Замечание!  Значения  сегмента  для  аргумента segreg могут
         быть получены либо при использовании функции segread, либо
         макро FP_SEG.

               Пример:

               #include <signal.h>
               #include <dos.h>
               #include <stdio.h>
               #include <process.h>

               /* процедура int86x используется для генерирования прерыва-
         ния 0х21 (системный вызов), который, в свою очередь, активизирует
         системный  вызов  "Изменение  атрибутов"  DOS. Здесь используется
         процедура int86x, поскольку ссылка на имя файла может  находиться
         в сегменте, отличном от умалчиваемого сегмента данных (ссылка при
         помощи  far-указателя), поэтому регистр DS может быть точно уста-
         новлен со структурой SREGS. */

               #define SYSCALL 0x21
               /* INT 21H вызывает системные вызовы */
               #define CHANGE_ATTR 0x43
               /* системный вызов 43H - изменения атрибутов */
               char far *filename;
               /* имя файла в far-сегменте данных */
               union REGS inregs, outregs;
               struct SREGS segregs;
               int result;
               .
               .
               .
               inregs.h.ah=CHANGE_ATTR;
               /* AH - номер (число) системного вызова */
               inregs.h.al=0;
               /* AL - функция вызова атрибутов */
               inregs.x.dx=FP_OFF(filename);
               /* DS:DX указывают на имя файла */

               segregs.ds=FP_SEG(filename);
               result=int86x(SYSCALL,&inregs,&outregs,&segregs);
               if (outregs.x.cflag) {
                   printf("can't get attributes of file; error
                           number %d\n", result);
                   exit(1);
                   }
               else {
                   printf("Attribs=%#x\n", outregs.x.cx);
                   }

               INTDOS


               #include <dos.h>
               int intdos(inregs, outregs);
               union REGS *inregs;           значения  регистров  при
                                             вызове
               union REGS *outregs;          значения  регистров  при
                                             возврате

               Описание.

               Функция intdos осуществляет выполнение системного вызова MS
         DOS, который определен значением регистров, объявленных в inregs,
         и возвращает результат системного  вызова  в  outregs.  Аргументы
         inregs  и outregs являются объединениями типа REGS. Тип объедине-
         ния объявлен в include-файле <dos.h>.
               Для осуществления системного вызова intdos выполняет коман-
         ду INT 21H. Перед выполнением команды функция копирует содержимое
         inregs в соответствующие регистры. После  возврата  команды  INT,
         intdos  копирует  значение текущего регистра в outregs. Она также
         копирует статус переносимого флага системы в поле  cflag,  разме-
         щенное в outregs. Если это поле является ненулевым, флаг устанав-
         ливается системным вызовом и указывает на условие ошибки.
               Функция  intdos используется для выполнения системных вызо-
         вов DOS, которые берут аргументы  в  регистрах,  отличных  от  DX
         (DH/DL) и AL, или для системных вызовов, которые определяют ошиб-
         ки посредством переносимого флага.

               Возвращаемое значение.

               Функция intdos возвращает значение регистра AX после завер-
         шения системного вызова. Если поле cflag в outregs является нену-
         левым,  возникает ошибка  и _doserrno устанавливает соответствую-
         щий код ошибки.
               См.также bdos, intdosx.

               Пример:


               #include <dos.h>
               #include <stdio.h>
               union REGS inregs, outregs;
               .

               .
               .
               /* следующие операторы  выбирают  текущую  дату,  используя
         шестнадцатеричный вызов функции DOS 2a */
               inregs.h.ah=0x2a;
               intdos(&inregs,&outregs);
               printf("date is %d/%d/%d\n", outregs.h.dh,
                       outregs.h.dl, outregs.x.cx);


               INTDOSX

               #include <dos.h>
               int intdosx(intno,inregs,outregs,segregs);
               union REGS *inregs;           значение  регистров  при
                                             вызове
               union REGS *outregs;          значение  регистров  при
                                             возврате
               struct SREGS *segregs;        значение  сегментов  при
                                             вызове

               Описание.

               Функция  intdosx  осуществляет выполнение системного вызова
         DOS, который определен значением регистра, объявленным в  inregs,
         и  возвращает результат системного вызова в outregs. В отличии от
         функции intdos, функция intdosx принимает значения регистров сег-
         мента в segregs, позволяя программам, которые используют сегменты
         данных большой модели или far-указатели, определить,  какой  сег-
         мент  или указатель должен быть использован на протяжении систем-
         ного вызова. Аргументы inregs и  outregs  являются  объединениями
         типа  REGS.Аргумент  segregs  является структурой типа SREGS. Эти
         типы объявлены в include-файле <dos.h>. Для активизации системно-
         го вызова функция intdosx выполняет команду INT 21H. Перед выпол-
         нением команды функция копирует содержимое inregs и segregs в со-
         ответствующие регистры. В segregs  используются  только  значения
         регистров  DS  и  ES. После возврата команды INT intdosx копирует
         текущее значение регистра в outregs и перезаписывает DS.
               Она также копирует статус переносимого флага системы в поле
         cflag, размещенное в outregs. Если это поле  является  ненулевым,
         флаг устанавливается посредством системного вызова и указывает на
         условие ошибки.
               Область  действия  функции intdosx расширяется и на область
         действия системных вызовов DOS, которые берут аргумент в регистре
         ES или значение регистра DS, отличное от  умалчиваемого  сегмента
         данных.

               Возвращаемое значение.

               После  завершения системного вызова функция intdosx возвра-
         щает значение регистра AX. Если поле cflag в outregs является не-
         нулевым, возникает ошибка и _doserrno также  устанавливает  соот-
         ветствующий код ошибки.
               См.также bdos, intdos, segread, FP_SEG.


               Замечание!  Значения  сегмента  для  аргумента segreg могут
         быть получены либо при использовании функции segread, либо
         макро FP_SEG.

               Пример:

               #include <dos.h>
               union REGS inregs, outregs;
               struct SREGS segregs;
               char far *dir = "/test/bin";
               /*следующий  оператор  заменяет  текущий рабочий директорий
         вызовом шеснадцатеричной функции DOS 36 */
                inregs.h.ah=0x3b;
                /* измененный директорий */
                inregs.x.dx=FP_OFF(dir);
                /* имя файла offset*/
                segregs.ds=FP_SEG(dir);
                /* имя файла сегмента */
                intdosx(&inregs,&outregs,&segregs);


               ISALNUM-ISASCII

               #include <ctype.h>
               int isalnum (c);     проверяет  символы  на   при-
                                    надлежность  к алфавитно-циф-
                                    ровому типу (A-Z,a-z,0-9)
               int isalpha(c);      проверяет на буквы (A-Z,a-z)
               int isascii(c);      проверяет  на  символы   кода
                                    ASCII (0x00-0x7F)
               int c;               проверяемая величина

               Описание.

               Процедуры,  описанные  в  ctype,  проверяют введенное целое
         значение и возвращают ненулевое значение, если целое удовлетворя-
         ет условиям проверки, и нулевое значение, если этого не  происхо-
         дит.  Предполагается, что на установленном оборудовании использу-
         ются коды ASCII.
               Процедура isascii выдает значение результата для всех цело-
         численных значений. Однако остальные процедуры выдают  определен-
         ный  результат только для тех целочисленных значений, которые мо-
         гут быть преобразованы в символы кода ASCII (что происходит толь-
         ко тогда, когда проверка с помощью isascii дает положительный ре-
         зультат) или значение EOF (определенное в <stdio.h>)  для  симво-
         лов, не принадлежащих к ASCII.
               См.также   iscntrl,   isdigit,  isgraf,  islower,  isprint,
         ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper.

               Замечание! Процедуры ctype реализованы как макро.


               Пример:

               #include <stdio.h>

               #include <ctype.h>
               int ch;
               /*Следующие операторы анализируют все **символы между кода-
         ми 0х0 и 0х7F, *печатает "A" для букв, "AN" - для  буквенно**циф-
         ровых символов и "AS" для символов **кода ASCII : */
               for (ch=0;ch<=0x7F;ch++) {
                        printf ("%#04x",ch);
                        printf ("%3S",isalnnum(ch)  ? "AN":" ");
                        printf ("%2S",isalpha(ch)   ? "A":" ");
                        printf ("%3S",isascii(ch)   ? "AS":" ");
                        putchar ('\n');


               ISATTY

               #include <io.h>   требуется  только   для   объявления
                                 функции
               int isatty(handle);
               int handle;       handle-р, ссылающийся на проверяемое
                                 устройство

               Описание.

               Функция  isatty определяет, является ли даный handle-р свя-
         занным с символьным устройством  (таким  как  терминал,  консоль,
         принтер или последовательный порт).

               Возвращаемое значение.

               Функция isatty возвращает ненулевое значение, если устройс-
         тво является символьным. Иначе - возвращается значение 0.

               Пример:

               #include <io.h>
               int fh;
               long loc;
               .
               .
               .
               if (isatty(fh)==0)
               /* если не устройство, то выдает текущую позицию */
               loc=tell(fh);


               ISCNTRL-ISXDIGIT

               #include <ctype.h>
               iscntrl(c);        проверяет   на  управляющий
                                  символ (0х00-0х1f или 0x7F)
               isdigit (c);       проверяет на цифру (0-9)
               isgraph(c);        проверяет на  печатаемые симво-
                                  лы,  исключая  символ   пробела
                                  (0х21-0х7e)
               islower(c);        проверяет  на  строчные буквы

                                  (a-z)
               isprint(c);        проверяет  на  печатаемые
                                  символы (0x20-0x7e)
               ispunct(c);        проверяет на  знаки  пунктуации
                                  (когда   проверки  с    помощью
                                  isalnum(c),   iscntrl(c)      и
                                  isspace(c) имеют  отрицательный
                                  результат
               isspace(c);        проверяет на пробельные символы
                                  (0x09-0x0d или 0x20)
               isupper(c);        проверяет  на  прописные  буквы
                                  (A-Z)
               isxdigit(c);       проверяет  на шестнадцатеричные
                                  цифры  (A-F,a-f, 0-9)
               int c;             проверяемое целое

               Описание.

               Процедуры  ctype, описанные выше, проверяют введенное целое
         значение и возвращают ненулевое значение, если целое удовлетворя-
         ет условиям проверки, и 0 -  в  противном  случае.  (Используется
         оборудование  с символами кода ASCII). Эти процедуры вырабатывают
         определенный результат только для целых значений, соответствующих
         символам кода ASCII (это возможно только тогда, когда isascii ис-
         тинна) или значение EOF (определенное в <stdio.h>),  если  символ
         не принадлежит к ASCII.
               См.также   isalnum,  isalpha,  isascii,  toascii,  tolower,
         toupper.

               Замечание! Процедуры ctype реализуются как макро.

               Пример:

               #include <stdio.h>
               #include <ctype.h>
               int ch;
               /*  следующие операторы анализируют все
               ** симовлы между кодами 0х0 и 0х7f,
               ** печатая "U" для прописных букв,
               ** "L" - для  строчных, "D" для цифр,
               ** "X" для шестнадцатеричных цифр,
               ** "S" для пробелов, "PU" для знаков
               ** пунктуации, "PR" для печатаемых
               ** символов,   "G" для графических,
               ** "C" для управляющих.
               ** Если код может быть напечатан, он печатается.   */
               for (ch=0; ch<=0x7f; ch++)
                 { printf ("%2s", iscntrl (ch)  ? "C":" ");
                   printf ("%2s", isdigit (ch)  ? "D":" ");
                   printf ("%2s", isgraph (ch)  ? "G":" ");
                   printf ("%2s", islower (ch)  ? "L":" ");
                   printf ("%c",  isprint (ch)  ? ch :'\0');
                   printf ("%3s", ispunct (ch)  ? "PU":" ");
                   printf ("%2s", isspace (ch)  ? "S":" ");
                   printf ("%3s", isprint (ch)  ? "PR":" ");

                   printf ("%2s", isupper (ch)  ? "U":" ");
                   printf ("%2s", isxdigit (ch)  ? "X":" ");
                   putchar('\n');
                 }


               ITOA

               #include <stdlib.h>          Требуется   только    для
                                            объявления функции
               char *itoa(value,string,radix);
               int value;                   преобразуемое число
               char *string;                строка результата
               int radix;                   основание value

               Описание.

               Функция itoa преобразует символы числа value  в  символьную
         строку,  заканчивающуюся  NULL-символом, и запоминает результат в
         string. Аргумент radix определяет основание системы счисления для
         value; его значение может лежать в пределах  от  2  до  36.  Если
         radix  =  10  и value - отрицательное число, то первым символом в
         строке результата будет знак минус.

               Возвращаемое значение.

               Функция itoa возвращает указатель на строку.  Возвращаемого
         значения в случае ошибки нет.
               См.также ltoa, ultoa.

               Замечание! Размер памяти, отводимой для string, должен быть
         больше, чем требуется для возвращаемой строки. Функция может воз-
         вращать строку длиной до 17 байтов.

               Пример:

               #include <stdlib.h>
               int radix=8;
               char buffer[20];
               char *p;
               p=itoa(-3445,buffer,radix); /*p="1712113"*/


               KBHIT

               #include <conio.h>     требуется только для объявления
                                      функции
               int kbhit();

               Описание.

               Функция kbhit проверяет нажатие клавиши на консоли.

               Возвращаемое значение.


               Функция  kbhit  возвращает ненулевое значение, если клавиша
         нажата. В противном случае возвращается 0.

               Пример:

               #include <conio.h>
               int result;
               /* следующий оператор проверяет, была ли нажата клавиша */
            result = kbhit();
               /* если результат result ненулевой, буфер  ожидает  нажатие
         клавиши.  Ее можно задать при помощи getch или getche. Если getch
         или getche были вызваны функцией kbhit  без  проверки,  программа
         делает паузу и ожидает ввод символа. */


               LABS

               #include <stdlib.h>             требуется  только  для
                                               описания функции
               long labs(n);
               long n;                         длинное целое значение

               Описание.

               Функция  labs вырабатывает абсолютное значение своего длин-
         ного целого аргумента n.

               Возвращаемое значение.

               Функция labs возвращает абсолютное значение своего аргумен-
         та. Возвращаемого значения в случае ошибки нет.
               См. также abs, cabs, fabs.

            Пример:

            #include <stdlib.h>
            long x, y;
            x = -41567L;
            y = labs(x);            /* y = 41567L */


               LDEXP

               #include <math.h>
               double ldext(x,exp);
               double x;            значение с плавающей точкой
               int *exp;            целая экспонента


               Описание.

               Функция  ldexp возвращает x, умноженное на 2 в степени exp.
         В случае переполнения результата  функция  возвращает  +HUGE  или
         -HUGE (в зависимости от знака x) и устанавливает errno в ERANGE.
               См.также frexp, modf.


               Пример:

               #include <math.h>
               double x,y;
               int p;
               x = 1.5;
               p = 5;
               y = ldexp(x,p);    /* y = 48.0 */


               LFIND - LSEARCH

               #include <search.h>    требуется только для объявления
                                      функции
               char *lsearch(key,base,num,width,compare);
               char *lfind(key,base,num,width,compare);
               char *key;              ключ поиска
               char *base;             указатель  на  поисковую  базу
                                       данных
               unsigned *num,width;    число и размер элементов
               int (*compare)();       указатель на функцию сравнения

               Описание.

               Функции lsearch и lfind производят строковый поиск для зна-
         чения key в массиве из num элементов, каждый размером width байт.
         (В отличии от bsearch, lsearch и lfind не требуют отсортированно-
         го массива). Аргумент base является указателем на  базу  массива,
         который нужно найти.
               Если key не найден, lsearch присоединяет его в конец. Функ-
         ция lfind этого не делает.
               Аргумент  compare является указателем на процедуру, постав-
         ляемую пользователем, которая сравнивает два элемента  массива  и
         возвращает значение, определяющее их отношение. Обе функции вызы-
         вают  процедуру  compare в течении поиска один или несколько раз,
         пересылая в каждом вызове указатели на два элемента массива.  Эта
         процедура  должна сравнивать элементы, а затем возвращать одно из
         следующих значений:

            Значение                     Его смысл

            не равно 0           element 1 и element 2 различны

               0                 element 1 равен element 2


               Возвращаемое значение.

               Обе функции lsearch и lfind возвращают указатель на  первое
         возникновение key в массиве, на который указывает base.
               Если key не найден, эти функции возвращают NULL.
               См.также bsearch.



               Пример:

               /* функция lsearch производит строковый поиск в массиве для
         элемента "key"; lsearch возвращает указатель на структуру, если в
         ней содержится key, и NULL - если его нет. */

               #include <search.h>
               #include <string.h>
               #include <stdio.h>
               int compare();
               /* должна быть объявлена как функция */
               main (argc, argv)
               int argc;
               char **argv;
                {
               char **result;
               char *key = "PATH";
               /*  следующий  оператор  находит  аргумент,  начинающийся с
         "PATH", в предположении, что аргументы лексикографически отсорти-
         рованы */
               result = (char **)bsearch((char *)&key,
                        (char *)argv, argc, sizeof(char *),
                         compare);
               if (result)
                   printf ("%s found\n", *result);
               else
                   printf("PATH not found!\n");
                 }
               int compare (arg1, arg2)
               char **arg1, **arg2;
                {
                 return(strncmp(*arg1, *arg2, strlen(*arg1)));
                }.


               LOCALTIME

               #include <time.h>
               struct tm *localtime(time);
               long *time;                 указатель на хранимое
                                           время

               Описание.

               Функция  localtime  преобразовывает  время,  хранимое   как
         long-значение,  к  структуре. Long-значение time представляет се-
         кунды, прошедшие от 00:00:00 значения времени по Гринвичу, т.е. с
         1 января 1980 года. Это значение обычно получается из вызова фун-
         кции time.
               Функция localtime разрывает значение time, корректирует зо-
         ну местного времени и переход на  летнее/зимнее  время,  если  он
         назначен,  и запоминает откорректированное время в структуре типа
         tm.(Смотрите gmtime для описания полей стрктуры tm.)
               В MS DOS даты раньше 1980 года  не  понимаются.  Если  time
         представляет  дату перед 1 января 1980 года ,localtime возвращает

         символьную строку, представленную 00:00:00 January 1,1980.
               Функция localtime делает изменения для зоны местного време-
         ни, если пользователь впервые установил переменную окружения  TZ.
         Значением  TZ должна быть названная трехбуквенная временная зона,
         например PST, следующая за возможным  знаковым  числом,  задающим
         различие  между  значением  времени  по Гринвичу и зоной местного
         времени. Число должно следовать за трехбуквенной  зоной  перехода
         на  летнее/зимнее время (например PDT). Функция localtime исполь-
         зует различия между значением времени по Гринвичу и местным  вре-
         менем  для  установки значения запомненного времени. Если в уста-
         новке TZ  присутствует  зона  перехода  на  летнее/зимнее  время,
         localtime  также  изменяет переход на летнее/зимнее время. Если в
         TZ нет текущего значения, используется значение PST8PDT, устанав-
         ливаемое по умолчанию.
               Когда TZ  установлена,  автоматически  устанавливаются  три
         другие переменные окружения - timezone, daylight, tzname. Смотри-
         те функцию tzset для описания этих переменных.

               Возвращаемое значение.

               Функция  localtime  возвращает  указатель  на  результат  в
         структуре. Возвращаемого значения в случае ошибки нет.
               См.также asctime, ctime, ftime, gmtime, time, tzset.

               Пример:

               #include <stddio.h>
               #include <time.h>
               main()
               {
                 struct tm *newtime;
                 char *am_pm="PM";
                 time_t long_time;
                 time(&long_time);
                 newtime=localtime(&long_time);
                 if(newtime->tm_hour<12)
                    am_pm="AM";
                 if(newtime->tm_hour>12)
                    newtime->tm_hour-=12;
                 printf("%.19s %s\n", asctime(newtime), am_pm);
               }

               На выходе:
               Tue Dec 10 11:30:12 AM


               LOCKING

               #include <sys\locking.h>
               #include <io.h>        требуется только для объявления
                                      функции
               int locking(handle,mode,nbyte);
               int handle;            файловый handle
               int mode;              режим блокировки файла
               int nbyte;             число блокированных байтов



               Описание.

               Функция locking блокирует  или  разблокирует  байты  nbytes
         файла, определенного по handle. Блокировка байтов в файле не раз-
         решает последующего чтения и записи этих байтов другими процесса-
         ми. Разблокировка файла разрешает другим процессам читать или за-
         писывать в байты, заблокированные ранее. Блокирование или разбло-
         кирование  начинается с текущей позиции указателя на файл и расп-
         ространяется до следующих nbyte байтов или до конца файла.
               Аргумент mode определяет выполняемые  действия  блокировки.
         Он может быть одной из следующих manifest-констант.


         Мanifest-константа                Значение

         LK_LOCK           Блокировка заданных байтов. Если  байты
                           не      заблокировались,     происходит
                           повторная попытка  блокировки  через  1
                           секунду. Если после 10 попыток байты не
                           заблокировались, возвращается ошибка.

         LK_RLCK           Аналогично LK_LOCK.

         LK_NBLCK          Блокировка заданных байтов.  Если байты
                           не заблокированы, возвращается ошибка.

         LK_NRLCK          Аналогично LK_NBLCK.

         LK_UNLCK          Разблокировка  заданных  байтов.  Байты
                           должны быть ранее заблокированы.


               Для  файла может быть заблокирована более чем одна область,
         но работа с перектытыми областями не допускается. Кроме  того,  в
         одно  и  то же время не может быть разблокирована более  чем одна
         область.
               Когда  файл  разблокируется,  область разблокируемого файла
         должна соответствовать  ранее  заблокированной  области.  Функция
         locking не может разблокировать одновременно смежные области, так
         как   если  две  области являются смежными, каждая область должна
         быть разблокирована отдельно.
               Все блокировки должны быть удалены  перед  закрытием  файла
         или перед выходом из программы.

               Возвращаемое значение.

               Функция locking возвращает 0, если она успешно выполнилась.
         Возвращаемое значение -1 свидетельствует о неудаче  и errno уста-
         навливается в одно из следующих значений:

         Значение                          Его смысл

         EACCES            принудительная блокировка (файл  всегда

                           блокирован или разблокирован).

         EBADF             неверный файловый handle.

         EDEADLOCK         принудительная блокировка. Это значение
                           возвращается,  если задан фллаг LK_LOCK
                           или  LK_RLCK, и файл  не   может   быть
                           заблокирован после  10 попыток.

               См.также open, creat.

               Замечание!  Функция  locking может быть использована только
         для версий MS DOS 3.0 и последующих, в ранних версиях MS DOS  она
         не дает никакого результата.

               Пример:

               #include <io.h>
               #include <sys\locking.h>
               #include <stdlib.h>
               extern unsigned char _osmajor;
               int fh;
               long pos;
               .
               .
               .
               /*  сохранить текущую позицию указателя на файл, затем бло-
         кировать область от начала файла до сохраненной позиции указателя
         на файл */
               if (_osmajor >= 3)  {
                  pos=tell(fh);
                  lseek(fh, OL, O);
                  if ((locking(fh, LK_NBLCK,pos)) != -1)  {
                  .
                  .
                  .
                  lseek(fh, OL, O);
                  locking((fh, LK_UNLCK, pos);
                                                           }
                                    }


               LOG-LOG10

               #include <math.h>
               double log(x);    вычисляет натуральный логарифм x.
               double log10(x);  вычисляет десятичный  логарифм x.
               double x;         значение с плавающей точкой.

               Описание.

               Функции log и log10 вычисляют соответственно натуральный  и
         десятичный логарифм x.


               Возвращаемое значение.

               Функции  log и log10 возвращают результат логарифма. Если x
         отрицательное значение, обе функции печатают сообщение об  ошибке
         DOMAIN  в stderr и возвращают отрицательное значение HUGE. Если x
         равно 0, обе функции печатают сообщение об ошибке SING и  возвра-
         щают отрицательное значение HUGE. И в том и в другом случае errno
         устанавливается в EDOM.
               Обработка  ошибок  может  быть модифицирована при изменении
         процедуры matherr.
               См.также exp, matherr, pow.

               Пример:

               #include <math.h>
               double xx = 1000.0, y;
               y = log(x);   /* y = 6.907755 */
               /* функция log10 вычисляет десятичный логарифм для заданно-
         го значения */
               y = log10(x); /* y = 3.0 */



               LONGJMP.

               #include <setjmp.h>
               void longjmp(env, value);
               jmp_buf env;                  переменная,   в  которой
                                             хранится окружение
               int value;                    значение,   возвращаемое
                                             при вызове setjmp.

               Описание.

               Функция longjmp восстанавливает состояние стека, ранее сох-
         раненное в env функцией setjmp.
               Функции setjmp и longjmp обеспечивают возможность  выполне-
         ния  нелокального  (nonlocal)  перехода и обычно используются для
         передачи управления на выполнение обработки ошибок;  восстанавли-
         вают  код в ранее вызванной процедуре (без использования обычного
         вызова); возвращают условные обозначения.
               Вызовом setjmp сохраняется текущее состояние стека  в  env.
         Последующий вызов longjmp восстанавливает сохраненное состояние и
         возвращает управление на указатель (точку входа), непосредственно
         следующий за соответствующим вызовом setjmp.
               Выполнение  возобновляется,  когда  вызов setjmp возвращает
         заданное value. Когда вызывается longjmp, значения всех  перемен-
         ных  (за  исключением  переменных регистра) становятся доступными
         для процедуры, которая принимает управление и  содержит  значения
         этих переменных. Значения переменных регистра непредсказуемы.
               Функция longjmp должна вызываться ранее функции, определяю-
         щей возврат setjmp. Если longjmp вызвана после функции, определя-
         ющей возврат setjmp, то может произойти непредсказуемое поведение
         программы.
               Значение  value,  возвращаемое longjmp, должно быть ненуле-
         вым. Если для value задан аргумент 0, значение возврата заменяет-

         ся значением 1.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См. также setjmp.

               Предупреждение! Значения переменных регистра  в  процедуре,
         вызывающей setjmp, после выполнения longjmp не могут быть восста-
         новлены к собственным значениям.


            Пример:

            #include <stdio.h>
            #include <setjmp.h>
            jmp_buf mark;
            main()
                 {
                 if (setjmp(mark) != 0)
                 {   printf("longjmp has been called\n");
                     recover();
                     exit(1);
                  }
                 printf("setjmp has been called\n");
                 .
                 .
                 .
                 p();
                 .
                 .
                 .
                 }

            p()
                {
                int error = 0;
                .
                .
                .
                if (error != 0)
                   longjmp(mark, -1);
                .
                .
                .
                }

            recover()
                {

               /*  при  выходе из программы убедитесь, что файлы данных не
         будут запорчены */
               .
               .
               .
               }.




               LSEEK


               #include <stdio.h>   требуется  только  для объявления
                                    функций.
               long lseek (stream, offset, origin);
               int handle;           handle, ссылающийся на  открытый
                                     файл
               long offset;          число байтов из origin.
               int оrigin;           начальная позиция.

               Описание.

               Функция lseek передвигает указатель на файл (если он есть),
         связанный с handle, на новое место расположения, которое является
         байтами offset из origin.
               Следующая операция в файле выполняется на новом месте  рас-
         положения.
               Аргумент origin может быть одной из следующих констант, оп-
         ределенных в <stdio.h>.

            ORIGIN                ОПРЕДЕЛЕНИЕ

            SEEK-SET              начало файла.

            SEEK-CUR              текущая позиция указателя на
                                  файл.

            SEEK-END              конец файла.

               Функция  lseek используется для перемещения указателя в лю-
         бое место файла. Указатель должен быть размещен вне конца  файла.
         Однако попытка расположить указатель на файл в начале файла обыч-
         но приводит к ошибке.

               Возвращаемое значение.

               Функция  lseek возвращает разветвление origin в байтах, оп-
         ределенное как значение от новой позиции до начала файла. Возвра-
         щаемое значение -1 указывает на ошибку; errno  устанавливается  в
         одно из следующих значений:

            ВЕЛИЧИНА                ЕЕ СМЫСЛОВОЕ  ЗНАЧЕНИЕ

            EBADF               Неверный handle-р файла.

            ENIVAL              Неверное значение для origin   или
                                позиция,  определенная  при помощи
                                offset,  находится  перед  началом
                                файла.

               Для устройств, не приспособленных для поиска (seek), (таких

         как терминал и печать), возвращаемое значение неопределено.
               См. также fseek, tell.

            Пример:

            #include <io.h>
            #include <fcntl.h>
            #include <stdlib.h>
            int fh;
            long position;
            fh = open("data", O_RDONLY);
            .
            .
            .
            /* 0 - разветвление от начала */
            position = lseek (fh, 0L, SEEK_SET);
            if (position == -1L)
               perror("lseek to beginning failed");
            .
            .
            .
            /* находит текущую позицию */
            position = lseek (fh, 0L, SEEK_CUR);
            if (position == -1L)
               perror("lseek to current position failed");
            .
            .
            .
            /* выполняет до конца файла */
            if (position == -1L)
               perror("lseek to end failed");.


               LTOA

               #include <stdlib.h>         Требуется    только    для
                                           объявления функции
               char *ltoa(value,string,radix);
               int value;                  преобразуемое число
               char *string;               строка результата
               int radix;                  основание value

               Описание.

               Функция ltoa преобразует символы value в символьную строку,
         заканчивающуюся  NULL-символом,  и запоминает результат в string.
         Аргумент radix определяет основание системы счисления для  value;
         его  значение может лежать в пределах от 2 до 36. Если radix = 10
         и value - отрицательное число, то первым символом  результирующей
         строки будет знак минус.

               Возвращаемое значение.

               Функция  ltoa возвращает указатель на строку. Возвращаемого
         значения в случае ошибки нет.

               См.также itoa, ultoa.

               Замечание! Размер памяти, отводимой для string, должен быть
         больше, чем требуется для возвращаемой строки. Функция может воз-
         вращать строку длиной до 33 байтов.

               Пример:

               #include <stdlib.h>
               int radix=10;
               char buffer[20];
               char *p;
               p=itoa(-344115L,buffer,radix); /*p="-344115"*/


               MALLOC

               #include <malloc.h>    требуется только для объявления
                                      функции
               char *malloc(size);
               unsigned size;         количество байтов в захваченном
                                      блоке

               Описание.

               Функция malloc захватывает блок памяти  по крайней мере  не
         меньшей,  чем  из  size байтов. (Блок может быть больше, чем size
         байтов, принадлежащих пространству, которое требуется для  вырав-
         нивания и для поддержания информации).

               Возвращаемое значение.

               Функция  malloc  возвращает  char-указатель  на захваченное
         пространство.
               В памяти, на которую указывает возвращаемое  значение,  га-
         рантировано  выравнивание для хранения любого типа объекта. Чтобы
         получить указатель на тип, отличный от char, используется  преоб-
         разователь типа возвращаемого значения.
               Возвращается  значение NULL, если свободной памяти осталось
         мало.
               См.также calloc, free, realloc.

               Пример:

               #include <malloc.h>
               int *intarray;
               /* захватывает пространство для 20 целых */
               intarray=(int*)malloc(20*sizeof(int));


               MATHERR

               #include <math.h>
               int matherr(x);
               struct exception *x;     информация  о  математических

                                        исключениях

               Описание.

               Функция matherr обрабатывает ошибки, порожденные  функциями
         математической   библиотеки.   Математические   функции  вызывают
         matherr, когда обнаружена ошибка. Пользователь  может  обеспечить
         различные объявления (определения) для функции matherr, выполняю-
         щие обработку специальных ошибок.
               Если  в  математической  процедуре возникла ошибка, matherr
         вызывается с указателем на  следующую  структуру  (объявленную  в
         <math.h>) как аргумент.

               struct exeption {
               int type;
               char *name;
               double arg1, arg2, retval;
               };

               Type  определяет  тип  математической ошибки. Он может быть
         одним из следующих значений, объявленных в <math.h>

          Значение                       Его смысл

          DOMAIN               Ошибка области (определения) аргумента.

          SING                 Особенность аргумента.

          OVERFLOW             Ошибка диапазона (области) переполнения

          UNDERFLOW            Ошибка диапазона потери значимости.

          TLOSS                Общая потеря значимости.

          PLOSS                Частичная потеря значимости.

               Элемент структуры name является указателем на строку, окан-
         чивающуюся нулевым символом и содержащую имя  функции,  вызвавшей
         ошибку.  Элементы структуры arg1 и arg2 определяют значения, выз-
         вавшие ошибку. (Если задан только один аргумент, он  запоминается
         в  arg1).  Для заданной ошибки по умолчанию возвращается значение
         retval. Это значение можно изменить.  По  возвращаемому  значению
         можно  определить,  действительно  или  нет возникла ошибка. Если
         matherr возвращает 0, высвечивается сообщение об ошибке  и  errno
         устанавливается  в  приблизительное значение ошибки. Если matherr
         возвращает ненулевое значение, сообщение об ошибке не  высвечива-
         ется  и errno остается неизменной.


               Возвращаемое значение.

               Функция  matherr  в  случае ошибки возвращает 0 и ненулевое
         значение, если действие верно и успешно выполнено.
               См.также acos, asin, atan, atan2, bessel, ccabs, cosh, exp,
         hypot, log, pow, sin, sinh, sqrt, tan.


               Пример:

               #include <math.h>
               #include <string.h>
               /* вылавливает ошибки в вызовах процедур log и log10.  Если
         ошибка  является  результатом  отрицательного  аргумента  (ошибка
         DOMAIN), возвращается log или log10 для абсолютного значения  ар-
         гумента.  Появляется  сообщение об ошибке. Если ошибка является 0
         аргументом  или ошибка сгенерирована некоторой другой процедурой,
         действие выбирается по умолчанию */
               int matherr(x)
               struct exception *x;
               {
               if (x->type==DOMAIN) {
                 if(strsmp(x->name,"log")==0\0  {
                    x->retval=log(-(x->arg1));
                    return(1);
                    }
                 else if(strsmp(x->name,"log10")==0) {
                    x->retval=log10(-(x->arg1));
                    return(1);
                    }
               }
               return(0);
               /* используется действие по умолчанию */
               }


               _MEMAVL

               #include <malloc.h>    требуется только для объявления
                                      функции
               unsigned int_memavl();

               Описание.

               Функция _memavl возвращает приблизительный размер памяти  в
         байтах,  доступной  для  динамического  размещения в умалчиваемом
         сегменте данных.  Эта  функция  может  использоваться  с  calloc,
         malloc,  realloc в малой и средней моделях памяти и с _nmalloc во
         всех моделях памяти.

               Возвращаемое значение.

               Функция _memavl возвращает размер в байтах как  беззнаковое
         целое.
               См.также calloc, malloc, _freect, realloc, stackavail.

               Пример:

               main()
               {
               long *longptr;
               printf("Memory available before malloc=%u\n",

                     _memavl());
               longptr=(long*)malloc(5000*sizeof(long));
               printf("Memory available after malloc=%u\n",
                     _memavl());
               }


               MEMCCPY

               #include <memory.f>          Требуется   только    для
               #include <string.h>          объявления функции;   ис-
                                            пользует либо <string.h>,
                                            либо <memory.h.>

               char *memccpy(dest,src,c,cnt);
               char *dest;                   Указатель  на  результат
               char *src;                    Указатель  на   исходный
                                             буфер
               int c;                        Последний     копируемый
                                             символ
               insigned cnt;                 Количество символов

               Описание.

               Функция  memccpy  копирует 0 или более байтов из src в dest
         вплоть до первого появления символа, указанного в переменной c (и
         включая его), или пока не будет скопировано cnt байтов.

               Возвращаемое значение.

               Если  символ  c скопирован, memccpy возвращает указатель на
         тот байт в dest, который непосредственно следует за символом. Ес-
         ли c не был скопирован, memccpy возвращает NULL.
               См. также функции memchr, memcmp, memcpy, memset.

               Пример:

               #include <memory.h>
               char buffer[100],source[100];
               char *result;
               .
               .
               .
               /* Копируются байты из source в buffer, пока не будет
               ** скопировано '\n', но не более 100 байтов
               */
               result=memccpy(buffer,source,'\n',100);


               MEMCHR

               #include <memory.h>       Требуется только для
               #include <string.h>       объявления функции; исполь-
                                         зует либо  <string.h>, либо
                                         <memory.h>

               char *memchr(buf,c,cnt);
               char *buf;                 Указатель на буфер
               int c;                     Копируемый символ
               unsigned cnt;              Количество символов

               Описание.

               Функция memchr находит первые cnt байтов из buf с целью об-
         наружения первого появления символа c. Поиск продолжается до  тех
         пор, пока не будет найден указанный символ или не будут проверены
         все cnt байтов.

               Возвращаемое значение.

               Функция memchr возвращает указатель на расположение символа
         c  в  buf.  Если  символ c не будет обнаружен в первых cnt байтах
         buf, возвращается NULL.
               Cм. также memccpy, memcmp, memcpy, memset.

               Пример:

               #include <memory.h>
               char buffer[100];
               char *result;
               .
               .
               .
               /*  Поиск первого символа 'a' в buffer. Если 'a' нет в
               ** первых 100 байтах, возвращается NULL
               */
               result=memchr(buffer,'a',100);


               MEMCMP

               #include <memory.h>       Требуется    только     для
               #include <string.h>       объявления функции; исполь-
                                         зует либо  <memory.h>, либо
                                         <string.h>
               int memcmp(buf1,buf2,cnt);
               char *buf1;                Первый буфер
               char *buf2;                Второй буфер
               unsigned cnt;              Количество символов


               Описание.

               Функция memcmp производит лексикографическое сравнение пер-
         вых cnt байтов из buf1 и buf2 и возвращает значение,  указывающее
         на соотношение этих буферов, так как показано ниже:

                Значение                          Смысл

                Меньше 0                      buf1 меньше,чем buf2


                0                             buf1 идентичен buf2

                Больше 0                      buf1 больше,чем buf2


               Возвращаемое значение.

               Функция memcmp возвращает целое число.
               См. также memccpy, memchr, memcpy, memset.

               Пример:

               #include <memory.h>
               char first[100], second[100];
               int result;
               /* Следующий оператор сравнивает first[] и second[] и
               ** определяет, что из них больше. Если   первые  100
               ** байтов указанных буферов идентичны, то они счита-
               ** ются равными */
               result=memcmp(first,second,100);


               MEMCPY

               #include <memory.h>   требуется только  для объявления
               #include <string.h>   функции;   использует       либо
                                     <string.h>, либо <memory.h>
               char memcpy (dest, src, cnt);
               char *dest;           указатель на результат
               char *src;            указатель на исходный буфер
               unsigned cnt;         количество символов


               Описание.

               Функция  memcpy копирует cnt байтов из src в dest. Если не-
         которые участки src и dest перекрываются, memcpy гарантирует, что
         байты из перекрываемого участка, принадлежащие src, будут  скопи-
         рованы перед перезаписью.

               Возвращаемое значение.

               Функция memcpy возвращает указатель на dest.
               См.также memccpy, memchr, memcmp, memsct.

               Пример:

               #include <memory.h>
               char source [200], destiination [200];
               .
               .
               .
               /*  Пересылаются  200 байтов из **source в destination ** и
         возвращается указатель на destination */
               memcpy (destination, source, 200);



               MEMICMP


               #include <memory.h>   требуется только для  объявления
               #include <string.h>   функции;    использует      либо
                                     <string.h>, либо <memory.h>
               int memicmp (buf1, buf2, cnt);
               char *buf1;                    первый буфер
               char *buf2;                    второй буфер
               unsigned cnt;                  количество символов

               Описание.

               Функция memicmp  лексикографически  сравнивает  первые  cnt
         байтов из buf1 и buf2 вне зависимости от типа регистра, т.е. бук-
         вы верхнего и нижнего регистров считаются эквивалентными. Функция
         memicmp возвращает значение, указывающее соотношение buf1 и buf2,
         а именно:

               Величина               Значение

               меньше 0          buf1 меньше, чем buf2

               0                 buf1 идентично buf2

               больше 0          buf1 больше, чем buf2

               Возвращаемое значение.

               Функция memicmp возвращает целое число.
               См.также memccpy, memchr, memcmp, memcpy, memset.

               Пример:

               #include <memory.h>
               char first[100], second [100];
               int result;
               strcpy (first,"Those, Who Will Not Learn from
                       History");
               strcpy  (second,  "THOSE WHO WILL NOT LEARN FROM their
                        mistakes");
               result = memicmp (first, second, 29);
               printf ("%d\n", result);

               На выходе:
                       0


               MEMSET

               #include <memory.h>   требуется только для  объявления
               #include <string.h>   функции;    использует      либо
                                     <string.h>, либо <memory.h>

               char *memset (dest, c, cnt);
               char *dest;                 указатель на результат
               int c;                      символ-заполнитель
               unsigned cnt;               количество символов

               Описание.

               Функция memset заполняет первые cnt байтов буфера dest сим-
         волом c.

               Возвращаемое значение.

               Функция memset возвращает указатель на буфер dest.
               См.также memccpy, memchr, memcmp, memcpy

               Пример:

               #include <memory.h>
               char buffer [100];
               /* заполняет первые 100 байтов buffer
               ** нулями */
               memset (buffer, '\0', 100);


               MKDIR

               #include <direct.h>  требуется  только для  объявления
                                    функции
               int mkdir(pathname);
               char *pathname;      path-имя нового директория

               Описание.

               Функция mkdir создает новый директорий с заданным pathname.
         В  одно  и  то же время может быть создан только один директорий,
         потому что только последняя компонента  pathname  может  называть
         новый директорий.

               Возвращаемое значение.

               Функция  mkdir возвращает значение 0, если создан новый ди-
         ректорий. Возвращаемое значение -1 свидетельствует об  ошибке   и
         errno устанавливается в одно из следующих значений:


         Значение                      Его смысл

         EACCES               Директорий  не  создан.  Заданное   имя
                              является  именем  существующего  файла,
                              директория, устройства.

         ENOENT               Path-имя не найдено.

               См.также chdir, rmdir.


               Пример:

               #include <direct.h>
               int result;
               /*  следующие  2  оператора  создают 2 новых директория: **
         один - в корне диска b, второй - в поддиректории ** "tmp" текуще-
         го рабочего директория */
               result=mkdir("b:/tmp); /* может быть использовано
                                      ** также "b:\\tmp" */
               result=mkdir("tmp/sub"); /* может быть использовано
                                        ** также "tmp\\sub" */



               MKTEMP

               #imclude <io.h>   требуется только для объявления
                                 функции
               char *mktemp(template);
               char *template;   шаблон имени файла

               Описание.

               Функция  mktemp  создает  уникальное имя файла, модифицируя
         данный template. Аргумент template имеет форму:

               baseXXXXXX,

               где base является частью нового имени файла,  предлагаемого
         пользователем  и X...X являются знакоместами для части, формируе-
         мой mktemp; mktemp сохраняет base и заменяет шесть  Х  алфавитным
         символом,  следующим  за значением из 5 цифр. 5-цифровое значение
         является уникальным номером, идентифицирующим вызываемый процесс.
         При первом вызове mktemp с заданным  template  алфавитный  символ
         равен  символу  0('0').  В  последующих вызовах из того же самого
         процесса с тем же самым template mktemp проверяет, использовались
         ли ранее возвращенные имена для создания файлов. Если файла с за-
         даным именем не существует, mktemp возвращает это имя.  Если  для
         всех ранее возвращенных имен файлы существуют, mktemp создает но-
         вое имя, заменяя в нем алфавитный символ следующей доступной бук-
         вой нижнего регистра.
               Например,  если  первое возвращенное имя было t012345 и это
         имя использовалось для создания файла, то следующее  возвращаемое
         имя  будет ta12345. При создании новых имен mktemp использует '0'
         и буквы нижнего регистра от "a" до "z".

               Возвращаемое значение.

               Функция mktemp  возвращает  указатель  на  модифицированный
         template.  Возвращаемым  значением  является  NULL, если аргумент
         template образован неверно или больше не может быть создано  уни-
         кальных имен из заданного template.
               Смотри также fopen, getpid, open.

               Замечание.  Функция mktemp генерирует уникальные имена фай-

         лов, но не создает и не открывает файлы.

               Пример:

               #include <io.h>
               char *template="fnXXXXXX";
               char *result;

               /* следующий оператор вызывает mktemp для создания **  уни-
         кального имени файла */
               result=mktemp(template);
               MODF
               #include <math.h>
               double modf(x,intptr);
               double x;              значение с плавающей точкой
               double *intptr;        указатель на хранение целой части

               Описание.

               Функция  modf  разрывает  значение  с плавающей точкой x на
         дробную и целую части. Возвращается знаковая дробная часть x. Це-
         лая часть хранится в intptr как значение с плавающей точкой.

               Возвращаемое значение.

               Функция modf возвращает знаковую дробную часть x. Возвраща-
         емого значения в случае ошибки нет.
               См. также frexp, ldexp.

               Пример:

               #include <math.h>
               double x,y,n;
               x = -14.87654321;
               y = modf(x,&n);   /* y = -0.87654321, n = -14.0 */


               MOVEDATA

               #include <memory.h>           Требуется   только   для об-
               #include <string.h>           явления  функции, использует
                                             либо   <string.h>,      либо
                                             <memory.h>

              void movedata (srcseg,  srcoff,  destseg,  destoff,
                          nbytes);
              int srcseg;                    адрес исходного сегмента
              int srcoff;                    смещение исходного сегмента
              int destseg;                   адрес результирующего сегмента
              int destoff;                   смещение  результирующего сег-
                                             мента
              unsigned nbytes;               количество байтов


               Описание.

               Функция movedata копирует nbytes байтов, начиная с исходно-
         го адреса, обозначенного srcseg:srcoff, в адрес результата, обоз-
         наченный destseg:destoff. Функция movedata предназначена для  пе-
         ресылки  far-данных  в  программах малых или средних моделей, где
         адреса сегментов данных не известны. В программах больших моделей
         может быть использована функция memcpy,  когда  адреса  сегментов
         известны.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См. также memcpy, segread, FP_SEG.

               Замечание!  Значения  сегментов  для  аргументов  srcseg  и
         destseg могут быть получены с  помощью  применения  либо  функции
         segread, либо макроопределения FR_SEG.
               Функция movedata не обрабатывает все случаи пересылок с пе-
         рекрытием  корректно  (пересылки  с перекрытием происходят тогда,
         когда часть результирующего поля является в этой же области памя-
         ти частью исходного). Пересылки с перекрытием корректно обрабаты-
         ваются функцией memcpy.

               Пример:

               #include <memory.h>
               #include <dos.h>
               char far *src;
               char far *dest;
               .
               .
               .
               /* следующие операторы пересылают 512
                   ** байтов данных из src в dest.   */

               movedata (FP_SEG (src), FPSEG(dest),
                          FP_OFF(dest), 512);


               _ MSIZE

               #include <malloc.h>       требуется только для  объявления
                                         функции

               unsigned_msize(ptr);
               char *ptr;                указатель на блок памяти

               Описание.

               Функция _ msize возвращает размер блока памяти (в  байтах),
         распределенного посредством вызовов calloc, malloc или realloc.

               Возвращаемое значение.

               Величина в байтах возвращается как беззнаковое целое.
               См. также calloc, _expand, malloc, realloc.


               Пример:

               #include <stdio.h>
               #include <malloc.h>
               main()
               {
               long *oldptr;
               unsigned int newsize=64000;

               oldptr=(long*)malloc(10000*sizeof(long));
               printf("Size of memory block pointed to by
                     oldptr=%u\n", _msize(oldptr));

               if (_expand(oldptr,newsize) != NULL)
               printf("expand was able to increase block to
                      %u\n", _msize(oldptr));
               else
                printf("expand was able to increase block to
                       only %u\n", _msize(oldptr));
               }

              _NFREE

               #include <malloc.h>      требуется только  для  объявления
                                        функции
               void _nfree(ptr);
               char near *ptr;          указатель  на  захваченный блок
                                        памяти

               Описание.

               Функция _nfree освобождает блок памяти. Аргумент ptr указы-
         вает на ранее захваченный блок памяти посредством _nmalloc.
               Числом  освобожденных байтов является число байтов, опреде-
         ленных при захвате блока. После вызова освободившиеся блоки  при-
         годны к размещению.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См.  также _nmalloc, free, malloc.

               Замечание.  Попытка  освободить  неверный ptr (указатель не
         захватывается посредством _nmalloc) может привести к последующему
         захвату и вызвать ошибку.

               Пример:

               #include <malloc.h>
               #include <stdio.h>

               char near *alloc;

               /* захватывает 100 байтов и затем освобождает их */


               /* проверяет указатель на правильность: */

               if ((alloc=_nmalloc(100))==NULL)
               printf("unable to allocate memory\n");
               else {
                .
                .
                .
               /* освобождает память для heap: */

               _nfree(alloc);
                   }

              _NMALLOC

               #include <malloc.h>       требуется только для  объявления
                                         функции

               char near *_nmalloc(size);
               unsigned size;            количество байтов в захваченном
                                         блоке


               Описание.

               Функция _nmalloc внутри умалчиваемого сегмента данных  зах-
         ватывает блок памяти, по крайней мере не меньше, чем из size бай-
         тов. (Блок может быть больше, чем из size байтов,но принадлежащих
         пространству, которое требуется для выравнивания).

               Возвращаемое значение.

               Функция _nmalloc возвращает near-указатель на char. В памя-
         ти, на которую указывает возвращаемое значение, гарантировано вы-
         равнивание  для хранения любого типа объекта. Чтобы получить ука-
         затель на тип, отличный от char, используется преобразователь ти-
         па возвращаемого значения.
               Возвращается значение NULL, если пространство не было  зах-
         ваченным.
               См. также _nrfee, _msize, malloc, realloc.

               Пример:

               #include <malloc.h>
               int *intarray;
               /* захватывает память для 20 целых */
               intarray=(int*)_nmalloc(20*sizeof(int));

               _NMSIZE

               #include <malloc.h>       требуется только  для объявления
                                         функции
               unsigned _nmsize(ptr);
               char near ptr;            указатель на блок памяти


               Описание.

               Функция  _nmsize  возвращает  размер блока памяти в байтах,
         захваченного посредством _nmalloc.

               Возвращаемое значение.

               Функция _nmsize возвращает размер в байтах, как беззнаковое
         целое.
               См. также  _ffree,  _fmalloc,  _fmsize, malloc, _msize,
        _nfree, _nmalloc.

               Пример:

               #include <malloc.h>

               #include <stdio.h>

               main()
                 {
                char near *stringarray;

                stringarray=_nmalloc(200*sizeof(char));
                if (stringarray != NULL)
                   printf("%u bytes allocated\n",
                          _nmsize(stringarray));
                else
                   printf("Allocation request failed.\n");
                }


               ONEXIT

               #include <stdlib.h>       требуется только  для  объявления
                                         функции
               onexit_t onexit(func);    тип  onexit_t,  определенный  в
                                         <stdlib.h>
               onexit_t func;

               Описание.

               Функция onexit передает адрес функции (func), которая будет
         выполнена, если программа нормально завершится.  Успешные  вызовы
         onexit  создают  набор функций, выполняемый по правилу магазина -
         "последний зашел, первый вышел". При  помощи  onexit  могут  быть
         созданы  наборы  не  более   чем из 32 функций; onexit возвращает
         значение NULL, если число функций в наборе превышает 32. Функции,
         передаваемые к onexit, не могут иметь параметров.

               Возвращаемое значение.

               Функция onexit в случае успеха возвращает указатель на фун-
         кцию  и возвращает NULL, если не осталось места для хранения ука-
         зателя на функцию.

            См.также exit.

               Пример:

               #include <stdlib.h>
               main()
               {
               int fn1(), fn2(), fn3(), fn4();
               onexit(fn1);
               onexit(fn2);
               onexit(fn3);
               onexit(fn4);
               printf("This is executed first.\n");
               }
               int fn1()
                   {
                   printf("next.\n");
                   }
               int fn2()
                   {
                   printf("executed");
                   }
               int fn3()
                   {
                   printf("is");
                   }
               int fn4()
                   {
                   printf("This");
                   }


               На выходе:

               This is executed first.
               This is executed next.


               OPEN

               #include <fcntl.h>
               #include <sys\types.h>
               #include <sys\stat.h>
               #include <io.h>        требуется только для объявления
                                      функций.
               int open(pathname, oflag [[, pmode]]);
               char *pathname;        path-имя файла
               int oflag;             доступный тип операций
               int pmode;             разрешенный тип доступа.

               Описание.

               Функция open открывает файл, определяемый по  path-имени, и
         подготавливает  его к последующему чтению или записи, что опреде-
         ляется посредством oflag.

               Аргумент oflag является целым выражением, состоящим из ком-
         бинации одной  или  более  манифестных  констант,  объявленных  в
         <fcntl.h>. Если задана больше  чем одна константа, тогда они объ-
         единяются при помощи логического оператора ИЛИ (:).

            OFLAG                          ЗНАЧЕНИЕ

            O_APPEND        Указатель  на файл  перемещен  в конец
                            файла перед каждой операцией записи.

            O_CREAT         Новый файл создан и открыт для записи;
                            это  не  эффективно,  если  существует
                            файл, определяемый по path-имени.

            O_EXCL          Возвращается  значение   ошибки,  если
                            существует файл, определяемый по path-
                            имени.  Применяется  только  вместе  с
                            O_CREATE.

            O_RDONLY        Файл  открыт  только  для чтения; если
                            задается этот флаг, может быть  выбран
                            либо флаг O_RDWR, либо O_WRONLY.

            O_RDWR          Файл   открыт  одновременно для чтения
                            и записи;  если  задается  этот  флаг,
                            может быть выбран  либо флаг O_RDONLY,
                            либо O_WRONLY.

            O_TRUNC         Существующий файл  открыт и  усечен  к
                            длине  0;   этот  файл  должен   иметь
                            разрешение на запись. Содержимое файла
                            уничтожается.

            O_WRONLY        Файл  открыт  только  для чтения; если
                            задан этот  флаг,  должен  быть  задан
                            также либо флаг O_RDONLY, либо ORDWR.

            O_BINARY        Файл  открыт  в  двоичном (не трансли-
                            рованном) режиме.  (См. описание  дво-
                            ичного режима у функции fopen).

            O_TEXT          Файл  открыт  в  текстовом   (трансли-
                            рующем) режиме. (См. описание  тексто-
                            вого режима у функции fopen).

               Замечание!  O_TRUNC полностью уничтожает содержимое сущест-
         вующего файла; поэтому нужно внимательно использовать  эту  конс-
         танту.
               Аргумент  pmode  требуется  только  тогда, когда определена
         константа O_CREAT. Если файл существует,  pmode  игнорируется.  В
         противном  случае   pmode определяет разрешенные типы доступа для
         файла, которые устанавливаются во время первого  закрытия  нового
         файла.
               Pmode  - целое выражение, содержащее одну или обе манифест-
         ные константы S_IREAD, S_IWRITE, объявленные в <sys\stat.h>. Когда

         заданы  обе константы, они объединяются логическим оператором ИЛИ
         (:). Значение аргумента pmode приводится ниже.

            КОНСТАНТА            ЕЕ СМЫСЛОВОЕ ЗНАЧЕНИЕ

            S_IWRITE             разрешает запись.

            S_IREAD              разрешает чтение.

            S_IREAD|S_IWRITE     разрешают чтение и запись.

               Если запись не разрешена, файл предназначен только для чте-
         ния. В MS DOS все файлы открыты для чтения; для них  не  возможно
         задать  разрешение  только  на запись. Поэтому, модели S_IWRITE и
         S_IREAD: S_IWRITE являются эквивалентными.
               Функция open перед установкой разрешенного доступа  прикла-
         дывает текущую маску файла к pmode. (Подробно об этом описывается
         у функции umask).

               Возвращаемое значение.

               Эта функция возвращает handle на созданный файл. Возвращае-
         мое значение -1 указывает на ошибку; errno устанавливается в одно
         из следующих значений.

            ЗНАЧЕНИЕ                ЕГО СМЫСЛ

            EACCES         Заданное path-имя является директорием;
                           или сделана попытка  записать  в  файл,
                           открытый   только   для   чтения,   или
                           возникло  sharing-нарушение.  (Sharing-
                           режим файла для операций не допускается.
                           Версии MS DOS 3.0 и старше).

            EEXIST         Флаги O_CREAT и O_EXCL  определены,  но
                           названный файл всегда существует.

            EMFILE         Другие handle-ры файла не доступны, т.к.
                           много открытых файлов.

            ENOENT         Файл или path-имя не найдено.

               См.  также  access,  chmod, close, creat, dup, dup2, fopen,
         sopen, umask.

            Пример:

            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>
            main ()
             {
              int fh1, fh2;

              fh1 = open("data1", O_RDONLY);
              if (fh1 == -1)
                  perror("open failed on input file");
              fh2 = open("data2", O_WRONLY:O_TRUNC:O_CREAT,
                                  S_IREAD:S_IWRITE);
              if (fh2 == -1)
                  perror("open failed on output file");
              .
              .
              .
             }.
              fh1 = open("data1", O_RDONLY);
              if (fh1 == -1)
                  perror("open failed on input file");.



               OUTP

               #include <conio.h>     требуется только для объявления
                                      функции
               int outp(port, value);
               unsigned port;         номер порта
               int value;             выводимое значение

               Описание.

               Функция outp записывает значение value в выходной порт, оп-
         ределенный по port. Аргумент port может  быть  любым  беззнаковым
         целым  в  пределах  от 0 до 65535, value может быть любым целым в
         пределах от 0 до 255.
               См.также inp.

               Пример:

               #include <conio.h>
               int port, byte_val;
               .
               .
               .
               /* следующий оператор выводит тот байт из порта, на который
         установлен port. */
               outp (port, byte_val);.


               PERROR

            #include <stdlib.h>            требуется только для
                                           обьявления функции

            void perror(string);
            char *string;                  сообщение, поставляемое
                                           пользователем

            int errno;                     счетчик ошибок
            int sys_nerr;                  число системных сообще-
                                           ний
            char sts_errlist[sys_nerr];    массив   сообщений   об
                                           ошибках.

               Описание.

               Функция perror печатает сообщение об  ошибке  в  stderr.  В
         этом сообщении аргумент string печатается первым, затем печатает-
         ся двоеточие, системное сообщение об ошибке для последнего библи-
         отечного вызова, выработавшего ошибку, и новая строка. Номер дей-
         ствительной ошибки хранится в переменной errno, которая объявлена
         на  внешнем  уровне. Системное сообщение об ошибке доступно через
         переменную sys_errlist, которая является массивом  сообщений  для
         счетчика ошибок.
               Функция  perror печатает приблизительное сообщение об ошиб-
         ке, используя значение errno как индекс для sys_errlist. Значение
         переменной sys_nerr определяется как максимальное число элементов
         в массиве sys_errlist.
               Чтобы выработать правильный результат, функция perror долж-
         на быть вызвана сразу же после библиотечной процедуры, возвращаю-
         щей ошибку. Иначе  значение errno  может  быть  перезаписано  для
         последующих вызовов.

               Возвращаемое значение.

               Функция perror не возвращает никакого значения.
               См. также clearerr, ferror, strerror.

               Замечание. В MS DOS некоторые значения errno, приведенные в
         <errno.h>,  не  используются.  Смотрите  приложение "Сообщение об
         ошибках", где приведен список значений errno, используемых  в  MS
         DOS,  и соответствующие сообщения об ошибках. Для значения errno,
         не использующегося в MS DOS, функция perror печатает пустую стро-
         ку.


               Пример.

            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>


            int fh1, fh2;

            fh1 = open("data1", O_RDONLY);
            if (fh1 == -1)
               perror("open failed on input file");

            fh2 = open("data2", O_WRONLY:O_TRUNC:O_CREAT,
                       S_IREAD:S_IWRITE);
            if (fh2 == -1)
               perror("open failed on output file");.


               POW

            #include <math.h>

            double pow(x,y);
            double x;               возводимое число
            double y;               степень числа x

               Описание.

               Функция pow вычисляет x, возведенное в степень y.

               Возвращаемое значение.

               Функция pow возвращает значение x в степени y. Если y равна
         0, pow возвращает значение 1. Если x равно 0 и  y  отрицательная,
         pow  устанавливает errno в ERANGE и возвращает HUGE. Если x отри-
         цательное, а y не является целой, функция печатает  сообщение  об
         ошибке DOMAIN в stderr, устанавливает errno в ERANGE и возвращает
         либо  положительное,  либо  отрицательное значение HUGE. В случае
         переполнения или потери значимости никакого сообщения не  печата-
         ется. См.также exp, log, sqrt.

               Пример.

            #include <math.h>
            double x = 2.0, y = 3.0, z;
            .
            .
            .
            z = pow(x,y);  /* z = 8.0 */


               PRINTF

            #include <stdio.h>

            int printf (format-string [, argument...]);
            char *format-string;       строка управления форматом.



               Описание.

               Функция  printf  форматирует  и  печатает наборы символов и
         значений в выходной стандартный поток stdout. Строка формата сос-
         тоит из обычных символов, escape-последовательностей и,  если  за
         строкой формата следуют аргументы,    еще и спецификации формата.
         Обычные  символы  и escape-последовательности просто копируются в
         stdout в порядке их появления.

                Например, строка

            printf ("Line one\n\t\tLine two\n");

         выработает на выводе

            Line one
                            Line two.
               Более подробно escape-последовательности описываются в гла-
         ве 2.2.4 руководства MSC Compiler Language Reference.

               Если за строкой формата следуют аргументы arguments, то эта
         строка также должна содержать спецификации формата,  определяющие
         формат  вывода этих аргументов. Спецификация формата всегда начи-
         нается с символа знака процента (%). Ниже о нем описывается  под-
         робнее.
               Строка  формата  читается  слева направо. Когда встречается
         первая спецификация формата (если она есть), то значение  первого
         аргумента после строки формата преобразовывается и выводится сог-
         ласно заданной спецификации. Вторая спецификация формата вызывает
         преобразование  и  вывод  второго аргумента и так далее, до конца
         строки формата. Если аргументов больше, чем спецификаций формата,
         то эти дополнительные аргументы игнорируются. Результат  является
         неопределенным,  если аргументов недостаточно для всех специфика-
         ций формата.
               Спецификация формата имеет следующую форму:

            %х[flags][wigth][.precision][{F:N:h:I}]type.

               Каждое поле в спецификации формата является отдельным  сим-
         волом  или  числом,  выражающим  отдельную  опцию формата. Символ
         type, появляющийся после последнего необязательного поля формата,
         определяет аргумент как символ,  строку  или  число.  (См.  табл.
         R.1.).
               Простейшая  спецификация  формата  содержит  только символ
         знака  процента  и  символ  типа  (например, %S).  Необязательные
         поля  управляют другими аспектами форматирования, как описывается
         ниже.

            ПОЛЕ                      ОПИСАНИЕ

            flags          Включение   вывода  и  печати   знаков,
                           пробелов,       десятичных       точек,
                           восьмеричных     и    шестнадцатеричных
                           префиксов. (См. табл. R.2.).

            width          Минимальное число выводимых символов.


            precision      Максимальное число символов, печатаемых
                           на  всем  или  части  поля  вывода; или
                           минимальное  число   цифр   для  печати
                           целых значений. (См. табл. R.3.).

            F, N           Префиксы, позволяющие пользователю over-
                           ride,  по умолчанию,  адресацию соглаше-
                           ний моделей памяти.

            F              Используется для малой модели для печати
                           значения, объявленного far.

            N              Используется   для   средней, большой  и
                           huge-моделей  для near-значений.

                           F  и N могут быть использованы только с
                           типами символов s и  p,  поскольку  они
                           уместны     только    с    аргументами,
                           представляющими указатель.

            h, l           Предполагаемый размер аргумента:

                           h используется в  качестве  префикса  с
                           целыми   типами  d,  i,  o,  x,  X  для
                           определения,  что   аргумент   является
                           short int.

                           l  используется  в  качестве префикса с
                           типами d, i, o, x, X  для  обозначения,
                           что  аргумент является long int. Символ
                           l  используется  также  как  префикс  с
                           типами  e,  E, f, g, G для определения,
                           что  аргумент  является  скорее double,
                           чем float.

               Если за символом знака  процента  (%)  следует  символ,  не
         обозначающий  тип  формата,  то  этот  символ  копируется в поток
         stdout. Например, для печати символа знака процента  используется
         комбинация %%.


                                                      Таблица R.1.

                          Типы символов функции printf


            СИМВОЛ    ТИП АРГУМЕНТА          ФОРМАТ ВЫВОДА

              d         целый           целочисленный   десятичный
                                        знаковый

              i         целый           целочисленный   десятичный
                                        знаковый

              u         целый           беззнаковый  целочисленный

                                        десятичный

              o         целый           беззнаковый   восьмеричный
                                        целый

              x         целый           беззнаковый   шестнадцате-
                                        ричный целый, использующий
                                        "abcdef"

              X         целый           беззнаковый   шестнадцате-
                                        ричный целый,
                                        использующий "ABCDEF".

              f       с  плавающей      знаковое значение, имеющее
                      точкой            форму  [-]dddd.dddd,   где
                                        dddd  -  одна   или  более
                                        десятичных  цифр.    Коли-
                                        чество      цифр     перед
                                        десятичной точкой  зависит
                                        от   величины   числа,   а
                                        количество   цифр    после
                                        десятичной  точки  зависит
                                        от требуемой точности.

             e        с плавающей       знаковое значение, имеющее
                      точкой            форму [-]d.dddde[sign]ddd,
                                        где  d - десятичная цифра,
                                        dddd  -  одна  или   более
                                        десятичныхя  цифр,  ddd  -
                                        ровно    три    десятичных
                                        цифры,  и sign - либо "+",
                                        либо "-".

             E        с плавающей       идентично формату "e",  за
                      точкой            исключением   того,    что
                                        вместо "e" вводится "E".

             g        с плавающей       знаковое значение, распеча-
                      точкой            тываемое в формате "f" или
                                        "e",  и  являющееся  более
                                        компактным  для  выбранных
                                        значения  и точности  (как
                                        показано ниже). Формат "e"
                                        используется, только когда
                                        значение экспоненты меньше
                                        -4    или    больше,   чем
                                        precision.  Ведущие   нули
                                        отсекаются,  и  десятичная
                                        точка  появляется   тогда,
                                        когда  за ней следует одна
                                        или несколько цифр.

             G       с плавающей        идентично  формату "g", за
                     точкой             исключением    того,   что
                                        вместо     "e"    вводится

                                        экспонента "E"  (если  она
                                        необходима).

             c       символьный         отдельный символ.

             s       строковый          символы    печатаются   до
                                        первого  нулевого  символа
                                        '\o'   или  до  достижения
                                        precision.

             n       указатель на       число   символов   успешно
                     целый              записывается   в     поток
                                        stream;    это    значение
                                        хранится  в  целом,  адрес
                                        которого   выбирается  как
                                        аргумент.

             p       far-указатель      печать адреса, указываемо-
                                        го аргументом,  в    форме
                                        xxxx:yyyy,    где     xxxx
                                        является  сегментом,  yyyy
                                        является разветвлением,  а
                                        цифры   x   и  y  являются
                                        шестнадцатеричными цифрами
                                        верхнего  регистра (upper-
                                        case). %Np печатает только
                                        адрес  разветвления  yyyy.
                                        Поскольку  %p предполагает
                                        указатель на far-значение,
                                        аргументы      p-указателя
                                        могут быть сброшены к  far
                                        в    маленьких     моделях
                                        программ.



                                                      Таблица R.2.

                          Символы flags функции printf

            FLAG(*)        ЗНАЧЕНИЕ                  ПО УМОЛЧАНИЮ

              -      Смещение результата влево    Смещение  вправо
                     внутри поля wigth


              +      Присоединение   знака   к    Знак  "-"  появ-
                     выводимому значению, если    ляется    только
                     оно имеет знаковый тип       для  отрицатель-
                                                  ных     знаковых
                                                  значений

            blank    К выводимому значению при-   Без пробела
            (' ')    соединяется ' ', если  вы-
                     водимое значение  является

                     знаковым и  положительным;
                     флаг  "+"  override   флаг
                     blank,  если  оба  есть, и
                     положительное     знаковое
                     значение выводится  вместе
                     со знаком

            #        При использовании с форма-   Без префикса
                     тами o, x, X,  флаг # при-
                     соединяет к любому ненуле-
                     вому  выводимому значению,
                     соответственно, 0, 0х, 0Х

                     Когда флаг #  используется   Десятичная точ-
                     в  формате  e,  E,  f,  он   ка   появляется
                     определяет   наличие деся-   только   тогда,
                     тичной  точки в  выводимом   когда   за  ней
                     значении                     идут цифры

                     Когда флаг #  используется   Десятичная точ-
                     в формате g, G, он опреде-   ка   появляется
                     ляет  наличие   десятичной   только   тогда,
                     точки в выводимом значении   когда   за  ней
                     и  препятствует  отсечению   идут цифры
                     ведущих нулей                Ведущие    нули
                                                  отсекаются

                     Флаг  # игнорируется,  при
                     его использовании в форма-
                     тах c, d, i, u, s

               Примечание. В формате спецификации может содержаться более,
         чем один flag.

               Width  -  неотрицательное  десятичное целое, контролирующее
         минимальное число напечатанных символов. Если  число  символов  в
         значении  вывода  меньше, чем в width, слева и справа добавляются
         пробелы (в зависимости от того, где определен флаг "-"), пока ми-
         нимальная ширина не будет достигнута. Если к width присоединяется
         0, то 0 будут добавляться до тех пор, пока не будет достигнут ми-
         нимум width. (Это не применяется для чисел, смещенных влево).
               Спецификация width не требует отсечения значения; если чис-
         ло символов выводимого значения больше  чем определено  в  width,
         или  не задано в нем, все значения символов распечатываются (под-
         лежат спецификации precision).
               В спецификации width может быть звездочка (*), когда вместо
         значения подставляется соответствующий ему аргумент из списка ар-
         гументов. Аргумент width должен предшедствовать  соответствующему
         значению.
               Спецификация  precision является неотрицательным десятичным
         целым, которому предшедствует точка (.), определяющая  количество
         печатаемых символов  или же число десятичных мест.
               В  отличии  от  спецификации  width, спецификация precision
         требует отсечения выводимого значения или, в  случае  значения  с
         плавающей  точкой, его округления. В случае подстановки аргумента

         из списка аргументов  в спецификации precision может  быть  звез-
         дочка  (*).  В списке аргументов аргумент precision предшедствует
         форматируемому значению. Объяснение значений precision, в зависи-
         мости от типа type  и случая, когда precision  пропущено,  предс-
         тавлено в таблице R.3.

                                                      Таблица R.3.

               Как тип type влияет на значение precision в функции printf


            ТИП             ЗНАЧЕНИЕ                ПО УМОЛЧАНИЮ

             d     Precision         определяет   Если   precision
             i     минимальное число печатаемых   равна 0 или про-
             u     цифр.  Если  число  цифр   в   пущена, или если
             o     аргументе     меньше,    чем   появляется точка
             x     размер   precision,    слева   (.)  без  идущих
             X     перед   выводимым  значением   за ней цифр,  то
                   добавляются нули. Если число   precision  уста-
                   цифр  не  превосходит размер   навливается рав-
                   precision,    значение    не   ной 1
                   отсекается

             e     Precision  определяет  число   Precision     по
             E     цифр,    печатаемых    после   умолчанию  равна
             f     десятичной  точки. Последняя   6; если она рав-
                   печатаемая цифра округляется   на  0  или перед
                                                  ней   появляется
                                                  точка   (.)  без
                                                  следуемых за ней
                                                  цифр,      тогда
                                                  десятичная точка
                                                  не печатается

             g     Precision         определяет   Печатаются   все
             G     максимальное   число  важных   важные   (много-
                   (многозначных)    печатаемых   значные) цифры
                   символов

             c     Не    происходит    никакого   Печать символа
                   действия

             s     Precision определяет макси-    Печать символов,
                   мальное число печатаемых       пока  не  встре-
                   символов                       тится    нулевой
                   Символы,  превышающие размер   символ
                   precision, не печатаются


               Возвращаемое значение.

               Эта функция возвращает количество напечатанных символов.
               См.  также  fprintf,  scanf,  sprintf,  vfprintf,  vprintf,
         vsprintf.


               Пример:

            main ()

         /* форматирование и печать различных данных */

            {
            char ch = 'h', *string = "computer";
            int count = 234, *ptr, hex = 0x10, oct = 010, dec = 10;
            double fp = 251.7366;

            printf("%d  %+d  %06d  %X  %x  %o\n\n",
                  count, count, count, count, count, count);

            printf("1234567890123%n45678901234567890\n\n", &count);
            printf("Value of count should be 13; count = %d\n\n",
                   count);

            printf("%10c%5c\n\n", ch, ch);

            printf("%25s\n%25.4s\n\n", string, string);

            printf("%f  %.2f  %e  %E\n\n", fp, fp, fp, fp);

            printf("%i  %i  %i\n\n", hex, oct, dec);

            ptr = &count;
            printf("%Np  %p  %Fp\n",
                   ptr, (int far *) ptr, (int far *)ptr);
            }

            Тогда на выводе получится следующее:

            234  +234  000234   EA  ea  352

            123456789012345678901234567890


            Value of count should be 13; count = 13;
                h    h
                      computer
                               comp

            251.736600    251.74   2.517366e+002   2.517366E+002

            16  8  10

            127A  1328:127A   1328:127A.


            PUTC-PUTCHAR

            #include <stdio.h>


            int putc (c, stream);   записывает символ в поток stream
            int c;                  записываемый символ

            FILE *stream;           указатель на структуру FILE

            int putchar(c);         записывает символ в <stdout>
            int c;                  записываемый символ


               Описание.

               Процедура putc записывает отдельный символ  "с"  в  текущую
         позицию выходного потока stream. Процедура putchar идентична про-
         цедуре putc(c, stdout).

               Возвращаемое значение.

               Эти  обе  процедуры  возвращают записанный символ. В случае
         ошибки  возвращается значение EOF. Так  как  значение  EOF  может
         быть  воспринято  как  целая величина, поэтому для проверки места
         возникновения ошибки применяется функция ferror.
               См. также fputc, fputchar, getc, getchar.
               Замечание: Процедуры  putc  и  putchar  идентичны  fputc  и
         fputchar, но они являются макро, а не функциями.

               Пример:

            #include <stdio.h>

            FILE *stream;
            char buffer[81];
            int i, ch;
            .
            .
            .
         /* следующий оператор позволяет записать буфер в поток */

            for  (i = 0;  (i < 81)  &&  ((ch = putc(buffer[i],
                                               stream)) != EOF) ;)
                     ++i;

         /* Замечание: Поскольку  тело  утверждения  пусто,  операция
         записи происходит в выражении проверки. */


              PUTCH

            #include <conio.h>     требуется только для объявления
                                   функции

            void putch(c)
            int c;                 выводимый символ



               Описание.

               Функция putch записывает символ "c" прямо на консоль.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См.также cprintf, getch, getche.

               Пример:

            #include <conio.h>

          /* в следующем примере показано, как может быть определена функ-
         ция getche посредством использования функций putch и getch.*/

            int getche()
            {
                int ch;

                ch=getch();
                putch(ch);
                return(ch);
            }


               PUTENV

            #include <stdlib.h>              требуется только  для
                                             объявления функции

            int putenv(envstring);           объявление   строки
            char *envstring;                 окружения

               Описание.

               Функция putenv добавляет новые переменные окружения или мо-
         дифицирует значения существующих переменных окружения.
               Переменные окружения определяют окружение, в котором выпол-
         няется  процесс (например, поиск по умолчанию path для библиотек,
         линкуемых вместе с программой).
               Аргумент envstring должен быть указателем на строку в  сле-
         дующей форме:

               varname = string,

               где varname - имя добавляемой или модифицируемой переменной
         окружения  и  string - значение этой переменной. Если varname уже
         является  частью  окружения,  она  заменяет  существующую  строку
         string, иначе - к окружению добавляется новая строка string. Зна-
         чение  переменной может быть установлено пустым, если string пус-
         тая.
               Указатель на вход (запись) окружения  не  освобождается  до
         тех пор, пока вход (запись) окружения остается неизменным при ис-
         пользовании   или пока переменная окружения не будет указывать на
         освобожденное пространство. Аналогичная  проблема  может  возник-

         нуть, если передается указатель на локальную переменную для функ-
         ции putenv, а затем   происходит выход на функцию, в которой объ-
         явлена переменная.

               Возвращаемое значение.

               Функция  putenv  возвращает 0, если она успешно отработала.
         Возвращаемое значение -1 указывает на ошибку.
               См. также getenv.

               Замечание: Функции getenv и  putenv  используют  глобальную
         переменную  environ  для  доступа к таблице переменных окружения.
         Функция putenv может изменять значение environ, делая  недействи-
         тельным аргумент "envp" для функции "main".

               Пример:

            #include<stdlib.h>
            #include<stdio.h>
            #include<process.h>

               /* попытка изменения переменной окружения */

            if (putenv("PATH=a:\\bin;b:\\tmp") == -1)
            {   printf("putenv failed -- out of memory");
                exit(1);
            }



               PUTS

            #include <stdio.h>

            int puts (string);
            char *string;                    выводимая строка


               Описание.

               Эта  функция записывает выбранную строку string в стандарт-
         ный поток вывода stdout, заменяя в выходном потоке нулевой символ
         окончания строки ('\0') символом новой строки ('\n').

               Возвращаемое значение.

               Функция puts возвращает последний записанный символ,  кото-
         рым обычно является символ новой строки '\n'. Значение EOF свиде-
         тельствует об ошибке.
               См. также fputs, gets.

               Пример:

            #include <stdio.h>


            int result;

               /* следующий оператор позволяет записать подсказку "Вставь-
         те дискету с данными и нажмите любую клавишу" в stdout. */

            result = puts("Insert data disk and strike any key");.


               PUTW

            #include <stdio.h>

            int putw(binint, stream);
            int binint;              выводимое двоичное целое

            FILE *stream;            указатель на структуру FILE

               Описание.

               Функция putw записывает двоичное значение типа int в  теку-
         щую  позицию  потока stream. Эта функция не выравнивает единицы в
         потоке и не предполагает специального выравнивания.

               Возвращаемое значение.

               Функция putw возвращает записанное значение.  Значение  EOF
         свидетельствует  об  ошибке.  Поскольку EOF может быть воспринято
         также как целая величина, то для проверки ошибки может  быть  ис-
         пользована функция ferror.
               См. также getw.
               Замечание: Эта функция позволяет обеспечивать совместимость
         с предыдущими библиотеками. Нужно заметить, что при использовании
         данной  функции  могут  возникать проблемы переносимости из одной
         системы в другую систему, поскольку в них отличаются размеры  int
         и порядок расположения байтов в int.

               Пример:

            #include <stdio.h>
            #include <stdlib.h>

            FILE *stream;
            .
            .
            .

               /*  следующие  операторы  позволяют  записать слово в поток
         stream и проверить на наличие ошибки. */

            putw(0345, stream);

            if (ferror(stream))
            {     fprintf(stderr, "putw failed\n");
                  clearerr(stream);
            }



               QSORT

            #include <search.h>    требуется только для объявления
                                   функции

            void gsort(base,num, width, compare);
            char *base;
            unsigned num, width;
            int (*compare)();

               Описание.

               Функция qsort выполняет алгоритм быстрой сортировки,  чтобы
         отсортировать  массив  из  num элементов, каждый элемент размером
         width байт. Аргумент base является указателем  на  базу  массива,
         который  нужно  отсортировать.  Функция qsort перезаписывает этот
         массив с отсортированными элементами.
               Аргумент compare является указателем на процедуру,  постав-
         ляемую  пользователем,  которая сравнивает два элемента массива и
         возвращает значение, определяющее их отношение.
               Функция qsort может вызывать  процедуру  compare  один  или
         несколько  раз в процессе сортировки, передавая при каждом вызове
         указатели на два элемента массива.  Процедура  должна  сравнивать
         элементы, а затем возвращать одно из следующих значений:

            Значение                   Его смысл

            меньше 0           element 1 меньше element 2

               0               element 1 равен element 2

            больше 0           element 1 больше element 2


               Возвращаемое значение.

               Возвращаемого значения в случае ошибки нет.
               См.также bsearch, lsearch.

               Пример:

            #include <search.h>
            #include <string.h>
            #include <stdio.h>

            int compare ();
            /* должна быть объявлена как функция */

            main (argc, argv)
                int argc;
                char **argv;
                {
                .

                .
                .
               /*  следующий оператор сортирует аргументы командной строки
         в лексикографическом порядке: */

                qsort((char*)argv,argc,sizeof(char*),compare);
                for (i=0; i<argc; ++i)
                  printf("%s\n", argv[i]);
                .
                .
                .
                }

            int compare (arg1, arg2)
               char **arg1, **arg2;

               {
               return(strcmp(*arg1, *arg2));
               }


               RAND

            #include<stdlib.h>              требуется только   для
                                            объявления функции

            int rand;

               Описание.

               Функция rand возвращает псевдослучайное целое  в  интервале
         от 0 до 32767. Процедура srand может использоваться перед вызовом
         rand для установки начальной случайной точки.

               Возвращаемое значение.

               Функция rand возвращает псевдослучайное число.
               См. также srand.

               Пример:

            #include<stdlib.h>
            #include<stdio.h>

            int x;

         /* печатает 20 первых сгенерированных случайных чисел */

            for (x = 1; x <= 20; x++)
                printf("iteration %d, rand=%d\n", x, rand());.




               READ

            #include<io.h>        требуется только для объявления
                                  функции

            int read(handle, buffer,count)
            int handle;           handle-р,  ссылающийся на откры-
                                  тый файла
            char *buffer;         память для хранения данных
            unsigned int count;   максимальное количество байтов

               Описание.

               Функция read позволяет читать байты count из файла, связан-
         ного с handle, в буфер buffer. Операции чтения начинаются с теку-
         щей позиции указателя на файл, который соответствует данному фай-
         лу.  После выполнения операции чтения этот указатель устанавлива-
         ется на следующий непрочитанный символ.

               Возвращаемое значение.

               Функция read  возвращает  число  действительно  прочитанных
         байтов, которое может быть меньше, чем count. Возвращаемое значе-
         ние 0 указывает на попытку чтения конца файла, а 1 - свидетельст-
         вует  об ошибке; в этих случаях errno устанавливается в значение,
         которое описано ниже.

            Величина          Смысловое значение

            EBADF       заданный handle неверный, или файл не яв-
                        ляется открытым для чтения,  или же  файл
                        заблокирован (закрыт). (Версия MS DOS 3.0
                        и последующие).

               Если прочитано больше 32К (максимальный размер типа int) из
         файла, возвращаемое значение будет типа unsigned int  (см.пример,
         приведенный ниже). Однако максимальное число байтов, которое мож-
         но  прочитать из файла, равно 65534; поскольку 65534 (или OXFFFF)
         является неотличимым от -1, поэтому будет возвращена ошибка. Если
         файл открыт в текстовом режиме, возвращаемое  значение  может  не
         соответствовать числу действительно прочитанных байтов. Если тек-
         стовый  режим эффективен, каждая пара "ВК-ПС" заменяется символом
         ПС. Подсчитывается в возвращаемом значении только отдельный  сим-
         вол ПС. Эта замена не влияет на указатель файла.
               См.также creat, fread, open, write.

               Замечание: В MS DOS, когда файл открыт в текстовом  режиме,
         символ  трактуется  как  индикатор  конца файла. Если встречается
         CONTROLL-Z, чтение оканчивается и при следующем чтении  возвраща-
         ется  0  байтов.  Индикатор  конца  файла может воспрепятствовать
         очистке файла.

               Пример:

            #include <io.h>
            #include <stdio.h>
            #include <fcntl.h>


            char buffer [60000]

            main ()
             {
               int fh;
               unsigned int nbytes=60000, bytesread;

               if ((fn=open("c:/data/conf.dat",O_RDONLY))==-1) {
                      perror("open failed on input file");
                      exit (1);
                      }
               if ((bytesread=read(fh,buffer,nbytes))==-1)
                      perror("");
               else
                   printf("Read %u bytes from file\n",bytesread);
               .
               .
               .
               }


               REALLOC

            #include <malloc.h>    требуется только для объявления
                                   функции

            char *realloc(ptr,size);
            char *ptr;             указатель  на ранее захваченный
                                   блок памяти
            unsigned size;         новый размер в байтах

               Описание.

               Функция realloc изменяет размер  ранее  захваченного  блока
         памяти. Аргумент ptr указывает на начало блока. Аргумент size за-
         дает новый размер блока в байтах. Содержимое блока не изменяется.
         Аргумент  ptr  может указывать на блок, который должен быть осво-
         божден прежде,  чем  последуют  вызовы  calloc,  halloc,  malloc,
         realloc.

               Возвращаемое значение.

               Функция  realloc возвращает char-указатель на перезахвачен-
         ный блок памяти. Блок может быть передвинут, если его размеры из-
         менены, поэтому аргумент ptr для функции realloc  не  обязательно
         должен быть таким же, как и возвращаемое значение.
               Возвращается значение NULL, если памяти недостаточно, чтобы
         расширить  блок к заданному размеру. Если это происходит, то пер-
         воначальный блок освобождается.
               В памяти, на которую указывает возвращаемое  значение,  га-
         рантировано  выравнивание для хранения любого типа объекта. Чтобы
         получить указатель на тип, отличный от char, используется  преоб-
         разователь типа возвращаемого значения.
               См.также caloc, free, halloc, malloc.


               Пример:

            #include <malloc.h>
            #include <stdio.h>

            char *alloc;

            /*  выбирает  достаточно  большое  пространство для 50
            символов */

            alloc=malloc(50*sizeof(char));
            .
            .
            .

               /* перезахватывает блок, который содержит 100 символов */
            if (alloc != NULL)
               alloc=realoc(alloc,100*sizeof(char));


               REMOVE

            #include <io.h>     требуется  только  для  объявления
                                функции
            #include <stdio.h>  использует  либо  <io.h>,     либо
                                <stdio.h>

            int remove(pathname);
            char *pathname;     path-имя удаляемого файла

               Описание.

               Функция remove удаляет файл, определенный по pathname.

               Возвращаемое значение.

               Функция remove возвращает 0, если файл успешно удален. Воз-
         вращаемое значение -1 свидетельствует об ошибке  и errno устанав-
         ливается в одно из следующих значений.


               Значение                         Его смысл

         EACCES               path-имя определяет директорий или файл
                              только для чтения

         ENOENT               файл или path-имя не найдено

               См.также close, unlink.

               Пример:

            #include <io.h>
            #include <stdio.h>


            int result;

            result=remove("tmpfile");
            if (result == -1)
              perror("couldn't delete tmpfile");


               RENAME

            #include <io.h>    требуется  только  для   объявления
                               функции
            #include <stdio.h> использует   либо   <io.h>,    либо
                               <stdio.h>

            int rename (oldname,newname);
            char *oldname;      указатель на старое имя
            char *newname;      указатель на новое имя

               Описание.

               Функция rename переименовывает файл или директорий, опреде-
         ляемый по имени newname. Oldname должно задавать path-имя сущест-
         вующего  файла  или директория. Newname не определяет имя уже су-
         ществующего файла или директория. Функцию rename можно  использо-
         вать  для  перемещения  файла из одного директория в другой, если
         задать другое path-имя в аргументе newname. Однако, файлы не  мо-
         гут  быть  перемещены  с одного устройства на другое (например, с
         дисковода А на дисковод В). Директории  можно  переименовывать  и
         нельзя перемещать.

               Возвращаемое значение.

               Функция  rename возвращает 0, если она выполнена успешно. В
         случае ошибки возвращается ненулевое значение  и errno устанавли-
         вается в одно из следующих значений:


               Значение                          Его смысл

         EACCES               Файл  или  директорий,  заданный     по
                              newname, существует или не  может  быть
                              создан (неверный  path),   или  oldname
                              является    директорием   и     newname
                              определяет другой  path.


         ENOENT               Файл или path-имя, заданные по oldname,
                              не  найдены.

         EXDEV                Попытка  перемещения  файла  на  другое
                              устройство.


               См.также create, fopen, open.


               Замечание. Нужно заметить, что порядок аргументов в  rename
         для Microsoft C 4.0 противоположен порядку rename для ранних вер-
         сий.  Это  изменение  было  сделано  в соответствии со
         стандартом ANSI.

               Пример:

            #include <io.h>

            int result;

               /* следующий оператор изменяет имя файла "input" ** на  имя
         "data" */

            result = rename("input", "data");


               REWIND

            #include <stdio.h>

            void rewind(stream);

            FILE *stream;            указатель на структуру FILE.

               Описание.

               Функция rewind перемещает указатель на  файл,  связанный  с
         потоком stream, к началу файла. Вызов функции rewind эквивалентен
         вызову следующей функции:

            fseek(stream, OL, SEEK_SET);

               с учетом того, что в потоке rewind очищает ошибки и индика-
         торы  конца файла, а fseek этого не делает. Fseek возвращает зна-
         чение,которое определяет, успешно или нет  передвинут  указатель.
         Rewind не возвращает никакого значения.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См. также fseek, ftell.

               Пример:

            #include <stdio.h>

            FILE *stream;
            int data1, data2;
            .
            .
            .
            fprintf(stream, "%d  %d", data1, data2);
            /* располагает данные в файл */


            rewind(stream);
            /* читает файл данных */

            fscanf(stream, "%d", &data1);.


               RMDIR

            #include <direct.h>  требуется  только  для объявления
                                 функции

            int rmdir(pathname);
            char *pathname;      path-имя удаляемого директория

               Описание.

               Функция rmdir удаляет директорий, определяемый по pathname.
         Директорий  должен быть пустым и он не может быть текущим рабочим
         директорием или директорием корня.

               Возвращаемое значение.

               Функция rmdir возвращает значение 0, если директорий успеш-
         но удален. Возвращаемое значение -1 свидетельствует об ошибке   и
         errno устанавливается в одно из следующих значений:

               Значение                       Его смысл

         EACCES               Заданное path-имя не является  директо-
                              рием; или директорий не пуст,  или  ди-
                              ректорий является текущим рабочим   ди-
                              ректорием  или директорием корня.

         ENOENT               Path-имя не найдено


               См.также chdir, mkdir.

               Пример:

            #include <direct.h>

            int result1, result2;

               /*  следующие  операторы  удаляют два директория: ** один в
         корне, другой - в текущем рабочем ** директории */

            result1=rmdir("/data1");
            result2=rmdir("data2");


               RMTMP

            #include <stdio.h>


            int rmtmp;

               Описание.

               Функция  rmtmp используется для очистки всех временных фай-
         лов в текущем директории. Эта функция очищает  и  удаляет  только
         файлы, созданные при помощи tmpfile.
               Функция  rmtmp может использоваться в том же самом директо-
         рии, где создавались временные файлы.

               Возвращаемое значение.

               Эта функция возвращает количество очищенных и  уничтоженных
         временных файлов.
               См. также flushall, tmpfile, tmpnam.

               Пример:

            #include <stdio.h>

            main ()

                 {
                  int numdeleted;
                  .
                  .
                  .
                  if ((stream = tmpfile()) == NULL)
                     perror ("Couldn't open new temporary file");
                  .
                  .
                  .
                  numdeleted = rmtmp;
                  printf ("Number of files closed and deleted in\
                  current directory = %d\n", numdeleted);
                 }.



               SBRK

            #include <malloc.h>    требуется только для объявления
                                   функции

            char *sbrk(incr);
            int incr;              количество   добавляемых    или
                                   вычитаемых  байтов

               Описание.

               Функция sbrk переустанавливает значение разрыва для вызван-
         ного  процесса.  Значением  разрыва  является адрес первого байта
         захваченной памяти. Функция sbrk добавляет incr байты к  значению
         разрыва;  соответственно этому устанавливается размер захватывае-

         мой памяти.

               Замечание. Incr может быть отрицательным, тогда  количество
         захваченной памяти уменьшается на incr байтов.

               Возвращаемое значение.

               Функция sbrk возвращает старое значение разрыва. Возвращае-
         мое  значение  -1  указывает на ошибку  и errno устанавливается в
         ENOMEN, указывая, что осталось недостаточно памяти.
               См.также calloc, free, malloc, realloc.

               Замечание. В компактной, большой  и  huge-моделях  программ
         функция  sbrk отсутствует и возвращает значение -1. В больших мо-
         делях программ для захвата используется функция malloc.


               Пример:

            #include <malloc.h>
            #include <stdio.h>

            /* захватывает память в 100 байт */

            char *alloc;
            alloc=sbrk(100);
            .
            .
            .

            /* уменьшает захваченную память до 60 байт  */

            if (alloc != (char)-1)
                   sbrk(-40);


               SCANF

            #include <stdio.h>

            int scanf(format-string[[, argument...]]);
            char *format-string.       строка управления форматом.

               Описание.

               Функция scanf читает данные из стандартного потока stdin  в
         место, определяемое аргументами arguments. Каждый аргумент должен
         быть  указателем на значение с типом, который соответствует типу,
         заданному в строке формата. Строка формата управляет преобразава-
         ниями полей ввода. Эта строка может содержать следующее:

               "Пробельные" символы, т.е. символ пробела ' ', табуляции \t,
         новой строки '\n'. Для функции scanf символом пробела определяет-
         ся считывание, но без запоминания, всех вводимых последующих сим-
         волов пробела вплоть до первого символа, не являющегося пробелом.

         При  вводе один символ пробела в строке формата соответствует лю-
         бому числу, включая 0, или любой комбинации символов пробела.
               Любой символ управления, не являющийся пробелом и  символом
         знака  процента %. Тогда по этому символу для функции scanf опре-
         деляется считывание, но без запоминания соответствующих  символов
         управления. Если следующий символ в <stdin> не соответствует сим-
         волам управления, то scanf оканчивает свою работу.
               Спецификацию  формата, введенную со знаком %. В этом случае
         scanf читает и преобразовывает введенные символы к значениям  за-
         данного типа, причем значения определяются соответствующими аргу-
         ментами из списка аргументов.

               Строка формата читается слева направо. Символы вне специфи-
         кации формата предполагаются согласованными с последовательностью
         символов в потоке stdin; эти согласованные символы в stdin скани-
         руются,  но  не  запоминаются.  Если  символ в stdin противоречит
         строке формата, scanf оканчивает свою работу. Этот  конфликтующий
         символ остается в stdin, так как он не может быть прочитан. Когда
         встречается  первая  спецификация формата, тогда значение первого
         поля ввода преобразовывается в соответствии со спецификацией фор-
         мата и запоминается в месте, заданном первым аргументом. По  вто-
         рой  спецификации формата выполняется преобразование второго поля
         ввода и запоминание его по второму  аргументу;  и  так  до  конца
         строки формата.
               Поле  ввода ограничивается первым "пробельным" символом или
         первым символом, который не может  преобразоваться  по  заданному
         формату, или случаем достижения поля width, которое идет первым.
               Если для выбранной спецификации формата задано больше аргу-
         ментов, чем требуется, то лишние аргументы игнорируются.
               Спецификация формата имеет следующую форму.

               %<flags><wigth><.precision><{F:N:h:I}><type>.

               Каждое  поле в формате спецификаций является отдельным сим-
         волом или числом,  выражающим  отдельную  опцию  формата.  Символ
         type, появляющийся после последнего необязательного поля формата,
         определяет тип поля ввода как символьного, строкового или числен-
         ного.
               Простейший формат спецификации содержит только символ знака
         процента и символ типа (например, %S).
               Каждое поле спецификации формата описывается ниже.
               Если  за  знаком  процента  % следует символ, не являющийся
         символом управления форматом, то этот символ и идущие за ним сим-
         волы, вплоть до следующего знака %, трактуются как обычная после-
         довательность символов, т.е. последовательность,  которая  должна
         быть введена. Например, чтобы ввести символ знака %, используется
         комбинация %%.
               Звездочка  (*),  идущая  за  знаком %, подавляет назначение
         следующего поля ввода, задающегося как поле,  определяемое  типом
         type. Это поле сканируется, но не запоминается.
               Widht  является  положительным десятичным целым и управляет
         максимально возможным числом символов, считываемых из stdin. Пре-
         образовываются и запоминаются по соответствующему аргументу толь-
         ко те символы, которые не превышают width. Если в width  встреча-
         ются  "пробельные"  символы,  т.е. символы пробела, табуляции или

         новой строки, то по выбранному формату они не  преобразовываются,
         пока не будет достигнут размер width.
               Необязательные  префиксы  F  и  N  не учитывают принятое по
         умолчанию адресное соглашение используемых моделей памяти. F  мо-
         жет  быть префиксом к аргументу argument, указыващему на far-объ-
         ект; а N - на near-объект.
               Необязательный префикс l свидетельствует о том, что исполь-
         зуется версия long; а префикс h - указывает на использование вер-
         сии  short.  Соответствующий  argument  указывает  на  long   или
         double-объект  (при  помощи префикса l)  или на short-объект (при
         помощи префикса h). Модификаторы l и h могут использоваться вмес-
         те с типами символов d, i, o, x, u. Модификатор l также может ис-
         пользоваться с символами type e и f. Если определен любой  другой
         type, модификаторы l и h игнорируются.

               Символы type и их значения описаны в таблице R.4.

                                                        Таблица R.4

                           Типы символов функции scanf

            СИМВОЛ    ПРЕДПОЛАГАЕМЫЙ ТИП        ТИП АРГУМЕНТА
                           ВВОДА


              d       десятичный   целый     указатель на  int.

              D       десятичный   целый     указатель на  long.

              o       восьмеричный целый     указатель на  int.

              O       восьмеричный целый     указатель на  long.

              x       шестнадцатеричный      указатель на  int.
                      целый

              X       шестнадцатеричный      указатель на  long.
                      целый

              i       десятичный,  вось-     указатель на  int.
                      меричный или шест-
                      надцатеричный  це-
                      лый

              I       десятичный,  вось-     указатель на  long.
                      меричный или шест-
                      надцатеричный  це-
                      лый

              u       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          int.

              U       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          long.


              e       значение с  плава-     указатель на  float
              f       ющей  точкой,  со-
                      держащее  необяза-
                      тельный знак ("+",
                      "-"),   одну   или
                      больше  десятичную
                      цифру, обычно  со-
                      держащую  десятич-
                      ную точку и экспо-
                      ненту ("е", "Е"),
                      которая    записы-
                      вается за знаковым
                      целым   значением.

              c       символьный. Симво-     указатель на  char
                      лы пробела,  табу-
                      ляции   или  новой
                      строки, так  назы-
                      ваемые "пробельные
                      символы",  которые
                      обычно  пропускают-
                      ся,  при   задании
                      этого типа  считы-
                      ваются. Для считы-
                      вания   следующего
                      символа, не являю-
                      щегося   "пробель-
                      ным", используется
                      комбинация %1s.

              s       строковый.             указатель на символь-
                                             ный массив, достаточ-
                                             но большой для вводи-
                                             мого  поля  вместе с
                                             нулевым     символом
                                             окончания '\0',  по-
                                             являющимся автомати-
                                             чески.

              n       чтение  при  вводе     указатель на  int, в
                      из   stream    или     котором записывается
                      буфера  не  проис-     число  успешно  счи-
                      ходит.                 танных  символов  из
                                             потока  или  буфера,
                                             вплоть до  указанных
                                             в вызове scanf.

              p       значение в   форме     указатель   на  far-
                      xxxx : yyyy,   где     группу данных.
                      цифры x и y  явля-
                      ются  шестнадцате-
                      ричными    цифрами
                      верхнего регистра.



               При  чтении  строк, не ограниченных символами пробела, мно-
         жество символов в квадратных скобках [] должно заменяться строко-
         вым типом s. Соответствующее поле ввода читается вплоть до перво-
         го символа, не содержащегося в ограниченном квадратными  скобками
         множестве символов. Если в этом множестве первым символом являет-
         ся  caret  (^),  результат сохраняется: поле ввода считывается до
         первого символа, не входящего в это множество символов. Чтобы за-
         помнить строку без нулевого символа '\0', применяется  специфика-
         ция %nc, где n - десятичное целое. В этом случае символьный тип s
         определяет  аргумент,  который указывает на массив символов. Сле-
         дующие  n  символов считываются из входного потока в определенное
         местоположение  и нулевой символ не записывается.
               Функция scanf для каждого поля ввода  сканирует  символ  за
         символом.  Она может окончить чтение отдельного поля при достиже-
         нии символа пробела, если либо достигнуто поле width; либо следу-
         ющий вводимый символ не может быть преобразован по заданному фор-
         мату; либо следующий символ  конфликтует  с  соответствующим  ему
         символом  в  управляющей строке формата; либо же следующий символ
         отсутствует в выбранном множестве символов. Когда происходит  вы-
         нужденный  процесс  окончания считывания, то следующее поле ввода
         рассматривается с самого  первого  конфликтующего  символа.  Этот
         символ, если он один, рассматривается как непрочитанный, либо как
         первый  символ  следующего  поля  ввода, либо как первый символ в
         последующих операциях чтения потока stdin.

               Возвращаемое значение.

               Эта функция возвращает число успешно преобразованных и наз-
         наченных полей. В возвращаемом значении не содержится число  про-
         читанных   но  не назначенных полей. При попытке считывания конца
         файла возвращается значение EOF. Возвращаемое значение 0 указыва-
         ет, что нет назначенных полей.
               См.  также  fscanf,  printf,  sscanf,  vfprintf,   vprintf,
         vsprintf.

               Пример 1.

            #include <stdio.h>

            int i;
            float fp;
            char c, s[81];

            scanf("%d  %f  %c  %s", &i, &fp, &c, s);
            /* ввод различных данных */.

            Пример 2.

            #include <stdio.h>

            main ()          /* преобразование шестнадцатеричного
                             ** или  восьмеричного   целого     к
                             ** десятичному целому  */
            {
            int numassigned, val;


            pintf("Enter hexadecimal or octal #, or 00
                   to guit:\n");
            do
               {  printf("# = ");
                  numassigned = scanf("%i", &val);
                  printf("Decimal # = %i\n", nal);
               }
            while (val && numassigned);

               /*  конец  цикла,  если  значение  ввода равно 00, или если
         scanf не способна назначить поле */.

            }

               Тогда на выходе будет следующее.

            Enter hexadecimal or octal #, or 00 to guit:

            # = 0xf
            Decimal # = 15

            # = 0100

            Decimal # = 64

            # = 00

            Decimal # = 0.



               SEGREAD

            #include <dos.h>

            void segread (segregs);
            struct SREGS *segregs;    значения регистров сегмента

               Описание.

               Функция  segread  заполняет структуру, на которую указывает
         segregs, текущим содержимым регистров сегмента. Эта функция может
         использоваться вместе с функциями intdosx и int86, чтобы  восста-
         навливать значения регистров сегментов, используемых последними.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См.также intdosx, int86x, FP_SEG.

               Пример:

            #include <dos.h>


            struct SREGS segregs;
            unsigned int cs, ds, es, ss;

               /* следующие операторы задают  текущие  значения  регистров
         сегмента */

            segread(&segregs);
            cs=segregs.cs;
            ds=segregs.ds;
            es=segregs.es;
            ss=segregs.ss;



            SETBUF

            #include <stdio.h>

            void setbuf(stream, buffer);
            FILE *stream;        указатель на структуру FILE
            char *buffer;        буфер, размещаемый пользователем.

               Описание.

               Функция setbuf позволяет пользователю управлять буферизаци-
         ей  потока  stream.  Аргумент  stream может ссылаться на открытый
         файл. Если аргумент buffer является NULL, то stream не  буферизо-
         ванный;  если  поток буферизованный, то buffer может указывать на
         массив символов  размером BUFSIZ, где размер BUFSIZ  определен  в
         <stdio.h>. Пользователь может использовать буфер buffer для буфе-
         ризации  ввода/вывода  вместо  буфера,  размещаемого  системой по
         умолчанию для потока stream.
               Стандартные потоки stderr и stdaux по умолчанию являются не
         буферизованными, но при использовании функции setbuf   они  могут
         назначать буферы.

               Возвращаемое значение.

               У этой функции возвращаемого значения нет.
               См. также fflush, fopen, fclose.

               Пример:

            #include <stdio.h>

            char buf[BUFSIZ];
            FILE *stream1, stream2;

            stream1 = fopen("data1", "r");
            stream2 = fopen("data2", "w");

            setbuf(stream, buf);
         /* stream1 использует буфер, назначенный пользователем */
            setbuf(stream, NULL);
         /* stream2 является небуферизованным */.




               SETJMP

            #include<setjmp.h>

            int setjmp(env);
            jmp_buf env;                   переменная, в  которой
                                           хранится окружение.

               Описание.

               Функция  setjmp  сохраняет  состояние  стека, который может
         быть последовательно восстановлен посредством использования функ-
         ции longjmp.
               Функции setjmp и longjmp обеспечивают возможность  выполне-
         ния  нелокального  (nonlocal)  перехода и обычно используются для
         передачи управления к обработке ошибок  для восстановления кода в
         ранее вызванной процедуре (без  использования  обычного  вызова),
         для возврата условных обозначений. Вызов setjmp активизирует сох-
         ранение текущего состояния стека в env. Последующий вызов longjmp
         восстанавливает  сохраненное состояние и возвращает управление на
         указатель (точку входа), непосредственно следующий за  соответст-
         вующим вызовом setjmp. Когда вызывается функция longjmp, значения
         всех  переменных  (за исключением переменных регистра) становятся
         доступными для процедуры, которая принимает управление и содержит
         значения этих переменных. Значения переменных регистра непредска-
         зуемы.

               Возвращаемое значение.

               После сохранения состояния стека функция setjmp  возвращает
         значение 0. Если в результате вызова longjmp возвращается setjmp,
         тогда возвращается и значение value аргумента longjmp. Возвращае-
         мого значения в случае ошибки нет.
               См. также longjmp.

               Замечание. После выполнения longjmp значения переменных ре-
         гистра в процедуре, вызывающей setjmp, не могут быть восстановле-
         ны (возвращены) к собственным значениям.


               Пример:

            #include <stdio.h>
            #include <setjmp.h>

            jmp_buf mark;

            main()
                 {
                 if (setjmp(mark) != 0)

                 {   printf("longjmp has been called\n");

                     recover();
                     exit(1);
                  }
                 printf("setjmp has been called\n");
                 .
                 .
                 .
                 p();
                 .
                 .
                 .
                 }


                p()
                {

                int error = 0;
                .
                .
                .
                if (error != 0)
                   longjmp(mark, -1);
                .
                .
                .
                }

                recover()
                {

               /*  при  выходе из программы убедитесь, что файлы данных не
         будут запорчены */

                .
                .
                .
                }.




               SETMODE

            #include <fcntl.h>
            #include <io.h>    требуется только для объявления
                               функции

            int setmode(handle,mode);
            int handle;        файловый handle
            int mode;          новый режим преобразования

               Описание.

               Функция setmode устанавливает в mode  режим  преобразования

         файла, заданного по handle.
               Mode может быть одной из следующих констант.

         Manifest-константа                Ее значение

          O_TEXT           Устанавливается  текстовый  режим  пре-
                           образования. Комбинация "Возврат карет-
                           ки - Перевод строки"  преобразуется  на
                           входе к одному символу "Перевод строки"
                           (ПС). Символ ПС на выводе преобразуется
                           в комбинацию "Возврат каретки - Перевод
                           строки".

         O_BINARY          Устанавливается  двоичный  режим.   Все
                           вышеприведенные преобразования  не под-
                           держиваются.

               Функция  setmode обычно используется для модификации режима
         преобразования, устанавливаемого по умолчанию, для stdin, stdout,
         stderr, stdaux, stdprn, но может использоваться для любого файла.

               Возвращаемое значение.

               В случае верной установки функция setmode возвращает преды-
         дущий режим преобразования. Возвращаемое значение -1 указывает на
         ошибку  и errno устанавливается в одно из следующих значений:


          Значение                      Его смысл

          EBADF                Неверный файловый handle.

          EINVAL               Неверный аргумент mode. (Ни O_TEXT,  ни
                               O_BINARY).

               См.также create, fopen, open.


               Пример:

            #include <stdio.h>
            #include <fcntl.h>
            #include <io.h>

            int result;

               /* следующий оператор устанавливает stdin в режим  преобра-
         зования binary (первоначально он был text) */

            result = setmode(fileno(stdin), O_BINARY);




               SETVBUF


            #include <stdio.h>

            int setvbuf(stream, buf, type, size);

            FILE *stream;      указатель на структуру FILE
            char *buf;         буфер, назначенный пользователем.
            int type           тип буфера:
                                   _IONBF - нет буфера;
                                   _IOFBF - полная буферизация;
                                   _IOLBF - строковая буферизация.
            int size;          размер буфера.

               Описание.

               Функция  setvbuf позволяет пользователю управлять буфериза-
         цией и размером буфера для потока stream. Stream может  ссылаться
         на  открытый файл. Массив, на который указывает buf, используется
         как буфер, если он не является NULL, т.е. поток не является буфе-
         ризованным. Если поток буферизованный, используется тип,  опреде-
         ленный по type; этот тип может быть либо _IONBF, либо _IOFBF, ли-
         бо  _IOLBF. Если используется тип _IOFBF, размер буфера определя-
         ется по size; если используется тип _IOLBF или _IONBF, поток  яв-
         ляется небуферизованным, а size и buf игнорируются.

            ЗНАЧЕНИЕ ТИПА              ЕГО СМЫСЛ

            _IONBF             Буфер не используется, несмотря  на
                               присутствие size и buf

            _IOFBF             Полная буферизация, если buf не яв-
                               ляется  NULL;  поэтому  buf исполь-
                               зуется в качестве буфера, а  size -
                               его размера

            _IOLBF             Аналогично _IOFBF

               Истинное  значение  size  обычно больше 0, но меньше макси-
         мального целого размера.

               Возвращаемое значение.

               Эта функция возвращает ненулевое  значение,  если  тип  или
         размер буфера неправильно определен, и возвращает значение 0, ес-
         ли все определено верно.
               См. также setbuf, fflush, fopen, fclose.


               Пример:

            #include <stdio.h>

            char buf[1024];

            FILE *stream1, *stream2;


            main()

            {
            stream1 = fopen("data1", "r");
            stream2 = fopen("data2", "w");

               /*  Stream1  будет использовать буфер размером 1024 байта и
         назначенный пользователем, а stream2 является небуферизованным */

            if (setvbuf(stream1, buf, _IOFBF, sizeof(buf)) !=0)
                  printf("Incorrect type or size of buffer1\n");
            if (setvbuf(stream2, _IONBF, 0) != 0)
                  printf("Incorrect type or size of buffer2\n");
            }.


               SIGNAL

            #include <signal.h>

            int (*signal(sig, func)();
            int sig;                           значение сигнала
            int (*func)();                     выполняемая функция

               Описание.

               Функция signal позволяет выбрать  из  операционной  системы
         один  из трех способов обработки сигнала прерывания. Аргумент sig
         может быть одной из манифестных констант SIGINT или SIGFPE, опре-
         деленых в <signal.h>. Манифестная константа SIGINT  соответствует
         в  MS DOS сигналу прерывания INT 23H. SIGFPE соответствует преры-
         ваниям плавающей точки, которые не маскированы, такие  как  пере-
         полнение, деление на ноль, неверная операция. Аргумент func может
         быть одной из манифестных констант SIG_DFL или SIG_IGN (также оп-
         ределенных в <signal.h>), или адресом функции. При получении сиг-
         нала  прерывания  принимаемое действие зависит от значения func и
         является следующим:

         ЗНАЧЕНИЕ                           ЕГО СМЫСЛ

         SIG_IGN           Сигнал   прерывания  игнорируется.  Это
                           значение для SIGFPE не задается,   т.к.
                           состояние  процесса  с плавающей точкой
                           остается неопределенным.

         SIG_DFL           Вызванный процесс завершен;  управление
                           передается   на  уровень команд MS DOS.
                           Все файлы, открытые в процессе,  закры-
                           ваются, но буферы не обновляются.

         Адрес функции     Для сигналов SIGINT функции, на которую
                           указывает func,  передается    аргумент
                           SIGINT и она выполняется. Если  функция
                           завершается нормально, прерванный  про-
                           цесс возобновляет выполнение с команды,

                           следующей за той, в которой был получен
                           сигнал  прерывания.  Перед  выполнением
                           специфицированной функции значение func
                           устанавливается  в  SIG_DFL;  следующий
                           сигнал прерывания трактуется как и  для
                           SIG_DFL,  если  внешний  вызов  signal,
                           задающий другое значение прерывания, не
                           определен.  Это  позволяет пользователю
                           переустанавливать сигналы  в вызываемых
                           функциях, если необходимо. Для   SIGFPE
                           функциц,   на  которую  указывает func,
                           передаются два аргумента - SIGFPE и це-
                           лый подкод ошибки,  FPE-xxx-,  и  затем
                           она выполняется. (Смотрите include-файл
                           <float.h>   для   определения  подкодов
                           FPE-xxx.)     Значение     func      не
                           переустановится  до  тех  пор,  пока не
                           будет  получен  сигнал прерывания;  для
                           выхода  из  состояния  плавающей  точки
                           используется  setjmp  вместе  с longjmp
                           (см. пример  для функции_fprset).  Если
                           функция завершается нормально, прерван-
                           ный    процесс     возобновляется     в
                           неопределенном    состоянии   плавающей
                           точки.


               Возвращаемое значение.

               Функция signal возвращает предыдущее значение func. Возвра-
         щаемое значение -1 свидетельствует об ошибке и errno устанавлива-
         ется в EINVAL, определяя неверное значение sig.
               См.также abort, exit,  _exit,  _fpreset,  spawnl,  spawnle,
         spawnlp, spawnv, spawnve, spawnvp.

               Замечание: В тех child-процессах, которые созданы посредст-
         вом  вызова процедур exec или spawn, установленные сигналы преры-
         ваний не сохраняются. Эти сигналы в child-процессе переустанавли-
         ваются по умолчанию.

               Пример:

            #include <stdio.h>
            #include <signal.h>
            #include <stdlib.h>
            #include <process.h>
            int handler();

            main()
                  {
                  if(signal(SIGINT, handler)==(int(*)())-1) {
                      fprintf(stderr,"couldn't set SIGINT\n");
                      abort();
                      }
                      .

                      .
                      .
                  }

            int handler()
                  {
                  char ch;
                  printf("terminate processing? ");

                  scanf("%1c", &ch);
                  if (ch=='y' ::ch=='Y')
                        exit(0);
                  signal(SIGINT, handler);
                  }

               /* функция signal, вызванная здесь для  следующего  сигнала
         прерываний, посылает управление не в ОС, а к handler() */



               SIN-SINH

            #include <math.h>

            double sin(x);         вычисляет синус x
            double sinh(x);        вычисляет гиперболический синус
                                   x
            double x;              радиан

               Описание.

               Функции  sin и sinh вычисляют соответственно синус и гипер-
         болический синус x.

               Возвращаемое значение.

               Функция sin возвращает синус x. Если x  большой,  то  может
         возникнуть  частичная потеря значимости результата. В этом случае
         sin вырабатывает ошибку PLOSS, но сообщения не печатает.  Если  x
         настолько большой, что теряется общая значимость результата, тог-
         да  sin  печатает сообщение об ошибке TLOSS в stderr и возвращает
         0. В обоих случаях errno устанавливается в ERANGE.
               Функция sinh возвращает гиперболический синус x.  Если  ре-
         зультат большой, sinh возвращает значение HUGE (отрицательное или
         положительное, в зависимости от знака x)  и устанавливает
         errno в ERANGE.
               Обрaботкa  ошибок  может  быть модифицировaнa при изменении
         процедуры matherr.
               См.также acos, asin, atan, atan2, cos, cosh, tan, tanh.

               Пример:

            #include <math.h>

            double pi = 3.1415926535,x,y;


            x = pi/2;);
            y = sin(x);  /* y равен 1.0 */

            y = sinh(x); /* y равен 2.3 */



               SOPEN

            #include <fentl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <sharc.h>
            #include <io.h>        требуется только для объявления
                                   функции

            int sopen(pathname,oflag,shflag{,pmode]);
            char *pathname;        path-имя  файла
            int oflag;             тип разрешенных операций
            int shflag;            разрешенный тип разделения
            int pmode;             разрешенный тип доступа

               Описание.

               Функция sopen открывает файл,  заданный  по  path-имени,  и
         подготавливает его к последующему разделенному чтению или записи,
         что определяется значением oflag или shflag. Oflag является целым
         выражением,  состоящим из комбинации одной или нескольких следую-
         щих манифестных констант, объявленных в <fcntl.h>.  Когда  задана
         более  чем одна манифестная константа, тогда они объединяются при
         помощи оператора ИЛИ(:).

            OFLAG                          ЗНАЧЕНИЕ

            O_APPEND        Перед   каждой    операцией     записи
                            перемещает указатеь  на  файл  в конец
                            файла.

            O_CREAT         Новый файл создан и открыт для записи;
                            это  не  эффективно,  если  существует
                            файл, определяемый по path-имени.

            O_EXCL          Возвращается  значение  ошибки,   если
                            существует файл, определяемый по path-
                            имени. Используется вместе с O_CREATE.

            O_RDONLY        Файл  открыт  только  для чтения, если
                            задан этот флаг, также может быть  вы-
                            бран флаг O_RDWR или O_WRONLY.

            O_RDWR          Файл открыт одновременно для чтения  и
                            записи; если  задается  этот  флаг, то
                            может быть выбран флаг
                            O_RDONLY   или O_WRONLY.


            O_TRUNC         Существующий  файл  открыт  и усечен к
                            длине 0; этот файл должен иметь разре-
                            шение  на  запись.   Содержимое  файла
                            уничтожается.

            O_WRONLY        Файл  открыт  только  для чтения; если
                            задан этот  флаг,  должен  быть  задан
                            флаг O_RDONLY или O_RDWR.

            O_BINARY        Файл открыт в двоичном  (не транслиро-
                            ванном) режиме.  (См. описание  двоич-
                            ного режима у функции  fopen).

            O_TEXT          Файл открыт в текстовом (транслирован-
                            ном) режиме.   (См.  описание  тексто-
                            вого режима у функции fopen).

               Замечание:  O_TRUNC полностью уничтожает содержимое сущест-
         вующего файла, поэтому нужно внимательно использовать  эту  конс-
         танту.
               Аргумент  shflag является константным выражением, состоящим
         из следующих манифестных констант, объявленных в <share.h>.  Под-
         робно  информация  о режиме разделения приведена в
         руководстве по MS DOS.

            shflag                          Значение

           SH_COMPAT        устанавливается режим совместимости

           SH_DENYRW        доступ по чтению  и записи в файле  не
                            разрешен

           SH_DENYWR        доступ по записи в файле не разрешен

           SH_DENYRD        доступ по чтению в файле не разрешен

           SH_DENYNO        доступ по чтению и записи разрешен


               Аргумент pmode требуется  только  тогда,  когда  определена
         константа 0_CREAT. Если файл не существует, pmode также определя-
         ет  типы доступа для файла, которые устанавливаются во время пер-
         вого закрытия нового файла. В противном случае аргумент pmode иг-
         норируется. Аргумент pmode является целым выражением,  содержащим
         одну  или  больше манифестных констант S_IWRITE и S_IREAD, объяв-
         ленных в <sys\stat.h>. Когда задаются обе константы, они объединя-
         ются оператором ИЛИ(!). Значение аргумента pmode приведено ниже.

            КОНСТАНТА            ЕЕ СМЫСЛОВОЕ ЗНАЧЕНИЕ

            S_IWRITE             разрешает запись

            S_IREAD              разрешает чтение


            S_IREAD:S_IWRITE     разрешают чтение и запись

               Если запись не разрешена, файл предназначен только для чте-
         ния.  В MS DOS все файлы открыты для чтения, разрешение по записи
         не задается. Поэтому модели S_IWRITE и S_IREAD: S_IWRITE являются
         эквивалентными.
               Перед  установкой разрешения функция sopen прикладывает те-
         кущую маску файла к pmode (см. umask).

               Возвращаемое значение.

               Функция sopen возвращает handle-р на открытый файл. Возвра-
         щаемое значение -1 указывает на ошибку; errno  устанавливается  в
         одно из следующих значений:

            ЗНАЧЕНИЕ                ЕГО СМЫСЛ

            EACCES         Заданное path-имя является директорием
                           или сделана попытка  записать  в  файл,
                           открытый   только   для   чтения,   или
                           возникло нарушение в режиме разделения.
                           (Версии MS DOS 3.0 и старше).

            EINVAL         Командный файл SHARE.COM не инстоллиро-
                           ван.

            EEXIST         Флаги O_CREAT и O_EXCL  определены,  но
                           названный файл всегда существует.

            EMFILE         Другие handle-ры  файла  не   доступны,
                           т.к. много открытых файлов.

            ENOENT         Файл или path-имя не найдено.

               См.также close, create, fopen, open, umask.

               Замечание:  Функция sopen используется в версиях 3.0 MS DOS
         и старших. В ранних версиях MS DOS аргумент shflag игнорируется.
               Режимы разделения файлов работают неверно с буферизованными
         файлами, поэтому fdopen не используется для связи потока и файла,
         открытого к разделению или закрытию.

               Пример:

            #include <fcntl.h>
            #include<sys\types.h>
            #include<sys\stat.h>
            #include<share.h>
            #include<io.h>

            extern unsigned char _osmajor;
            int fh;


               /* Перед вызовом sopen используется переменная _osmajor для

         проверки номера версии MS DOS . */.

            if (_osmajor >=3)
               fh = sopen ("data", O_RDWR:O_BINARY, SH_DENYRW);

            else
               fh = open ("data", O_RDWR: O_BINARY);


               SPAWNL-SPAWNVPE

               #include <stdio.h>
               #include <process.h>

         int spawnl(modeflag,pathname,arg0,arg1...,argn,NULL);
         int spawnle(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
         int spawnlp(modeflag,pathname,arg0,arg1...,argn,NULL);
         int spawnlpe(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
         int spawnv(modeflag,pathname,argv);
         int spawnve(modeflag,pathname,argv,envp);
         int spawnvp(modeflag,pathname,argv);
         int spawnvpe(modeflag,pathname,argv,envp);

         int modeflag;               режим выполнения parent-процесса
         char *pathname;             path-имя выполняемого файла
         char *arg0,*arg1...,*argn;  список указателей на аргументы
         char *argv[];               массив указателей на аргументы
         char *envp[];               массив указателей на установлен-
                                     ное окружение

               Описание.

               Функции  spawn создают и выполняют новый child-процесс. Для
         загрузки и выполнения child-процесса должно быть доступно  доста-
         точно  памяти.  Аргумент modeflag определяет действия, выбираемые
         parent-процессом перед и на протяжении spawn. Следующие  значения
         modeflag объявлены в <process.h>

         Значение                        Его смысл

         P_WAIT               Приостанавливает  parent-процесс,  пока
                              не завершится child-процесс.

         P_NOWAIT             Продолжает  выполнение  parent-процесса,
                              параллельного с child-процессом.

         P_OVERLAY            Parent-процесс  перекрывается с  child-
                              процессом; parent-процесс  уничтожается
                              (то же действие, что и при вызовах exec)

               Могут  использоваться  только  значения modeflag, такие как
         P_WAIT и P_OVERLAY. Значение P_NOWAIT сохраняется  для  возможной
         будущей реализации. Если используется P_NOWAIT, возвращается зна-
         чение  ошибки. Аргумент pathname определяет файл, выполняемый как
         child-процесс. Pathname может определять полный path (из  корня),
         часть path (из текущего рабочего директория), или просто имя фай-
         ла.




               Если  pathname не имеет расширения для имени файла или если
         оно не заканчивается точкой (.), тогда функция spawn устанавлива-
         ет расширение .EXE. Если pathname имеет расширение, то  использу-
         ется  только  это расширение. Если pathname заканчивается точкой,
         spawn  осуществляет  поиск  pathname  без  расширения.  Процедуры
         execlp, execlpe, execvpe осуществляют поиск для pathname (исполь-
         зуя те же процедуры) в директориях, определенных переменной окру-
         жения PATH.
               Аргументы  для  нового  процесса передаются как аргументы в
         вызове spawn, задавая один или  более  указателей  на  символьные
         строки.  Эти  символьные  строки  образуют  список аргументов для
         child-процесса. Общая длина строк, образующих  список  аргументов
         для  нового процесса, не может превышать 128 байтов. Нулевой сим-
         вол окончания '\0'для каждой строки в эту длину не засчитывается,
         а символы пробела (автоматически вставляемые для аргументов)-зас-
         читываются.
               Указатели аргументов могут передаваться как отдельные аргу-
         менты (в execl, execle, execlp, execlpe) или как массив  указате-
         лей  (в execv, execve, execvp, execvpe). По крайней мере один ар-
         гумент - arg0 или argv[0] - может передаваться к  child-процессу.
         По  условию  этот  аргумент  является  копией аргумента pathname.
         (Другое значение ошибки не вырабатывается).  В  версиях  MS  DOS,
         ранних от 3.0, передаваемое значение arg0 или argv[0] не доступно
         для использования в child-процессе. Однако, для версий MS DOS 3.0
         и старше pathname доступно через arg0 или argv[0].
               Вызовы  execl,  execle, execlp, execlpe обычно используются
         тогда, когда количество  аргументов  известно  заранее.  Аргумент
         arg0 обычно является указателем на pathname. Аргументы от arg1 до
         argn  являются указателями на символьные строки, образующие новый
         список аргументов. NULL-указатель, идущий за аргументом argn, оп-
         ределяет конец списка аргументов.
               Вызовы execv, execve, execvp, execvpe  используются,  когда
         число  аргументов для нового процесса является переменным. Указа-
         тели на аргументы пересылаются как массив argv. Аргумент  argv[0]
         обычно  является  указателем на pathname. Аргументы от argv[1] до
         argv[n] являются указателями на символьные строки, образующие но-
         вый список аргументов. Аргумент argv[n+1] может быть  NULL-указа-
         телем для определения конца списка аргументов.
               Файлы,  открытые при вызове spawn, остаются открытыми в но-
         вом процессе. В вызовах execl, execlp, execv, execvp,  child-про-
         цесс наследует окружение parent-процесса. Вызовы execle, execlpe,
         execve,  execvpe  позволяют  пользователю  изменять окружение для
         child-процесса, передавая список установленного  окружения  через
         аргумент envp.
               Аргумент envp является массивом символьных указателей, каж-
         дый  элемент  которого  (исключая последний элемент) указывает на
         строку, заканчивающуюся нулем и определяющую  переменную  окруже-
         ния. Обычно эта строка имеет форму:
               NAME = value,
               где NAME - имя переменной окружения, value - значение стро-
         ки, в которой устанавливается эта переменная. (Заметим, что value
         не заключается в кавычки "..."). Последним элементом массива envp
         должен быть NULL.
               Child-процесс наследует установленное окружение parent-про-
         цесса, когда envp является NULL.



               Возвращаемое значение.

               Возвращаемое   значение   является   статусом   выхода   из
         child-процесса. Статус выхода равен 0, если процесс нормально за-
         вершен. Статус выхода устанавливается в ненулевое значение,  если
         child-процесс особым образом вызывает процедуру exit вместе с не-
         нулевым  аргументом.  Если статус не установлен, то положительный
         статус выхода указывает на непредвиденный выход из программы пос-
         редством abort или прерывания.
               Возвращаемое  значение   -1   свидетельствует   об   ошибке
         (child-процесс  не  стартовал), и errno устанавливается в одно из
         следующих значений:

         ЗНАЧЕНИЕ                         ЕГО СМЫСЛ

         E2BIG                Список аргументов  превышает  128  байт
                              или    простраство,    требуемое    для
                              информации окружения,  превышает 32К.

         EINVAL               Аргумент modeflag неверный.

         ENOENT               Файл или path-имя не найдено.

         ENOEXEC              Определенный файл не является выполимым
                              или имеет неверный формат.

         ENOMEN               Достаточная  память  не  доступна   для
                              выполнения child-процесса.

               Замечание! Вызовы spawn не сохраняют  режим  преобразования
         для открытых файлов. Если child-процесс использует файлы, унасле-
         дованные  от parent-процесса, тогда процедура setmode применяется
         для установки требуемого режима преобразования для этих файлов.
               В child-процессе, созданном вызовами процедур  spawn,  сиг-
         нальные  установки не сохраняются. В child-процессе они переуста-
         навливаются по умолчанию.

               Cм. также abort, execl,  execle,  execlp,  execlpe,  execv,
         execve, execvp, execvpe, exit, _exit, onexit, system.

               Пример.

               #include <stdio.h>
               #include <process.h>

               extern char **environ;

               char *args[4];
               int result;

               args[0]="child";
               args[1]="one";
               args[2]="two";

               args[3]=NULL;
               .
               .
               .
               /*  все  следующие  операторы  позволяют порождать процесс,
         названный "child.exe", и передавать ему три аргумента. Первые три
         аргумента приостанавливают parent-процесс, а последние три - свя-
         зывают parent-процесс с child */.

               result=spawnl(P_WAIT,"child.exe","child","one","two",
                   NULL);
               result=spawnle(P_WAIT,"child.exe","child","one",
                   "two", NULL, environ);
               result=spawnlp(P_WAIT, "child.exe","child","one",
                   "two", NULL);
               result=spawnv(P_OVERLAY, "child.exe", args);
               result=spawnve(P_OVERLAY, "child.exe", args, environ);
               result=spawnvp(P_OVERLAY, "child.exe", args);


               SPRINTF

               #include <stdio.h>

               int sprintf(buffer, format-string[, argument...]);
               char *buffer;              память для  хранения вывода
               char *format-string;       строка  управления форматом

               Описание.

               Функция sprintf форматирует и запоминает наборы символов  и
         значений  в buffer. Каждый аргумент argument (если он есть), пре-
         образуется и выводится согласно соответствующей спецификации фор-
         мата в format-string.
               Format-string состоит из порядковых символов и имеет ту  же
         самую  форму  и  функцию,  что аргумент format-string для функции
         printf. Смотрите функцию printf для описания format-string и  ар-
         гументов.

               Возвращаемое значение.

               Функция  sprintf возвращает количество символов, записанных
         в buffer.
               См. также fprintf, printf, sscanf.

               Пример.

               #include <stdio.h>

               char buffer[200];
               int i, j;
               double fp;
               char *s = "computer";
               char c;
               .

               .
               .

               /*  форматирует и печатает различные данные */

               j = sprintf(buffer, "%s\n", s);
               j + = sprintf(buffer+j, "%c\n", c);
               j + = sprintf(buffer+j, "%d\n",i);
               j + = sprintf(buffer+j, "%f\n",fp);.


               SQRT

               #include <math.h>

               double sqrt(x);
               double x;         неотрицательное значение с плавающей
                                 точкой

               Описание.

               Функция sqrt вычисляет квадратный корень x.

               Возвращаемое значение.

               Функция sqrt возвращает  результат  вычисления  квадратного
         корня.  Если  x  -  отрицательное,  функция печатает сообщение об
         ошибке DOMAIN в stderr, устанавливает errno в EDOM  и  возвращает
         0.
               Обрaботкa  ошибок  может  быть модифицировaнa при изменении
         процедуры matherr.
               См. также exp, log, matherr, pow.

               Пример.

               #include <math.h>
               #include <stdlib.h>
               double x,y,z;
                .
               .
               .
               if ((z = sqrt(x+y))==o.0)
               if((x+y) < 0.0)
                  perror("sqrt of a negative number");


               SRAND

               #include<stdlib.h>              требуется только   для
                                               объявления функции

               void srand(seed);
               unsigned seed;                  начальное   число  для
                                               генерации    случайных
                                               чисел.


               Описание.

               Функция srand устанавливает начальную точку  для  генерации
         множества  псевдослучайных  целых.  В качестве аргумента seed для
         переустановки генератора используется 1.  Любое  другое  значение
         seed устанавливает генератор в начальную случайную точку.
               Функция  rand  используется для поиска сгенерированных слу-
         чайных чисел.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См. также rand.


               Пример.

               #include <stdlib.h>
               #include <stdio.h>

               int x, ranvals [20];

               /* устанавливает генератор случайных чисел в начальное сос-
         тояние и сохраняет в массиве 20 первых сгенерированных  случайных
         чисел. */

               srand(17);
               for (x = 0; x < 20; ranvals[x++] = rand())
                         ;.


               SSCANF

               #include <stdio.h>

               int sscanf(buffer, format-string[, argument...]);
               char *buffer;               хранимые данные
               char *format-string;        строка управления форматом

               Описание.

               Функция  sscanf читает данные из buffer в расположение, за-
         даваемое arguments. Каждый argument должен быть указателем на пе-
         ременную такого типа, которая соответствует типу, определннному в
         format-string.
               Format-string интерпретирует поля ввода и имеет ту же самую
         форму и функцию, что аргумент format-string  для  функции  scanf.
         Смотрите функцию scanf для описания format-string.

               Возвращаемое значение.

               Функция  sscanf возвращает количество успешно преобразован-
         ных и назначенных полей. В возвращаемом  значении  не  содержатся
         прочитанные но не назначенные поля. Значение EOF возвращается при

         попытке считывания конца строки.Возвращаемое значение 0 означает,
         что нет назначенных полей.
               См. также fscanf, scanf, sprintf.

               Пример.

               #include <stdio.h>
               char *tokenstring = "15 12 14...";
               int i;
               float fp;
               char s[81];
               char c;
               .
                .
               .
               /* ввод различных данных */

               sscanf(tokenstring, "%s", s);
               sscanf(tokenstring, " %c", &c);
               sscanf(tokenstring, "%d", &i);
               sscanf(tokenstring, "%f", fp);.

               STACKAVAIL

               #include <malloc.h>    требуется только для объявления
                                      функции
               unsigned int stackavail();


               Описание.

               Функция  stackavail возвращает приблизительный размер стека
         в байтах, доступного для динамического размещения памяти посредс-
         твом функции alloca.

               Возвращаемое значение.

               Функция stackavail возвращает размер в байтах как беззнако-
         вое целое.
               См. также alloca, freect, memavl.

               Пример.

               #include <malloc.h>

               main()
               {
               char * ptr;

               printf("Stack memory available before alloca=%u\n",
                     stackavail());
               ptr=alloca(100*sizeof(char));
               printf("Stack memory available after alloca=%u\n",
                     stackavail());
               }



               STAT

               #include <sys\types.h>
               #include <sys\stat.h>

               int stat(pathname, buffer);
               char *pathname;       path-имя существующего файла
               struct stat *buffer;  указатель на строку, принимающую
                                     результаты

               Описание.

               Функция stat получает информацию о  файле  или  директории,
         определенном по pathname, и запоминает ее в структуре, на которую
         указывает  buffer.  Структура stat, объявленная в   <sys\stat.h>,
         содержит следующие поля.

               Поле                              Значение

               st_mode              Битовая  маска  для информации о режиме
                                    файла.  Бит   S_IFDIR  устанавливается,
                                    если  pathname  определяет  директорий;
                                    бит   S_IFREG   устанавливается,   если
                                    pathname  ссылается  на  обычный  файл.
                                    Биты   чтения/записи    устанавливаются
                                    пользователем в соответствии с  режимом
                                    доступа к файлу. Пользователь выполняет
                                    установку битов, используемых для  рас-
                                    ширения имени файла.

               st_dev               Номер   устройства  диска,  содержащего
                                    файл.

               st_rdev              Номер   устройства  диска,  содержащего
                                    файл.
                                    (аналогично st_dev).

               st_nlink             Всегда 1.

               st_size              Размер файла  в байтах.

               st_atime             Время последней модификации файла.

               st_mtime             Время последней модификации файла
                                    (аналогично st_atime).

               st_ctime             Время последней модификации файла
                                    (аналогично st_atime и st_mtime).


               В структуре типа stat существуют три  дополнительных  поля,
         которые для MS DOS не имеют смысла.


               Возвращаемое значение.

               Функция  stat возвращает значение 0, если получена информа-
         ция о статусе файла. Возвращаемое значение -1 свидетельствует  об
         ошибке,  и  errno  устанавливается  в  ENOENT, т.е. имя файла или
         path-имя не найдено.

               См. также access, fstat.

               Замечание. Если заданный pathname ссылается на  устройство,
         поля  размера  и  времени  в структуре stat не имеют осмысленного
         значения.

               Пример.

               #include <sys\types.h>
               #include <sys\stat.h>
               #include <stdio.h>

               struct stat buf;
               int result;
               char *args[4];
               .
               .
               .
               result = stat("child.exe", &buf);

               if (result == 0)
               if (buf.st_mode & S_IEXEC)
                  execv("child.exe", args);

               _STATUS87

               #include <float.h>

               unsigned int _status87();       получает слово статуса
                                               плавающей точки

               Описание.

               Функция _status87 получает слово статуса  плавающей  точки.
         Слово  статуса  плавающей  точки  является комбинацией 8087/80287
         слова  статуса  и  других  состояний,  обнаруживаемых  8087/80287
         handler-ом, таких как переполнение и потеря значимости стека пла-
         вающей точки.

                Возвращаемое значение.

               Биты  в  возвращаемом  значении обозначают статус плавающей
         точки. Смотрите include-файл <float.h> для полного  описания  би-
         тов, возвращаемых функций _status87.

               Замечание! Большинство из математических библиотечных функ-
         ций  модифицируют слово статуса 8087/80287 с непредсказуемыми ре-
         зультатами. Возвращаемые значения функций  _clear87  и  _status87

         становятся  более достоверными после выполнения нескольких опера-
         ций с плавающей точкой с  известными  сообщениями  слова  статуса
         плавающей точки.
               См. также _clear87, _control87.

               Пример.

               #include <stdio.h>
               #include <float.h>

               double a = 1e-40, b;
               float x,y;

               main()
               {
               printf("status=%.4x-clear\n",_status87());

               /*  запомненное в y является неточным и с потерянной значи-
         мостью */
               y = a;
               printf("status=%.4x-inexect,underflow\n",
                      _status87());

               /* y неверно */
               b = y;
               printf("status=%.4x-inexect,underflow,denormal\n",
                      _status87());

               /* очистка пользователем 8087 статуса */
               _clear87();
               }


               STRCAT-STRDUP

               #include<string.h>            требуется только для объявления
                                             функции

               char *strcat(string1,string2);
                                             добавляет string2 к string1
               char *string1;                строка-приемник
               char *string2;                строка-источник

               char *strchr(string,c);       находит первое вхождение
                                             c в string
               char *string;                 строка-источник
               int c;                        поисковый символ

               int strsmp(string1,string2);  сравнивает строки
               char *string1;
               char *string2;

               int strcmpi(string1,string2); сравнивает   строки  вне
                                             зависимости    от   типа
                                             регистра

               char *string1;
               char *string2;

               char strcpy(string1,string2); копирует    string2    в
                                             string1
               char *string1;                строка-приемник
               char *string2;                строка-источник

               int strcspn(string1,string2); находит первую подстроку
                                             символов  в  string1, не
                                             входящую в string2
               char *string1;                строка-источник
               char *string2;                множество символов

               char *strdup(string);         дублирует строку
               char *string;                 строка-источник

               int stricmp(string1,string2); сравнивает   строки  вне
                                             зависимости    от   типа
                                             регистра
               char *string1;
               char *string2;

               Описание.

               Функции strcat, strchr, strcmp,  strcmpi,  strcpy,  strspn,
         strdup,  stricmp  работают со строками, оканчивающимися '\0' симво-
         лом. Аргументы строк для этих функций предполагают наличие  нуле-
         вого символа ('\0'), отмечающего конец строки.
               При копировании или добавлении строк проверка на переполне-
         ние не выполняется.
               Функция strcat добавляет string2 к string1, заканчивает ре-
         зультирующую  строку  нулевым  символом и возвращает указатель на
         строку-приемник (string1).
               Функция strchr возвращет указатель на первое вхождение c  в
         string. Символ c может быть нулевым символом ('\0'); нулевой символ
         окончания string включается в поиск. Функция возвращает NULL, ес-
         ли символ не найден.
               Функция  strcmp лексикографически сравнивает строки string1
         и string2 и возвращает значение, обозначающее их соотношение так,
         как показано ниже.

               Значение                 Его смысл

               меньше 0           string 1 меньше string 2

               0                  string 1 равна string 2

               больше 0           string 1 больше string 2

               Функции strcmpi и stricmp являются  причинно-нечувствитель-
         ными версиями strcmp. Два аргумента string1 и string2 сравнивают-
         ся  вне  зависимости  от типа регистра; это обозначает, что формы
         букв верхнего и нижнего регистров рассматриваются эквивалентными.
               Функция strcpy копирует  string2  (включая  нулевой  символ

         окончания)  в  расположение,  которое  определяется по string1, и
         возвращает string1.
               Функция  strcspn  возвращает  индекс  первого   символа   в
         string1, который принадлежит множеству символов srting2. Это зна-
         чение  эквивалентно длине начальной подстроки строки string1, ко-
         торая содержит все символы, не входящие в строку string2. При по-
         иске нулевые символы окончания не рассматриваются.  Если  string1
         начинается  с  символа,  содержащегося  в строке string2, strcspn
         возвращает 0.
               Функция strdup захватывает память (с возвратом malloc)  для
         копирования  string  и  возвращает указатель на память, содежащую
         скопированную строку. Функция возвращает NULL, если память не мо-
         жет быть захвачена.

               Возвращаемые значения для этих функций описаны выше.
               См. также strncat,  strncmp,  strncpy,  ctrnic,p,  strrchr,
         strspn.

               Пример.

               #include <string.h>

               char string[100], template[100], *result;
               int numresult;
               .
               .
               .
               /*  создает строку "computer program" посредством использо-
         вания strcpy и strcat */
               strcpy(string, "computer");
               result = strcat(string," program");
               /* находит строку, в которой первый раз обнаружено 'a' */
               result = strchr(string,'a');
               /* определяет, является ли строка больше, меньше или равной
         другой */
               numresult = strcmp(string, template);
               /* сравнивает две строки вне зависимости от  типа  регистра
         */
               numresult = strcmpi("hello", "HELLO");
               /* создает копию строки */
               result = strcpy(template,string);
               /* находит "a","b","c" в строке */
               strcpy(string,"xyzabbc");
               result = strcspn(string,"abc");
               /* создает новый указатель на строку для дублирования стро-
         ки */
               result = strdup(string);

               STRERROR

               #include <string.h>    требуется только для объявления
                                      функции

               char *strerror(string);
               char *string;           сообщение,        поставляемое

                                       пользователем

               int errno;              счетчик ошибок
               int sys_nerr;           счетчик сообщений системы
               char sys_errlist[sys_nerr];
                                       массив сообщений об ошибках

               Описание.

               Если  string равна NULL, функция strerror возвращает указа-
         тель на строку, содержащую системное сообщение об ошибке для пос-
         леднего библиотечного вызова, в котором  выработана  ошибка;  эта
         строка оканчивается символом новой строки ('\n').
               Если string не равна NULL, strerror возвращает указатель на
         строку,  содержащую сообщение об ошибке, поставляемое пользовате-
         лем; двоеточие; пробел; системное сообщение об ошибке для послед-
         него библиотечного вызова, выработавшего ошибку; и  символ  новой
         строки ('\n'). Сообщение пользователя может иметь максимальную дли-
         ну до 94 байта.
               В  отличии  от perror, strerror не печатает никаких сообще-
         ний. Для печати сообщения,  возращаемого  strerror  в  stderr,  в
         программе должен быть оператор printf, например:
               if((access("datafile",2))++-1)
                printf(strerror(NULL));

               Номер ошибки хранится в переменной errno, которая объявлена
         на  внешнем уровне. Системные сообщения об ошибках доступны через
         переменную sys_errlist, которая является массивом  сообщений  для
         ошибок  из  счетчика  ошибок. По функции strerror посредством ис-
         пользования значения errno как индекса к sys_errlist можно  уста-
         новить  приблизительные сообщения об ошибках. Значение переменной
         sys_nerr определяется как максимальное число элементов в  массиве
         sys_errlist.
               Чтобы  выработать  правильный  результат,  функция strerror
         должна быть вызвана сразу после библиотечной процедуры, возвраща-
         ющей ошибку. Иначе значение errno  может  быть  перезаписано  для
         последующих вызовов.

               Возвращаемое значение.

               Функция strerror не возвращает никакого значения.
               См. также clearerr, ferror, perror.


               Замечание. В MS DOS некоторые значения errno, приведенные в
         <errno.h>,  не используются. См. приложение А "Сообщения об ошиб-
         ках", где приведен список значений errno и соответствующие  сооб-
         щения  об ошибках, которые применяются в MS DOS . Для любого зна-
         чения errno, не используемого в MS DOS, функция strerror печатает
         пустую строку.

               Пример.

               #include <fcntl.h>
               #include <sys\types.h>

               #include <sys\stat.h>
               #include <io.h>
               #include <stdlib.h>

               int fh1, fh2;

               fh1 = open("data1", O_RDONLY);
               if (fh1==-1)
                   strerror("open failed on input file");

               fh2 = open("data2", O_WRONLY : O_CREAT,
                              S_IREAD : S_IWRITE);
               if (fh2==-1)
                   srterror("open failed on output file");

               STRLEN

               #include <string.h>    требуется только для объявления
                                      функции

               int strlen(string);
               char *string;          строка, заканчивающаяся нулевым
                                      символом

               Описание.

               Функция strlen возвращает в  байтах  длину  строки  string,
         причем нулевой символ окончания ('\0') в длину не засчитывается.

               Возвращаемое значение.

               Функция  возвращает  длину string. Возвращаемого значения в
         случае возврата нет.

               Пример.

               #include <string.h>

               char *string="some space";
               int result;
               .
               .
               .
               /* определяет длину строки */
               result=strlen(string);  /* result = 10 */


               STRLWR

               #include <string.h>    требуется только для объявления
                                      функции

               char strlwr(string);
               char *string;          преобразуемая строка


               Описание.

               Функция strlwr преобразовывает любые буквы верхнего регист-
         ра из заданной строки string, заканчивающейся нулевым символом, в
         буквы нижнего регистра. Другие символы не рассматриваются.

               Возвращаемое значение.

               Функция strlwr возвращает указатель на преобразуемую строку
         string. Возвращаемого значения в случае ошибки нет.
               См. также strupr.

               Пример.

               #include <string.h>

               char string[100], *copy;
               .
               .
               .
               /* создает копию строки в символах нижнего регистра */

               copy=strlwr(strdup(string));



               STRNCAT-STRNSET

               #include<string.h>     требуется только для объявления
                                      функции

               char *strncat(string1,string2,n);
                                      добавляет n символов  string2 к
                                      string1
               char *string1;         строка-приемник
               char *string2;         строка-источник
               unsigned int n;        количество добавляемых символов

               char *strncmp(string1,string2,n);
                                      сравнивает  первые  n  символов
                                      строк
               char *string1;
               char string2;
               unsigned int n;        количество  сравниваемых симво-
                                      лов

               int strnicmp(string1,string2,n);
                                      сравнивает  первые  n  символов
                                      строки

               char *string1;
               char string2;
               unsigned int n;        количество сравниваемых  симво-
                                      лов



               char *strncpy(string1,string2,n);
                                      копирует n символов  string2  в
                                      string1
               char *string1;         строка-приемник
               char *string2;         строка-источник
               unsigned int n;        количество добавляемых символов

               char *strnset(string,c,n,);
                                      инициализирует  n первых симво-
                                      лов строки string
               char *string;          инициализируемая строка
               int c;                 символ-приемник
               unsigned int n;        количество принимаемых символов


               Описание.

               Функции strncat, strnsmp, stricmp, strncpy, strnset работа-
         ют с первыми n символами строк, оканчивающимися нулевым символом.
               Функция  strncat добавляет n первых символов строки string2
         к строке string1, заканчивает результирующую строку нулевым  сим-
         волом ('\0') и возвращает указатель на строку-приемник (string1).
         Если n больше, чем длина строки string2, тогда вместо n использу-
         ется длина строки.
               Функция strncmp лексикографически сравнивает первые n  сим-
         волов строк string1 и string2 и возвращает значение, которое ука-
         зывает на отношение между подстроками, как приведено ниже:

               Значение                 Его смысл

               меньше 0           substring 1 меньше substring 2

               0                  substring 1 равна substring 2

               больше 0           substring 1 больше substring 2

               Функция  stricmp является причинно-нечувствительной версией
         strncmp; функция stricmp сравнивает две строки string1 и  string2
         вне  зависимости от чувствительности к регистрам; это обозначает,
         что формы букв верхнего и нижнего регистров  рассматриваются  как
         эквивалентные.
               Функция  strncpy копирует точно n символов строки string2 к
         строке string1 и возвращает string1. Если  n  меньше,  чем  длина
         string2, нулевой символ окончания ('\0') автоматически не добавля-
         ется к копируемой строке. Если n больше, чем длина  string2,  ре-
         зультат  string1 заполняется нулевыми символами, вплоть до дости-
         жения длины n.
               Функция strnset устанавливает первые n  символов  string  в
         символ  c  и  возвращает  указатель  на измененную строку. Если n
         больше, чем длина строки  string,  вместо  n  используется  длина
         string.
               См. также  strcat, strcmp, strcpy, strset.


               Пример.

               #include <string.h>

               char string[30]={"12345678901234567890"};

               main()
               {
               char copy[100], suffix[100], *result;
               int numresult;
               unsigned int nresult;
               .
               .
               .
               /*  комбинирует  строку  со строкой suffix, не более чем 10
         символов (30 минус длина начальной строки). (Если в  примере  ис-
         пользуется  более 10 символов, в память будет записано любое дру-
         гое значение) */

               result = strncat(string,suffix,10);

               /* определяет порядок слов в строке, которая  содержится  в
         "program",  но рассматривает не более 7 символов. Если строка со-
         держит префикс "program", strncmp возвращает 0 */

               strcpy(string,"programmer");
               numresult = strncmp(string,"program",7);

               /* сравнивает 4 символа двух строк вне зависимости от  типа
         регистра */

               strcpy(string,"PROGRESS");
               nresult = stricmp(string,"program",4);

               /* копирует 99 символов строки */

               result = strncpy(copy,string,99);

               /* устанавливает первые 4 символа строки в символ 'x' */

               result = strnset("computer",'x',4);
               }


               STRPBRK

               #include<string.h>     требуется только для объявления
                                      функции

               char *strpbrk(string1,string2);
                                      находит любой символ из string2
                                      в string1
               char *string1;         строка-источник
               char *string2;         множество символов


               Описание.

               Функция  strpbrk  находит первое вхождение в string1 любого
         символа из string2. Нулевой символ окончания при поиске не  расс-
         матривается.

               Возвращаемое значение.

               Функция  strpbrk  возвращает  указатель на первое вхождение
         символа из string2 в string1.
               NULL-указатель  определяет  отсутствие  общих  символов   в
         string1 и в string2.
               См. также strchr, strrchr.

               Пример.

               #include <string.h>

               char string[10], *result;
               .
               .
               .
               /*  возвращает  указатель на первое вхождение в строке либо
         'a,' либо 'b' */

               result = strpbrk(string,"ab");

               STRRCHR

               #include<string.h>     требуется только для объявления
                                      функции

               char *strrchr(string,c);
                                      находит последнее вхождение c в
                                      string
               char *string;          строка-источник
               int c;                 символ поиска

               Описание.

               Функция strrchr находит последнее  вхождение  символа  c  в
         строке  string. Нулевой символ окончания ('\0') строки string вклю-
         чается в поиск. (Используется strchr для поиска первого вхождения
         c в строке string).

               Возвращаемое значение.

               Функция strrchr возвращает указатель на последнее вхождение
         c в string. Указатель NULL возвращается, если заданный символ  не
         найден.
               См. также strchr, strpbrk.

               Пример.

               #include <string.h>


               char string[100], *result;
               .
               .
               .
               /* находит последнее вхождение символа 'a' в строке */
               result = strrchr(string,'a');.

               STRREV

               #include<string.h>     требуется только для объявления
                                      функции

               char *strrev(string);
               char *string;          сохраняемая строка

               Описание.

               Функция strrev сохраняет порядок символов в заданной строке
         string. Нулевой символ окончания ('\0') остается на месте.

               Возвращаемое значение.

               Функция  strrev  возвращает указатель на измененную string.
         Возвращаемого значения в случае ошибки нет.
               См. также strcpy, strset.

               Пример.

               #include <string.h>

               char string[100];
               int result;
               .
               .
               .
               /* определяет, является ли строка палиндромом, т.е. читает-
         ся одинаково в прямом и обратном порядке */
               result = strcmp(string,strrev(strdup(string)));
               /* если result == 0, строка является палиндромом */


               STRSET

               #include<string.h>     требуется только для объявления
                                      функции

               char *strset(string,c);
               char *string;          устанавливаемая строка
               int c;                 символ-приемник


               Описание.

               Функция strset устанавливает в c все  символы  из  заданной
         строки string, исключая нулевой символ окончания ('\0').


               Возвращаемое значение.

               Функция  strset  возвращает указатель на измененную строку.
         Возвращаемого значения нет.
               См. также strnset.

               Пример.

               #include <string.h>

               char string[100], *result;
               .
               .
               .
               /* устанавливает строку, состоящую из пробелов */
               result = strset(string, ' ');


               STRSPN

               #include<string.h>     требуется только для объявления
                                      функции

               int strspn(string1,string2);
               char *string1;         поисковая строка
               char *string2;         множество символов

               Описание.

               Функция strspn возвращает индекс первого символа  в  строке
         string1,  который  не принадлежит множеству символов string2. Это
         значение эквивалентно длине начальной подстроки в строке string1,
         которая полностью состоит из  символов  строки  string2.  Нулевой
         символ  окончания строки string2 не рассматривается. Если string1
         начинается с символа, не входящего в string2,  strcpn  возвращает
         0.

               Возвращаемое значение.

               Функция  strspn возвращает целое значение, определяющее по-
         зицию первого символа в string1, и не содержащегося в string2.
               См. также strcspn.

               Пример.

               #include <string.h>

               char *string="cabbadge";
               int result;
               .
               .
               .
               /* определяет длину префикса, содержащего a,b и c */
               result = strspn(string,"abc"); /* result = 5 */


               STRSTR


               #include<string.h>     требуется только для объявления
                                      функции

               char *strstr(srting1,string2);
               char *string1;         поисковая строка
               char *string2;         строка-шаблон

               Описание.

               Функция strstr возвращает  указатель  на  первое  вхождение
         string1 в string2.

               Возвращаемое значение.

               Функция   strstr  возвращает  указатель  на  string1,  если
         string1 обнаружена, и NULL - если string1 нет.
               См. также strcspn.

               Пример.

               #include <string.h>

               main()
                 {
                 char *string1="needle in a haystack";
                 char *string2="hay";

                 printf("%s\n", strstr(string1,string2));
                 }

               На выходе:
               haystack

               STRTOD-STRTOL

                #include <stdlib.h>

                double strtod(nptr, endptr);  преобразует  строку,
                                              на которую указывает
                                              nptr, в double

                char *nptr;                   указатель  на строку
                char **endptr;                указатель  на  конец
                                              просмотра

                long strol(nptr,endptr,base); преобразует строку в
                                              long  десятичное це-
                                              лое,   эквивалентное
                                              числу с данным осно-
                                              ванием base
                char *nptr;

                char **endptr;
                int  base;                    используемое основа-
                                              ние


               Описание.

               Функции strtod и strtol соответственно преобразуют символь-
         ную строку к значению с двойной точностью или к  длинному  целому
         значению.  Исходная  строка  string представляет собой последова-
         тельность символов, которые интерпретируются как числовое  значе-
         ние  специального  типа. Эти функции прекращают чтение строки как
         только встретится символ, который не может быть частью числа (это
         может быть нулевой символ '\0 в конце строки); для strtol символом
         прерывания может быть также первый цифровой символ, который боль-
         ше или равен base. Если endptr - не NULL,  *endptr  указывает  на
         тот символ, на котором останавливается просмотр.
               Функция  strtod предполагает, что nptr указывает на строку,
         имеющую следующую форму:

         [whitespace][sign][digiits][.digits][{d:D:e:E}[sign]digits]

               При появлении первого символа, не отвечающего  этой  форме,
         обработка прекращается.
               Функция  strtol  предполагает, что nptr указывает на строку
         следующей структуры:

               [whitespace][sign][0][x][digits]

               Если base лежит между 2 и 36, это значение используется как
         основание системы счисления данного числа.
               Если base = 0, начальные символы строки, на которые  указы-
         вает  nptr,  используются  для определения основания. Если первый
         символ - 0 и второй - одна из цифр от 1 до 7, то строка интерпре-
         тируется как восьмеричное целое; если первый символ 0, а второй x
         или X, тогда строка понимается как шестнадцатеричное целое;  если
         первый символ принадлежит последовательности 1-9, то строка пони-
         мается как десятичное целое.

               Возвращаемое значение.

               Функция  strtod  возвращает значение числа с плавающей точ-
         кой, исключая случаи переполнения или потери результата (т.е. аб-
         солютное значение результата меньше, чем это допустимо диапазоном
         представления числа). В случае переполнения или потери значимости
         результата возвращается соответственно +HUGE или -HUGE.
               Функция strtol возвращает значение преобразованной  строки,
         исключая случай переполнения или потери результата. В этом случае
         возвращается  соответственно  LONG_MAX  или LONG_MIN. Обе функции
         устанавливают errno в ERANGE.
               См. также atof, atol.

               Пример.

                #include <stdlib.h>


                main()
                 {
                 char *string, *stopstring;
                 double x;
                 long l;
                 int bs;

                 string="3.1415926This stopped it";
                 x=strtod (string, &stopstring);
                 printf ("string=%s\n",string);
                 printf (    strtod=%ld (base %d)\n", l, bs);
                 printf ("   Stopped scan at %s\n\n", stopstring);
                 string="10110134932";
                 printf ("string=%s\n", string);
                 for (bs=2; bs<=8; bs*=2)  {
                 l=strtol(string, &stopstring, bs);
                 printf (" strtol=%ld (base %d)\n",l,bs);
                 printf (" Stopped scan at %s\n\n",stopstring);
                  }
                }

               На выходе:

               string = 3.1415926This stopped it
                 strtod = 3.141593
                 Stopped scan at This stopped it

               string = 10110134932
                 strtol = 45 (base 2)


                 Stopped scan at 34932

                 strtol = 4423 (base 4)
                 Stopped scan at 4932

                 strtol = 2134108 (base 8)
                 Stopped scan at 932

               STRTOK

               #include<string.h>    требуется  только для объявления
                                     функции

               char *strtor(string1,string2);
                                     находит символ в string1
               char *string1;        строка, содержащая символы
               char *string2;        множество символов-ограничителей

               Описание.

               Функция strtok читает строку string1 как множество нуль или
         более знаков, служащих в качестве ограничителей  для  символов  в
         string1. Символы в string1 могут отделяться одним или более огра-

         ничителем  от string2. Символы в string1 разрываются столько раз,
         сколько вызывается strtok. При первом вызове strtok для  заданной
         строки string1, strtok находит первый символ в string1, пропуская
         предыдущие  ограничители.  Указатель возвращается на первый знак.
         Для того, чтобы прочитать следующий символ  из  string1,  функция
         strtok  вызывается вместе с NULL значением для аргумента string1.
         Аргумент NULL строки string1 вызывает strtok для поиска следующе-
         го знака в предыдущей строке  символов.  Множество  ограничителей
         может  быть  различным  от вызова к вызову, так как string2 может
         принимать любые значения.
               Замечание. String1 можно  модифицировать  вызовами  strtok,
         так  как после вызова strtok в string1 вставляется нулевое значе-
         ние ('\0').

               Возвращаемое значение.

               При вызове strtok первый раз, она возвращает  указатель  на
         первый  символ в string1. При последующих вызовах в этой же самой
         строке символов, strtok возвращает указатель на следующий  символ
         в строке. Указатель NULL возвращается, когда нет больше символов.
         Все символы оканчиваются нулем.
               См. также strcspn, strspn.

               Пример.

               #include <string.h>
               #include <stdio.h>

               char *string = "a string, of , ,tokens";
               .
               .
               .
               /*  в следующем цикле собираются символы (отделенные пробе-
         лами или запятыми) из строки до тех пор, пока в ней ничего не ос-
         танется */
               token = strtok(string,",");

               while  (token  !=NULL)   {
               /* вставляет код для обработки символа в цикле */
                      .
                      .
                      .
               token = strtok(NULL,",");
               /* берет следующий символ */
                    }

               /* возвращаемыми  символами  являются  "a","string",  "of",
         "tokens". Следующий вызов strtok возвратит NULL и цикл завершает-
         ся */


               STRUPR

               #include<string.h>     требуется только для объявления
                                      функции


               char *strupr(string);
               char *string;          строка,       преобразуемая   к
                                      верхнему  регистру

               Описание.

               Функция  strupr преобразует любые буквы нижнего регистра из
         заданной string к буквам верхнего  регистра.  Другие  символы  не
         рассматриваются.

               Возвращаемое значение.

               Функция strupr возвращает указатель на преобразуемую строку
         string. Возвращаемого значения в случае ошибки нет.
               См. также strlwr.

               Пример.

               #include<string.h>

               char string[100], *copy;
               .
               .
               .
               /* следующий оператор делает копию строки в верхнем регист-
         ре */
               copy = strupr(strdup(string));


               SWAB

            #include <stdlib.h>             требуется  только  для
                                            объявления функции

            void swab(source, destination, n);
            char *source;                   копируемые и перестав-
                                            ляемые  (обмениваемые)
                                            данные
            char *destination;              хранение  переставлен-
                                            ных данных
            int n;                          число       копируемых
                                            байтов

               Описание.

               Функция swab копирует n байтов из source, переставляет (об-
         менивает)  каждую  пару  смежных  байтов  и  хранит  результат  в
         destination. Целые n могут быть одинаковыми числами,  подлежащими
         перестановке (обмену).
               Функция  swab  обычно  используется для подготовки двоичных
         данных при пересылке их к вычислительной машине, которая  исполь-
         зует различный порядок байтов.

               Возвращаемое значение.

               Возвращаемого значения нет.
               См. также fgets, fputs.



               Пример:

            #include <stdlib.h>
            #define NBYTES  1024

            char from[NBYTES],  to [NBYTES];

               /*  копирует  n байтов из одного расположения в другое, пе-
         реставляет (обменивает) каждую пару смежных байтов */

            swab(from, to, NBYTES);.


               SYSTEM

            #include <process.h>   требуется только для объявления
                                   функции
            #include <stdlib.h>    использует  либо  <process.h>,
                                   либо <stdlib.h>

            int system(string);
            char *string;          выполняемая команда


               Описание.

               Функция  system передает заданную строку string к интерпре-
         татору команд и обрабатывает эту строку как команду MS DOS. Функ-
         ция system ссылается на переменные окружения COMSPEC и PATH, что-
         бы расположить файл COMMAND.COM, который используется при  выпол-
         нении команды string.


               Возвращаемое значение.

               Если  string  успешно отработала, функция system возвращает
         значение 0. Возвращаемое значение -1 свидетельствует об ошибке  и
         errno устанавливается в одно из следующих значений:

            ЗНАЧЕНИЕ                        ЕГО СМЫСЛ

          E2BIG            Список аргументов для команды превышает
                           128 байтов, или пространство, требуемое
                           для информации окружения, превышает 32К.

          ENOENT           COMMAND.COM не может быть найден.

          ENOEXEC          Файл   COMMAND.COM   не   может    быть
                           выполненным и имеет неверный формат.

          ENOMEM           Для выполнения child-процеса памяти  не
                           достаточно, или эта  память    является
                           запорченной,  или  существуют  неверные
                           блоки, указывающие,  что parent-процесс
                           не захвачен.



               См. также execl, execle,  execlp,  execv,  execve,  execvp,
         exit, _exit, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve,
         spawnvp.

               Пример:

            #include <process.h>

            int result;


               /* следующий оператор добавляет номер версии DOS к log фай-
         лу */

            result = system("ver >> result.log");



            TAN-TANH

            #include <math.h>

            double tan(x);       вычисляет тангенс x
            double tanh(x);      вычисляет гиперболический тангенс x
            double x;            радиан

               Описание.

               Функции  tan  и tanh вычисляют соответственно тангенс и ги-
         перболический тангенс x.

               Возвращаемое значение.

               Функция tan возвращает тангенс x. Если x большой,  при  вы-
         числениях  может  возникнуть  частичная потеря значимости. В этом
         случае tan вырабатывает ошибку PLOSS, но сообщения  не  печатает.
         Если x настолько большой, что общая значимость результата теряет-
         ся, тогда tan печатает сообщение об ошибке TLOSS в stderr и возв-
         ращает 0. В обоих случаях errno устанавливается в ERANGE.
               Функция  tanh возвращает гиперболический тангенс x. Возвра-
         щаемого значения в случае ошибки нет.
               См.также acos, asin, atan, atan2, cos, cosh, sin, sinh.

               Пример:

            #include <math.h>

            double pi,x,y;

            pi = 3.1415926535;
            x = tan(pi/4.0);     /* x равен 1.0 */
            y = tanh(x);         /* y равен 1.6 */




               TEMPNAM - TMPNAM

            #include <stdio.h>

            char *tmpnam(string);
            char *string;            указатель на временное имя.

            char *tempnam(dir, prefix);
            char *dir;
            char *prefix;

               Описание.

               Функция tmpnan генерирует имя  временного  файла.  Это  имя
         хранится  в  string.  Если string является NULL, память для строк
         размещается посредством функции malloc. При этом, если  использо-
         валась функция malloc, пользователь сам является ответственным за
         освобождение памяти.
               Символьная  строка, созданная по tmpnam, состоит из цифр от
         "0" до "9"; численное значение этой строки может изменяться от  1
         до 65535.
               Функция  tempnam  позволяет  пользователю создать временный
         файл в другом директории. Prefix является приставкой к имени фай-
         ла. Эта функция рассматривает файл с заданным именем в других ди-
         ректориях, расположенных в порядке старшинства.


                   УСЛОВИЕ                ИСПОЛЬЗУЕМЫЙ ДИРЕКТОРИЙ

         Устанавливается    переменная   Директорий,  определяемый
         окружения  TMP,  и существует   по ТМР.
         директорий,  определяемый
         по TMP.

         Переменная  окружения  TMP не   Аргумент dir для  tempnam.
         устанавливается     или    не
         существует        директорий,
         определяемый по TMP.

         Аргумент  dir  является  NULL   P_tmpdir  в <stdio.h>.
         или  dir  является  именем не
         существующего директоия.

         Не существует P_tmpdir.         \tmp.

               Если все это отсутствует, tempnam возвращает значение NULL.

               Возвращаемое значение.

               Эти функции возвращают указатель  на  сгенерированное  имя,
         если  есть  возможность создать это имя, или если имя не является
         единственным (уникальным). Если имя не может быть создано или оно
         всегда существует, функции tmpnam и tempnam  возвращают
         значение NULL



               См. также tmpfile.

               Пример:

            #include <stdio.h>

            main ()
            {
            char *name1, *name2;

            if ((name1 = tmpnam(NULL)) != NULL)
               printf("%s is safe to use as a temporary file.\n",
                      name1);
            else
               printf("cannot create a unique file name\n");

            if ((name2 = tempnam("a:\\tmp", "stq")) != NULL)
               printf("%s is safe to use as a temporary file.\n",
                      name2);
            else
               printf("cannot create a unique file name\n");
            }.



               TELL

            #include <io.h>    требуется  только  для  объявления
                               функции
            long tell(handle);
            int handle;        handle-р,  ссылающийся на открытый
                               файл

               Описание.

               Функция  tell берет текущую позицию указателя на файл (если
         он есть), связанного с handle. Позиция выражается как число  бай-
         тов от начала файла.

               Возвращаемое значение.

               Функция  tell возвращает текущую позицию. Возвращаемое зна-
         чение -1L указывает на ошибку  и errno устанавливается  в  EBADF,
         которое определяет неверный аргумент handle-ра файла. Для устрой-
         ств,  не  приспособленных к поиску (таких как терминалы и принте-
         ры), возвращаемые значения не определены.
               См.также ftell, lseek

               Пример:

            #include<io.h>
            #include<stdio.h>
            #include<fcntl.h>

            int fh;
            long position;

            fh = open ("data", O_RDONLY);
            .
            .
            .
            position = tell (fh);
            /* запоминает текущую позицию */
            .
            .
            .
            lseek (fh, position,0);
            /* находит предыдущую позицию */




               TIME

            #include <time.h>  требуется только для объявления
                               функции
            long time(timeptr);
            long *timeptr;     память для хранения времени

               Описание.

               Функция time в соответствии с системными часами  возвращает
         количество  секунд,  прошедших  от  00:00:00  значения времени по
         Гринвичу,т.е. с 1 января 1980 года. Возвращаемое значение хранит-
         ся в расположении, заданном по timeptr. Если возввращаемое значе-
         ние не запомнено, timeptr является NULL.


               Возвращаемое значение.

               Функция time возвращает пройденное время (в секундах). Воз-
         вращаемого значения нет.
               См.также asctime, ftime, gmtime, localtime, utime.

               Пример:

            #include <time.h>
            #include <stdio.h>

            long ltime;

            time(&ltime);
            printf("the time is %s\n", ctime(&ltime));




               TMPFILE


            #include <stdio.h>

            FILE *tmpfile();           значение,   указывающее  на
                                       структуру   типа   FILE.

               Описание.

               Функция tmpfile создает временный файл и возвращает  указа-
         тель  на  этот  файл.  Если  файл  не  может быть открыт, функция
         tmpfile возвращает указатель NULL. Этот временный файл  автомати-
         чески удаляется, когда программа заканчивается нормально  или ес-
         ли вызвана функция rmtmp, а текущий рабочий директорий не был из-
         менен.
               Временный файл открывается в режиме "w".

               Возвращаемое значение.

               Эта функция возвращает указатель на поток. Если файл не от-
         крывается - возвращается NULL-указатель.
               См. также tmpnam, tempnam, rmtmp.

               Пример:

            #include <stdio.h>

            FILE *stream;
            char tmpstring[] = "String to be temporary written".

            main ()

            {
            if ((stream = tmpfile()) == NULL)
                perror("Couldn't make temporary file");
            else
                fprintf(stream, "%s", tmpstring);
            }.



               TOASCII-_TOUPPER

            #include <ctype.h>
            int toascii(c)        преобразует "c"  в  символ  ASCII

            int tolower(c)        преобразует  "c" в символ верхнего
                                  регистра   (в   строчную букву),
                                  если это возможно

            int _tolower(c)       преобразует "c"  в строчную  букву

            int toupper(c)        преобразует "c"  в символ  нижнего
                                  регистра (прописную букву), если
                                  это возможно

            int _toupper(c)       преобразует "c"  в символ  нижнего

                                  регистра

            int c;                преобразуемый символ


               Описание.

               Макро toascii, tolower, toupper и _toupper преобразуют сим-
         вол "c" так, как описано ниже.
               Макро toascii устанавливает первые 7 битов "c" в нуль  так,
         что  преобразованное  значение  соответствует символу ASCII. Если
         "c" уже соответствует ASCII, то он не изменяется.
               Макро tolower преобразует "c" в строчную  букву,  если  "c"
         соответствует прописной литере. Иначе - "c" не изменяется.
               Макро  _tolower  является  версией  tolower, использующейся
         только тогда, когда "c" - прописная буква. Если это не  так,  ре-
         зультат выполнения _tolower не определен.
               Макро toupper преобразует "c" в строчную букву, если "c" не
         является строчной буквой. Иначе - "c" не изменяется.
               _Toupper является версией toupper, используемой только тог-
         да,  когда  "c"  -  строчная буква. Если "c" не является строчной
         буквой, то результат не определен.

               Возвращаемое значение.

               Макро toascii, tolower, toupper и _toupper возвращают  пре-
         образованный  символ  "c". Возвращаемого значения в случае ошибки
         нет.
               См.также   isalnum,  isalpha,  isascii,  iscntrl,  isdigit,
         isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit.

               Замечание. Эти  процедуры  реализуются  как  макро.  Однако
         tolower  и  toupper  также реализуются и как функции, т.к. версии
         макро некорректно обрабатывают аргументы с  побочными  эффектами.
         Версии функций могут быть использованы, если удалить макроопреде-
         ления  директивой #undef или не подключать <ctype.h>. Определения
         функций tolower и toupper даны в <stdlib.h>.

               Пример:

               #include <stdio.h>
               #include <ctype.h>
               int ch;

               /*следующие операторы анализируют все
         **символы между кодами 0х0 и 0х7f.
         **Макро toupper и tolower применяются
         **для  любых кодов.  _Toupper и _tolower
         **применяются только для кодов, имеющих
         **смысл */

               for (ch=0; ch<=0x7f; ch++)  {
                   printf (" toupper=%#04x", toupper (ch));
                   printf (" tolower=%#04x", tolower (ch));


                   if (islower(ch))
                      printf(" _toupper=%#04x", _toupper(ch));
                   if (isupper(ch))
                      printf("_tolower=%#40x", _tolower(ch));
                   putchar ('\n');
                   }



               TZSET

            #include <time.h>  требуется только для объявления
                               функции

            void tzset();

            int daylight;      флаг перехода на летнее/зимнее
                               время
            long timezone;     различие в секундах от GMT
            char *tzname[2]l   строки трехбуквенных временных
                               зон

               Описание.

               Функция tzset использует текущую установку переменной окру-
         жения TZ, чтобы назначить  значения  трем  переменным:  daylight,
         timezone,  tzname.  Эти  переменные используются функциями ftime,
         localtime для изменения значения времени  по  Гринвичу  (GMT)  на
         местное время.
               Значением переменной окружения TZ должно быть трехбуквенное
         имя  временной  зоны,  такой как PST, следующей за необязательным
         знаковым числом, задающим различие в часах между значением време-
         ни по Гринвичу и местным временем.Число может идти за трехбуквен-
         ной зоной перехода на летнее/зимнее время, такой как PDT.  Напри-
         мер,  "PST8PDT"  представляет  действительное  значение  для зоны
         Pacific time.
               Когда  вызывается  tzset,  переменным  daylight,  timezone,
         tzname назначаются следующие значения:

            Переменная                      Значение

            timezone       Различие  между  значением  времени  по
                           Гринвичу и местным временем

            daylight       Ненулевое значение, если в установке TZ
                           определен  переход   на   летнее/зимнее
                           время; иначе -0

            tzname[0]      Строковое     значение,    определяющее
                           трехбуквенное  имя  временной  зоны  из
                           установки TZ

            tzname[1]      Строковое  значение,  определяющее зону
                           перехода на  летнее/зимнее  время,  или
                           пустую  строку, если эта зона пропущена
                           в установке TZ




               Если   TZ  не  установлена,  по  умолчанию  устанавливается
         PST8PDT, которая соответствует зоне Pacific  time.  По  умолчанию
         для daylight устанавливается 1, timezone - 28800, для tzname[0] -
         "PST", tzname[1] - "PDT".


               Возвращаемое значение.

               Возвращаемого значения нет.
               См.также asctime, ftime, localtime.

               Пример:

            #include <time.h>

            int daylight;
            llong timezone;
            char *tzname[];
            .
            .
            .
            putenv("TZ=EST5");
            tzset();


               ULTOA

            #include <stdlib.h>           требуется   только   для
                                          объявления функции
            char ultoa(value, string, radix);

            unsigned long value;          преобразуемое число
            char *string;                 строка результата
            int radix;                    основание value

               Описание.

               Функция ultoa преобразует символы value в символьную  стро-
         ку, оканчивающуюся NULL-символом, и запоминает ее в string. Пере-
         полнение  не  контролируется. Аргумент radix определяет основание
         системы счисления value. Он может принимать значения от 2 до 36.

               Возвращаемое значение.

               Функция  ultoa возвращает указатель на строку string. Возв-
         ращаемого значения в случае ошибки нет.
               См.также itoa, ltoa.

               Замечание: Память, отводимая под string, должна быть  боль-
         ше,  чем  требуется  для  возвращаемой строки. Функция возвращает
         строку длиной до 33 байтов.


               Пример:

                #include <stdlib.h>

                int radix = 16;
                char buffer [40];
                char *p;
                        /* p будет "501d9138 */
                p=ultoa (1344115000L, buffer, radix);



               UMASK

            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только  для объявления
                                  функции

            int umask(pmode);
            int pmode;            доступ, разрешенный по умолчанию

               Описание.

               Функция umask устанавливает  для  текущего  процесса  маску
         разрешенного  доступа  для файла в режим, который определяется по
         pmode. Маска разрешенного доступа  используется  для  модификации
         установленного  доступа  для  новых файлов, созданных посредством
         функций create, open или sopen. Если бит в маске равен 1, то  со-
         ответствующий  ему бит в значении режима доступа к файлу устанав-
         ливается в 0 (запрещение). Если бит в маске равен 0, соответству-
         ющий ему бит остается неизмененным. Маска доступа для нового фай-
         ла не установится, пока файл не закроется хотя бы один раз. Аргу-
         мент pmode является константным выражением, содержащим  одну  или
         обе  манифестные  константы  S_IWRITE  и  S_IREAD, определенные в
         <sys\stat.h>.Когда заданы обе константы, они объединяются логичес-
         ким опратором ИЛИ(:).

               Значение аргумента pmode приводится ниже.

         Значение                          Его смысл

         S_IWRITE           Запись не допускается (файл только  для
                            чтения)

         S_IREAD            Чтение не допускается (файл только  для
                            записи)


               Например, если в маске установлен бит записи,  любые  новые
         файлы будут доступны для чтения.

               Замечание.  В MS DOS все файлы доступны для чтения, поэтому
         доступ только по записи задать невозможно.  Это  обозначает,  что
         установка бита чтения в umask не имеет смысла.


               Возвращаемое значение.

               Функция umask возвращает предыдущее значение pmode. Возвра-
         щаемого значения в случае ошибки нет.
               См.также chmod, creat, mkdir, open.


               Пример:

            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>

            int oldmask;

            oldmask=umask(S_IWRITE);
            /* создать файлы только для чтения */



               UNGETC

            #include <stdio.h>

            int ungetc(c, stream);
            int c;                     возвращаемый символ

            FILE *stream;              указатель на структуру
                                       типа FILE

               Описание.

               Функция ungetc возвращает символ "c" в заданный поток ввода
         stream. Stream должен быть буферизованным и открытым для  чтения.
         Последующая  операция  чтения из stream начинается с символа "c".
         EOF вернуть в поток посредством использования ungetc нельзя.  Эта
         функция возвращает значение ошибки, если из stream ничего не про-
         читано   или  если "c" назад не возвращен. Символы, размещаемые в
         потоке посредством ungetc, могут быть  уничтожены,  если  функции
         fseek или rewind вызваны перед считыванием символа из stream.

               Возвращаемое значение.

               Эта  функция  возвращает аргумент символа "c". Возвращаемое
         значение EOF свидетельствует о  неудачном  возвращении  заданного
         символа.
               См. также getc, getchar, putc, putchar.

               Пример:

            #inc <stdio.h>
            #include <ctype.h>

            FILE *stream;

            int ch;
            int result = 0;
            .
            .
            .
               /* следующие операторы выбирают десятичное целое из  потока
         stream */

            while ((ch = getc(stream)) != EOF && isdigit(ch))
                  result = result * 10 + ch - '0';

            if (ch != EOF)
               ungetc(ch, stream);
               /* возвращает назад не десятичное целое. */


            UNGETCH

            #include <conio.h>     требуется только для объявления
                                   функции

            int ungetch(c);
            int c;                 возвращаемый символ

               Описание.

               Функция  ungetch возвращает символ "c" на консоль и опреде-
         ляет его как следующий читаемый символ. Функция ungetch не выпол-
         няется, если перед следующим чтением она  вызывается  более   чем
         один раз.

               Возвращаемое значение.

               Функция  ungetch возвращает символ "c", если функция удачно
         отработала. Возвращаемое значение EOF указывает на ошибку.
               См.также cscanf, getch, getche.

               Пример:

            #include <conio.h>
            #include <ctype.h>

            char bufffer[100];
            int count=0;
            int ch;

               /*  следующий код берет обозначение, ограниченное пробелами
         или новыми строками, из клавиатуры */

            ch = getche();

            while (isspace(ch))
                ch = getche();

            while (count < 99)

            {  if (isspase(ch))
               break;

               buffer[count++] = ch;
               ch = getche();
            }

            ungetch(ch);
            buffer[count] = '\0';


               UNLINK

            #include <io.h>     требуется  только  для объявления
                                функции
            #include <stdio.h>  использует   либо   <io.h>,  либо
                                <stdio.h>

            int unlink(pathname);
            char *pathname;     path-имя удаляемого файла

               Описание.

               Функция unlink удаляет файл, определенный по pathname.

               Возвращаемое значение.

               Функция unlink возвращает 0, если файл успешно удален. Воз-
         вращаемое значение -1 свидетельствует об ошибке  и errno устанав-
         ливается в одно из следующих значений:

           Значение                         Его смысл

          EACCES             Path-имя определяет директорий или файл
                             только для чтения

          ENOENT             Файл или path-имя не найдено

               См.также close, remove.

               Пример:

            #include <io.h>
            #include <stdio.h>

            int result;

            result=unlink("tmpfile");
            if (result == -1)
              perror("couldn't delete tmpfile");


               UTIME

            #include <sys\types.h>

            #include <sys\utime.h>

            int utime(pathname, times);
            char *pathname;                  path-имя файла
            struct utimbuf *times;           указатель на хранимые
                                             значения времени

               Описание.

               Функция utime устанавливает время модификации файла,  кото-
         рый  определяется по pathname. Процесс должен иметь доступ по за-
         писи к файлу, иначе   время не будет изменяться.
               Поскольку структура utimbuf содержит поле времени  доступа,
         в MS DOS устанавливается только время модификации.
               Если  times является NULL-указателем, время модификации ус-
         танавливается по текущему времени. Иначе  times должно  указывать
         на  структуру  типа utimbuf, определенную в <sys\utime.h>. В этой
         структуре время модификации устанавливается из поля modtime.

               Возвращаемое значение.

               Функция utime возвращает значение 0, если время модификации
         было изменено. Возвращаемое значение -1 свидетельствует об  ошиб-
         ке  и errno устанавливается в одно из следующих значений:

            ЗНАЧЕНИЕ                     ЕГО СМЫСЛ

            EACCES           Path-имя  файла определяет директорий
                             или файл, предназначенный только  для
                             чтения.

            EMFILE           Существует   много   открытых  файлов
                             (файл  должен   быть   открытым   для
                             изменения времени его модификации).

            ENOENT           Файл или path-имя не найдено.

               См.  также asctime, ctime, fstat, ftime, gmtime, localtime,
         stat, time.


               Пример.

            #include <sys\types.h>
            #include <sys\utime.h>
            #include <stdio.h>
            #include <stdlib.h>

               /* Время модификации файла устанавливается по текущему вре-
         мени */

            if (utime("/tmp/data", NULL) == -1)
                     perror ("utime failed").




               VA_ARG - VA_START

            #include <varargs.h>           требуется          для
                                           совместимости с UNIX V.

            #include<stdarg.h>             требуется          для
                                           совместимости       со
                                           стандартом   ANSI   C.

            void  va_start(arg-ptr);       макро   для   установки
                                           arg-ptr    к     началу
                                           списка   необязательных
                                           аргументов      (только
                                           версия <varargs.h>).

            void va_start(arg-ptr, prev-param);
                                           макро   для   установки
                                           arg-ptr к началу списка
                                           необязательных    аргу-
                                           ментов  (только  версия
                                           <stdarg.h>).

            type va_start(arg-ptr, type);  макро  для  возвращения
                                           текущего аргумента

            void va_arg(arg-ptr);          макро для переустановки
                                           arg-ptr

            va_list arg-ptr;               указатель   на   список
                                           аргументов;
            type                           тип       возвращаемого
                                           аргумента;
            prev-param                     параметр, предшедствую-
                                           щий             первому
                                           необязательному   аргу-
                                           менту  (только   версия
                                           <stdarg.h>).

            va_alist                       имя параметра для вызы-
                                           ваемой  функции (только
                                           версия <varargs.h>).

            va_dcl                         объявление     va_alist
                                           (только          версия
                                           <varargs.h>).

               Описание.

               Макро va_start, va_arg, va_end обеспечивают способ  доступа
         к  аргументам  функции, когда она принимает переменное количество
         аргументов.
               Доступны  2 версии макро: макро, объявленные в <varargs.h>,
         которые совместимы с определением системы UNIX 5, и макро, объяв-
         ленные в <stdarg.h>, которые приведены в соответствии со стандар-

         том ANSI C.
               Обе версии макро предполагают, что функция принимает фикси-
         рованное число требуемых аргументов, следующее за переменным чис-
         лом необязательных аргументов. Требуемые аргументы объявлены  как
         необязательные  параметры для функций и могут быть доступны через
         имена параметров. Необязательные аргументы доступны  через  макро
         <varargs.h>  или  <stdarg.h>,  которые устанавливают указатель на
         первый необязательный аргумент в  списке  аргументов;  возвращают
         аргументы из списка и переустанавливают указатель, когда обработ-
         ка аргументов завершена.
               Макро  системы UNIX 5, объявленные в <varargs.h>, использу-
         ются как показано ниже.

               1. Любые требуемые параметры для функции могут быть  объяв-
         лены обычным способом как параметры.
               2.  Последний параметр для функции представляет список нео-
         бязательных аргументов. Этот параметр должен быть назван va_alist
         (не  перепутайте  его  с  va_list,  который  объявлен   как   тип
         va_alist).
               3. Макро va_dcl появляется после объявления функции и перед
         открытой  левой скобкой функции. Эта макро объявляется как полное
         описание параметра va_alist, оканчивающегося  точкой  с  запятой,
         однако, за va_dcl не может идти точка с запятой.
               4.  Внутри  функции  макро va_start устанавливает arg-ptr к
         началу списка необязательных параметров, который передается функ-
         ции. Макро va_start должна использоваться перед va_arg, использу-
         емой в первый раз. Аргумент arg-ptr должен иметь тип va_list.
               5. Макро va_arg выполняет следующее:
               * возвращает значение заданного типа type из того  располо-
         жения, которое определяется по аргументу arg-ptr;
               *  увеличивает arg-ptr, чтобы указать на следующий аргумент
         в списке, используя размер type для определения начала расположе-
         ния следующего аргумента.
               Внутри функций макро va_arg может использоваться любое  ко-
         личество раз, чтобы возвратить требуемые аргументы из списка.
               6.  После возвращения всех аргументов  va_end устанавливает
         указатель в NULL.

               Макро, предлагаемые  стандартом  ANSI  C  и  объявленные  в
         <stdarg.h>,  незначительно отличаются от макро, которые объявлены
         в <varargs.h>.
               1. Все требуемые аргументы для функции объявляются как  па-
         раметры. Макро va_dcl не используется вместе с макро <stdarg.h>.
               2.  Макро va_start устанавливает arg-ptr на первый необяза-
         тельный аргумент из списка аргументов, который  передается  функ-
         ции.   Аргумент   arg-prt  должен  иметь  тип  va_list.  Аргумент
         prev-param является именем требуемого параметра,  непосредственно
         предшедствующего  первому необязательному параметру из списка ар-
         гументов. Макро va_start должна быть использована  перед  va_arg,
         используемой в первый раз.
               3. Макро va_arg выполняет следующее:
               * возвращает значение типа type из того расположения, кото-
         рое определяется по аргументу arg-ptr.
               *  чтобы указать на следующий аргумент в списке, она увели-
         чивает arg-ptr и использует размер type  для  определения  начала

         расположения следующего аргумента.
               Внутри  функций макро va_arg может использоваться любое ко-
         личество раз, чтобы возвратить требуемые аргументы из списка.
               4. После возвращения всех аргументов, va_end переустанавли-
         вает указатель в NULL.

               Возвращаемое значение.

               Макро va_arg возвращает текущий аргумент; va_start и va_end
         значений не возвращают.
               См. также vfprintf, vprintf, vsprintf.

               Пример:

               Ниже приводится листинг программы, использующей <varargs.h>
         для совместимости с UNIX V.

            #include <stdio.h>
            #include <varargs.h>

            main()
            {
                   int n;
                   .
                   .
                   .
               /* вызывается функция 4-х  аргументов;  последний  аргумент
         задается равным -1, чтобы отметить конец списка аргументов */

                   n = average(2, 3, 4, -1);
            printf("Average is: %d\n", n);
                   .
                   .
                   .
               /*  вызывается  функция 5-ти аргументов; последний аргумент
         задается равным -1, чтобы отметить конец списка аргументов */

                   n = average(5, 7, 9, 11, -1);
            printf("Average is: %d\n", n);
            }

            average(va_alist)
            va_dcl
              {
                 int i = 0, count = 0, sum = 0;
                 va_list arg_marker;

                 va_start(arg_marker);

               /* возвращение аргументов и прибавление к sum, пока не вст-
         ретится последний аргумент -1. */

             for (; (i = va_arg(arg_marker, int)) >= 0;
                         sum+=i, count++)
                              ;

                 return (count ? (sum/count) : count);
              }.


               Аналогичная  программа, перезаписанная для совместимости со
         стандартом ANSI C.

            #include <stdio.h>
            #include <stdarg.h>

            main()
            {
                   int n;
                   .
                   .
                   .
               /* вызывается функция 4-х  аргументов;  последний  аргумент
         задается равным -1, чтобы отметить конец списка аргументов */

                   n = average(2, 3, 4, -1);
            printf("Average is: %d\n", n);
                   .
                   .
                   .
               /*  вызывается  функция 5-ти аргументов; последний аргумент
         задается равным -1, чтобы отметить конец списка аргументов */

                   n = average(5, 7, 9, 11, -1);
            printf("Average is: %d\n", n);
            }

            average(first)
            int first;
              {
                 int i = 0, count = 0, sum;
                 va_list arg_marker;

                 va_start(arg_marker, first);

               /* первый  аргумент  прибавляется  к  sum  и  увеличивается
         count; если первый аргумент равен -1, происходит возврат */

                 if (first != -1)
                      sum = first;
                 else
                      return (0);
                 count++;
               /*  возвращение  дополнительных  аргументов и прибавление к
         sum, пока не встретится последний аргумент -1. */

                 for (; (i = va_arg(arg_marker, int)) >= 0;
                         sum+=i, count++)
                              ;
                 return (sum/count);
              }.




               VFPRINTF - VSPRINTF

            #include <stdio.h>
            #include <varargs.h>    требуется  для совместимости
                                    с UNIX V.

            #include <stdarg.h>     требуется для совместимости со
                                    стандартом ANSI C.

            int vfprintf(stream, format-string, arg-ptr);
            int vprintf(format-string, arg-ptr);
            int vsprintf(buffer, format-string, arg-ptr);

            FILE *stream;            указатель на  структуру
                                     типа FILE.
            char *buffer;            память  для  хранения резуль-
                                     тата
            char *format-string;     строка управления форматом
            va_list arg-ptr;         указатель   на  список  аргу-
                                     ментов.
               Описание.

               Функции vfprintf, vprintf, vsprintf форматируют  и  выводят
         данные соответственно в поток stream, поток стандартного вывода и
         буфер  buffer.  Эти  функции  похожи  на  свои  двойники fprintf,
         printf, sprintf, но используют  указатель  на  список  аргументов
         вместо списка аргументов.
               Format-string  имеет ту же самую форму и функцию, что и ар-
         гумент строки формата для функции printf; (см.  описание  функции
         printf).
               Параметр   arg-ptr   имеет   тип  va_list,  определяемый  в
         <vararg.h> и <stdarg.h>. Этот параметр указывает на список  аргу-
         ментов, которые преобразовываются и выводятся согласно соответст-
         вующим спецификациям формата в format-string.

               Возвращаемое значение.

               Возвращаемым  значением является количество выведенных сим-
         волов.
               См.  также  fprintf,  printf,  sprintf,   va_arg,   va_end,
         va_start.

               Пример:

               В качестве примера приводится листинг программы, использую-
         щей <varargs.h> для совместимости с UNIX V.

            #include <stdio.h>
            #include <varargs.h>

            main ()
            {

            int line = 1;

            char *filename = "EXAMPLE";
            .
            .
            .
            error("Error: line %d, file %s\n", line, filename);
            .
            .
            .
            error("Syntax error\n");
            }

            error(va_alist);
            va_dcl;
            {
               char *fmt;
               va_list arg_ptr;

                 va_start(arg_ptr);
               /* arg_ptr сейчас указывает на строку формата */
                 fmt = va_arg(arg_ptr, char *);
               /* arg_ptr сейчас указывает на аргумент после строки форма-
         та */
                 vprintf(fmt, arg_ptr);
                 va_end(arg_ptr);
            }

            На выходе:

            Error: line 1, file EXAMPLE
            Syntax error.

               Ниже  приводится  аналогичная программа, перезаписанная для
         совместимости со стандартом ANSI C.

            #include <stdio.h>
            #include <stdarg.h>

            main ()
            {
            int line = 1;
            char *filename = "EXAMPLE";
            .
            .
            .
            error("Error: line %d, file %s\n", line, filename);
            .
            .
            .
            error("Syntax error\n");
            }

            error(fmt);
            char *fmt;

            {
               va_list arg_ptr;
               va_start(arg_ptr, fmt);


               /* arg_ptr сейчас указывает на аргумент после строки форма-
         та */
                 vprintf(fmt, arg_ptr);
                 va_end(arg_ptr);
            }

            На выходе:

            Error: line 1, file EXAMPLE
            Syntax error.




               WRITE

            #include<io.h>       требуется только  для  объявления
                                 функции

            int write (handle, buffer, count);
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            char *buffer;       записываемые данные
            unsigned int count; число байтов

               Описание.

               Функция write записывает байты count  из  буфера  buffer  в
         файл, связанный с handle. Операции write начинаются с текущей по-
         зиции  указателя  на файл (указатель ассоциирован с заданным фай-
         лом). Если файл открыт для добавления, операции выполняются в ко-
         нец файла. После осуществления операций записи указатель на  файл
         (если он есть) увеличивается на количество действительно записан-
         ных байтов.

               Возвращаемое значение.

               Функция  write  возвращает  число  действительно записанных
         байтов. Возвращаемое значение должно быть положительным, но мень-
         ше числа count (например, когда размер для  записи  count  байтов
         выходит  за пределы пространства на диске). Возвращаемое значение
         -1 указывает на ошибку; errno устанавливается в одно из следующих
         значений:

            ЗНАЧЕНИЕ            ЕГО СМЫСЛ

            EACCES           файл открыт для чтения или закрыт для
                             записи

            EBADF            неверный handle-р файла


            ENOSPC           на устройстве нет свободного места

               Если в файл записано более 32К  (максимальный   размер  для
         типа  int),  возвращаемое  значение  будет иметь тип unsigned int
         (см.нижеследующий пример). Однако, максимальное число  записывае-
         мых байтов в файл равно 65534; поскольку число 65535 является не-
         отличимым  от -1, то возвращается ошибка. Если заданный файл отк-
         рыт в текстовом режиме, каждый символ "Перевод строки" на  выходе
         заменяется  парой "Возврат каретки-Перевод строки". Эта замена не
         влияет на возвращаемое значение.
               См.также fwrite, open, read.

               Замечание. При записи в файл, открытый в текстовом  режиме,
         символ  трактуется как логический конец файла. При записи на уст-
         ройство символ в буфере влияет на окончание #include<io.h>.

            #include<stdio.h>
            #include<fcntl.h>

            char buffer [60000];

            main ()

               {
               int fh;
               unsigned int nbytes = 60000, byteswritten;

               if ((fh=open("c:/data/conf.dat",O_WRONLY))==-1) {
                   perror("open failed on output file");
                   exit (1);
                   }
               if ((byteswritten=write(fh,buffer,nbytes))==-1)
                   perror ("");
               else
                 printf("Wrote %u bytes to file\n",byteswritten);
               .
               .
               .
               }

