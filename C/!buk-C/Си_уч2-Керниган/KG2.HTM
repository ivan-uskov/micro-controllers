<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>
1. Учебное введение.


     Давайте  начнем  с  быстрого  введения в язык "C". Наша
цель - продемонстрировать существенные элементы языка на ре-
альных  программах, не увязая при этом в деталях, формальных
правилах и исключениях. В этой главе мы не пытаемся изложить
язык  полностью  или  хотя бы строго (разумеется, приводимые
примеры будут корректными). Мы хотим как можно скорее довес-
ти  Вас  до такого уровня, на котором Вы были бы в состоянии
писать полезные программы, и чтобы добиться этого, мы сосре-
дотачиваемся на основном: переменных и константах, арифмети-
ке, операторах передачи управления, функциях и  элементарных
сведениях о вводе и выводе. Мы совершенно намеренно оставля-
ем за пределами этой главы многие элементы языка "C",  кото-
рые  имеют  первостепенное  значение  при  написании больших
программ, в том числе указатели, сртуктуры, большую часть из
богатого  набора  операторов языка "C", несколько операторов
передачи управления и несметное количество деталей.
     Такой подход имеет, конечно, свои недостатки. Самым су-
щественным  является то, что полное описание любого конкрет-
ного элемента языка не излагается в одном месте,  а  поясне-
ния, в силу краткости, могут привести к неправильному истол-
кованию. Кроме того, из-за  невозможности  использовать  всю
мощь языка, примеры оказываются не столь краткими и элегант-
ными, как они могли бы быть. И хотя мы старались свести  эти
недостатки к минимуму, все же имейте их ввиду.
     Другой  недостаток состоит в том, что последующие главы
будут неизбежно повторять некоторые части этой главы. Мы на-
деемся, что такое повторение будет скорее помогать, чем раз-
дражать.
     Во всяком случае, опытные программисты должны оказаться
в  состоянии  проэкстраполировать  материал  данной главы на
свои собственные программистские нужды. Начинающие же должны
в  дополнение  писать  аналогичные маленькие самостоятельные
программы. И те, и другие могут использовать эту  главу  как
каркас, на который будут навешиваться более подробные описа-
ния, начинающиеся с главы 2.

1.1. Начинаем. Единственный способ освоить новый язык  прог-
раммирования  -  писать  на нем программы. Первая программа,
которая должна быть написана, - одна для всех языков:  напе-
чатать слова : hello, world.
      Это - самый существенный барьер; чтобы преодолеть его,
Вы должны суметь завести где-то текст программы, успешно его
скомпилировать,  загрузить,  прогнать и найти, где оказалась
ваша выдача. Если Вы научились справляться с этими техничес-
кими деталями, все остальное сравнительно просто.
      Программа печати "hello, world"  на  языке  "C"  имеет
вид:
    main ()
    {
            printf("hello, world\n");
    }
      Как пропустить эту программу - зависит от используемой
вами системы. В частности, на операционной системе "UNIX" Вы
должны  завести  исходную  программу  в  файле, имя которого
оканчивается на ".c" , например, hello.c , и затем скомпили-
ровать ее по команде
            cc hello.c
      Если  Вы  не  допустили какой-либо небрежности , такой
как пропуск символа или неправильное  написание,  компиляция
пройдет  без  сообщений  и  будет  создан исполняемый файл с
именем а.out . Прогон его по команде

               a.out

приведет к выводу

           hello, world

На других системах эти правила будут иными; проконсультируй-
тесь с местным авторитетом.

Упражнение 1-1.
     Пропустите  эту  программу на вашей системе. Попробуйте
не включать различные части программы и посмотрите какие со-
общения об ошибках Вы при этом получите.

      Теперь некоторые пояснения к  самой  программе.  Любая
"C"-программа,  каков  бы ни был ее размер, состоит из одной
или  более  "функций",  указывающих   фактические   операции
компьютера,  которые  должны быть выполнены. Функции в языке
"C" подобны функциям и подпрограммам фортрана  и  процедурам
PL/1, Паскаля и т.д. В нашем примере такой функцией является
main. Обычно Вы можете давать функциям любые имена по вашему
усмотрению, но main - это особое имя; выполнение вашей прог-
раммы начинается сначала с функции main. Это  означает,  что
каждая программа должна в каком-то месте содержать функцию с
именем main. Для выполнения  определенных  действий  функция
main  обычно  обращается к другим функциям, часть из которых
находится в той же самой программе, а часть - в библиотеках,
содержащих ранее написанные функции.
      Одним способом обмена данными между функциями является
передача посредством аргументов. Круглые  скобки,  следующие
за именем функции, заключают в себе список аргументов; здесь
маin - функция без аргументов, что указывается как ().  Опе-
раторы,  составляющие функцию, заключаются в фигурные скобки
{ и }, которые аналогичны do-end в PL/1 или begin-end в  ал-
голе, Паскал е и т.д. Обращение к функции осуществляется ука-
занием ее имени, за которым следует  заключенный  в  круглые
скобки список аргументов. здесь нет никаких операторов call,
как в фортране или PL/1. Круглые скобки  должны  присутство-
вать  и  в  том  случае,  когда функция не имеет аргументов.
Строка

      printf("hello, world\n");

является обращением к функции, которое  вызывает  функцию  с
именем  printf  и аргуметом "hello, world\n". Функция printf
является библиотечной функцией, которая выдает выходные дан-
ные на терминал (если только не указано какое-то другое мес-
то назначения). В данном случае печатается строка  символов,
являющаяся аргументом функции.
     Последовательность из любого количества символов,  зак-
люченных  в  удвоенные кавычки "...", называется 'символьной
строкой' или 'строчной константой'. Пока мы будем  использо-
вать  символьные  строки  только  в  качестве аргументов для
printf и других функций.
     Последовательность \n  в  приведенной  строке  является
обозначением  на языке "C" для 'символа новой строки', кото-
рый служит указанием для перехода на терминале к левому краю
следующей  строки. Если Вы не включите \n (полезный экспери-
мент), то обнаружите, что ваша выдача не закончится  перехо-
дом  терминала на новую строку. Использование последователь-
ности \n - единственный способ введения символа новой строки
в  аргумент  функции  printf;  если Вы попробуете что-нибудь
вроде

          printf("hello, world
          ");

то  "C"-компилятор  будет печатать злорадные диагностические
сообщения о недостающих кавычках.
    Функция printf не обеспечивает автоматического  перехода
на  новую строку, так что многократное обращение к ней можно
использовать для поэтапной сборки выходной строки. Наша пер-
вая  программа,  печатающая идентичную выдачу, с точно таким
же успехом могла бы быть написана в виде

     main()
     {
             printf("hello, ");
             printf("world");
             printf("\n");
     }

    Подчеркнем, что \n представляет только один символ.  Ус-
ловные  'последовательности', подобные \n , дают общий и до-
пускающий расширение механизм для представления трудных  для
печати или невидимых символов. Среди прочих символов в языке
"C" предусмотрены следующие: \t - для табуляции,  \b  -  для
возврата  на одну позицию, \" - для двойной кавычки и \\ для
самой обратной косой черты.

Упражнение  1-2.
    Проведите эксперименты для того, чтобы узнать, что  прои-
зойдет,  если в строке, являющейся аргументом функции printf
будет содержаться \x, где x - некоторый символ, не  входящий
в вышеприведенный список.

1.2. Переменные и арифметика.

    Следующая  программа  печатает  приведенную ниже таблицу
температур по Фаренгейту и их эквивалентов  по  стоградусной
шкале Цельсия, используя для перевода формулу

          c = (5/9)*(f-32).

     0       -17.8
    20        -6.7
    40         4.4
    60        15.6
   ...         ...
   260       126.7
   280       137.8
   300       140.9

      Теперь сама программа:

    /* print fahrenheit-celsius table
    for f = 0, 20, ..., 300 */
    main()
    {
    int lower, upper, step;
    float fahr, celsius;

    lower = 0;  /* lower limit of temperature
    table */
    upper =300; /* upper limit */
    step  = 20; /* step size */
    fahr = lower;
    while (fahr <= upper) {
      celsius = (5.0/9.0) * (fahr -32.0);
      printf("%4.0f %6.1f\n", fahr, celsius);
      fahr = fahr + step;
    }
    }


Первые две строки

    /* print fahrenheit-celsius table
         for  f  = 0, 20, ..., 300 */

являются  комментарием, который в данном случае кратко пояс-
няет, что делает программа. Любые символы между /* и */  иг-
норируются компилятором; можно свободно пользоваться коммен-
тариями для облегчения понимания программы. Комментарии  мо-
гут  появляться в любом месте, где возможен пробел или пере-
ход на новую строку.
    В языке "C" все переменные должны быть описаны до их ис-
пользования, обычно это делается в начале функции до первого
выполняемого оператора. Если Вы забудете вставить  описание,
то получите диагностическое сообщение от компилятора. Описа-
ние состоит из типа и списка переменных, имеющих  этот  тип,
как в

     int lower, upper, step;
     float fahr, celsius;

    Тип  int  означает, что все переменные списка целые; тип
float предназначен для чисел с плавающей  точкой,  т.е.  для
чисел, которые могут иметь дробную часть. Точность как int ,
tak и float зависит от конкретной машины, на которой Вы  ра-
ботаете. На PDP-11, например, тип int соответствует 16-бито-
вому числу со знаком, т.е. числу, лежащему  между  -32768  и
+32767.  Число  типа  float  - это 32-битовое число, имеющее
около семи значащих цифр и лежащее в диапазоне от 10е-38  до
10е+38.  В главе 2 приводится список размеров для других ма-
шин.
    В языке "C" предусмотрено несколько других основных  ти-
пов данных, кроме int и float:

char    символ - один байт
short   короткое целое
long    длинное целое
double  плавающее с двойной точностью

    Размеры  этих  объектов  тоже машинно-независимы; детали
приведены в главе 2. Имеются также массивы, структуры и  об-
ъединения  этих  основных  типов,  указатели  на них и функ-
ции,которые их возвращают; со всеми  ними  мы  встретимся  в
свое время.
    Фактически вычисления в  программе  перевода  температур
начинаются  с операторов присваивания lower = 0; upper =300;
step = 20; fahr =lower; которые придают  переменным  их  на-
чальные  значения.  каждый  отдельный оператор заканчивается
точкой с запятой.
    Каждая строка таблицы  вычисляется  одинаковым  образом,
так  что  мы  используем  цикл,  повторяющийся  один  раз на
строку. В этом назначение оператора while:

while (fahr <= upper) {
....
}

проверяется условие в  круглых  скобках.  Если  оно  истинно
(fahr  меньше  или  равно  upper), то выполняется тело цикла
(все операторы, заключенные в фигурные скобки { и } ). Затем
вновь проверяется это условие и, если оно истинно, опять вы-
полняется тело цикла. Если же условие не выполняется (  fahr
превосходит upper ), цикл заканчивается и происходит переход
к выполнению оператора, следующего за оператором цикла.  Так
как  в  настоящей программе нет никаких последующих операто-
ров, то выполнение программы завершается.
    Тело  оператора while может состоять из одного или более
операторов, заключенных в фигурные скобки, как  в  программе
перевода  температур,  или  из  одного оператора без скобок,
как, например, в

     while (i < j)
           i = 2 * i;

    В обоих случаях операторы, управляемые оператором while,
сдвинуты на одну табуляцию, чтобы Вы могли с первого взгляда
видеть, какие операторы находятся внутри цикла. Такой  сдвиг
подчеркивает  логическую  структуру  программы. Хотя в языке
"C" допускается совершенно произвольное расположение  опера-
торов  в  строке,  подходящий сдвиг и использование пробелов
значительно облегчают чтение программ. Мы рекомендуем писать
только  один оператор на строке и (обычно) оставлять пробелы
вокруг операторов. Расположение фигурных скобок менее сущес-
твенно; мы выбрали один из нескольких популярных стилей. Вы-
берите подходящий для Вас стиль и затем используйте его пос-
ледовательно.
    Основная часть работы выполняется в теле цикла. Темпера-
тура  по  Цельсию  вычисляется  и  присваивается  переменной
celsius оператором

      celsius = (5.0/9.0) * (fahr-32.0);

причина  использования  выражения 5.0/9.0 вместо выглядящего
проще 5/9 заключается в том, что в языке "C", как и во  мно-
гих  других  языках,  при делении целых происходит усечение,
состоящее в отбрасывании дробной части результата. Таким об-
разом, результат операции 5/9 равен нулю, и, конечно, в этом
случае все температуры оказались бы равными нулю. Десятичная
точка  в  константе указывает, что она имеет тип с плавающей
точкой, так что, как мы и хотели, 5.0/9.0 равно 0.5555... .
    Мы также писали 32.0 вместо 32 , несмотря на то, что так
как переменная fahr имеет тип float , целое 32 автоматически
бы преобразовалось к типу float ( в 32.0) перед  вычитанием.
С  точки  зрения  стиля разумно писать плавающие константы с
явной десятичной точкой даже тогда, когда  они  имеют  целые
значения; это подчеркивает их плавающую природу для просмат-
ривающего программу и обеспечивает то, что компилятор  будет
смотреть на вещи так же, как и Вы.
    Подробные правила о том, в каком случае целые преобразу-
ются  к типу с плаваюшей точкой, приведены в главе 2. Сейчас
же отметим, что присваивание

            fahr = lower;

проверка

            while (fahr <= upper)

работают, как ожидается, - перед выполнением операций  целые
преобразуются в плавающую форму.
    Этот же пример сообщает чуть больше о том, как  работает
printf.  Функция  printf  фактически  является универсальной
функцией форматных преобразований, которая  будет  полностью
описана в главе 7. Ее первым аргументом является строка сим-
волов, которая должна быть напечатана, причем каждый знак  %
указывает, куда должен подставляться каждый из остальных ар-
гументов /второй, третий, .../ и в какой форме он должен пе-
чататься. Например, в операторе

   printf("%4.0f %6.1f\n", fahr, celsius);

спецификация  преобразования %4.0f говорит, что число с пла-
вающей точкой должно быть напечатано в поле шириной по край-
ней  мере  в четыре символа без цифр после десятичной точки.
спецификация %6.1f описывает другое  число,  которое  должно
занимать  по крайней мере шесть позиций с одной цифрой после
десятичной точки, аналогично спецификациям f6.1  в  фортране
или  f(6,1)  в PL/1. Различные части спецификации могут быть
опущены: спецификация %6f говорит, что число  будет  шириной
по  крайней  мере  в шесть символов; спецификация %2 требует
двух позиций после десятичной точки, но ширина при  этом  не
ограничивается;  спецификация  %f  говорит только о том, что
нужно напечатать число с плавающей  точкой.  Функция  printf
также распознает следующие спецификации: %d - для десятично-
го целого, %о - для восьмеричного числа, %х - для шестнадца-
тиричного, %с - для символа, %s - для символьной строки и %%
- для самого символа %.
    Каждая конструкция с символом % в первом аргументе функ-
ции  printf  сочетается с соответствующим вторым, третьим, и
т.д. Аргументами; они должны согласовываться по числу и  ти-
пу; в противном случае Вы получите бессмысленные результаты.
    Между  прочим,  функция  printf не является частью языка
"C"; в самом языке "C" не определены операции  ввода-вывода.
Нет  ничего  таинственного и в функции printf ; это - просто
полезная функция, являющаяся частью  стандартной  библиотеки
подпрограмм,  которая  обычно доступна "C"-программам. Чтобы
сосредоточиться на самом языке, мы не будем  подробно  оста-
навливаться на операциях ввода-вывода до главы 7. В частнос-
ти, мы до тех пор отложим  форматный  ввод.  Если  вам  надо
ввести  числа - прочитайте описание функции scanf в главе 7,
раздел 7.4. Функция scanf во многом сходна с printf , но она
считывает входные данные, а не печатает выходные.

Упражнение  1-3.
    Преобразуйте  программу  перевода температур таким обра-
зом, чтобы она печатала заголовок к таблице.

Упражнение  1-4.
    Напишите программы печати соответствующей таблицы  пере-
хода от градусов цельсия к градусам фаренгейта.

1.3. Оператор for.

    Как  и  можно  было ожидать, имеется множество различных
способов написания каждой программы. Давайте рассмотрим  та-
кой вариант программы перевода температур:

 main()  /* fahrenheit-celsius table */
 {
    int fahr;
    for (fahr = 0; fahr <= 300; fahr = fahr + 20)
  printf("%4d %6.1f\n", fahr, (5.0/9.0)*(fahr-32.0));
 }

    Эта программа выдает те же самые результаты, но выглядит
безусловно по-другому. Главное изменение - исключение  боль-
шинства переменных; осталась только переменная fahr , причем
типа int (это сделано  для  того,  чтобы  продемонстрировать
преобразование %d в функции printf). Нижняя и верхняя грани-
цы и размер щага появляются только как константы в операторе
for  , который сам является новой конструкцией, а выражение,
вычисляющее температуру по Цельсию,  входит  теперь  в  виде
третьего  аргумента  функции printf , а не в виде отдельного
оператора присваивания.
    Последнее изменение является примером вполне общего пра-
вила  языка  "C"  - в любом контексте, в котором допускается
использование значения переменной некоторого типа, Вы можете
использовать  выражение  этого типа. Так как третий аргумент
функции printf должен иметь  значение  с  плавающей  точкой,
чтобы  соответствовать  спецификации  %6.1f, то в этом месте
может встретиться любое выражение плавающего типа.
    Сам оператор for - это оператор цикла, обобщающий опера-
тор  while. Его функционирование должно стать ясным, если Вы
сравните его с ранее описанным оператором while  .  Оператор
for содержит три части, разделяемые точкой с запятой. Первая
часть

fahr  = 0

выполняется один раз перед входом в сам цикл. Вторая часть -
проверка, или условие, которое управляет циклом:

 fahr <= 300

это  условие проверяется и, если оно истинно, то выполняется
тело цикла (в данном случае только функция printf  ).  Затем
выполняется шаг реинициализации

 fahr =fahr + 20

и условие проверяется снова. цикл завершается, когда это ус-
ловие становится ложным. Так же, как и  в  случае  оператора
while , тело цикла может состоять из одного оператора или из
группы операторов, заключенных в фигурные скобки.  Инициали-
зирующая  и  реинициализирующая  части могут быть любыми от-
дельными выражениями.
    Выбор между операторами while и for произволен и основы-
вается на том , что выглядит яснее. Оператор for обычно удо-
бен для циклов, в которых  инициализация  и  реинициализация
логически  связаны  и  каждая задается одним оператором, так
как в этом случае запись более компактна, чем при  использо-
вании оператора while , а операторы управления циклом сосре-
дотачиваются вместе в одном месте.

Упражнение  1-5.
    Модифицируйте программу перевода температур таким  обра-
зом,  чтобы она печатала таблицу в обратном порядке, т.е. от
300 градусов до 0.

1.4. Символические константы.

     Последнее замечание, прежде чем мы навсегда оставим
программу перевода температур. Прятать "магические числа",
такие как 300 и 20, внутрь программы - это неудачная практи-
ка; они дают мало информации тем, кто, возможно, должен будет
разбираться в этой программе позднее, и их трудно изменять
систематическим образом. К счастью в языке "C" предусмотрен
способ, позволяющий избежать таких "магических чисел". Ис-
пользуя конструкцию #define, Вы можете в начале программы оп-
ределить символическое имя или символическую константу, кото-
рая будет конкретной строкой символов. Впоследствии компиля-
тор заменит все не заключенные в кавычки появления этого име-
ни на соответствующую строку. Фактически это имя может быть
заменено абсолютно произвольным текстом, не обязательно циф-
рами

 #define  LOWER 0/* lower limit of table */
 #define  UPPER 300  /* upper limit */
 #define  STEP  20  /* step size */
 main () /* fahrenheit-celsius table */
 {
 int fahr;
for (fahr =lower; fahr <= upper; fahr =fahr + step)
  printf("%4d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
 }

величины  lower, upper и step являются константами и поэтому
они не указываются в описаниях. Символические  имена  обычно
пишут  прописными  буквами,  чтобы их было легко отличить от
написанных строчными буквами имен переменных. отметим, что в
конце определения не ставится точка с запятой. Так как подс-
тавляется вся строка, следующая за определенным  именем,  то
это  привело  бы  к слишком большому числу точек с запятой в
операторе for.

1.5. Набор полезных программ.

    Теперь мы собираемся рассмотреть  семейство  родственных
программ,  предназначенных  для  выполнения простых операций
над символьными данными. В  дальнейшем  Вы  обнаружите,  что
многие  программы  являются просто расширенными версиями тех
прототипов, которые мы здесь обсуждаем.

1.5.1. Ввод и вывод символов.

    Стандартная библиотека включает функции для чтения и за-
писи по одному символу за один раз. функция getchar() извле-
кает следующий вводимый символ каждый раз, как к ней обраща-
ются,  и  возвращает этот символ в качестве своего значения.
Это значит, что после

         c = getchar()

переменная 'c' содержит следующий символ из входных  данных.
Символы  обычно  поступают с терминала, но это не должно нас
касаться до главы 7.

    Функция putchar(c) является дополнением к  getchar  :  в
результате обращения

         putchar (c)

содержимое переменной 'c' выдается на некоторый выходной но-
ситель, обычно  опять  на  терминал.  Обращение  к  функциям
putchar и printf могут перемежаться; выдача будет появляться
в том порядке, в котором происходят обращения.
     Как и функция printf , функции getchar и putchar не со-
держат ничего экстраординарного. Они не входят в состав язы-
ка "C", но к ним всегда можно обратиться.

1.5.2. Копирование файла.

     Имея в своем  распоряжении  только  функции  getchar  и
putchar  Вы  можете,  не зная ничего более об операциях вво-
да-вывода, написать удивительное количество  полезных  прог-
рамм. Простейшим примером может служить программа посимволь-
ного копирования вводного файла в выводной. Общая схема име-
ет вид:

 ввести символ
 while (символ не является признаком конца файла)
   вывести только что прочитанный символ
   ввести новый символ


     Программа,  написанная на языке "C", выглядит следующим
образом:

  main()  /* copy input to output; 1st version */
  {
     int c;
     c = getchar();
     while (c != EOF) {
            putchar (c);
            c = getchar();
     }
  }

оператор отношения  !=  означает  "не равно".
     Основная проблема заключается в том,  чтобы  зафиксиро-
вать конец файла ввода. Обычно, когда функция getchar натал-
кивается на конец файла ввода, она возвращает значение ,  не
являющееся действительным символом; таким образом, программа
может установить, что файл ввода исчерпан. Единственное  ос-
ложнение, являющееся значительным неудобством, заключается в
существовании двух общеупотребительных соглашений о том, ка-
кое  значение  фактически является признаком конца файла. Мы
отсрочим решение этого  вопроса,  использовав  символическое
имя EOF для этого значения, каким бы оно ни было. На практи-
ке EOF будет либо -1, либо 0, так что для правильной  работы
перед программой должно стоять собственно либо

  #define  EOF  -1

либо

  #define  EOF   0

использовав  символическую  константу  EOF для представления
значения, возвращаемого функцией getchar при выходе на конец
файла,  мы  обеспечили, что только одна величина в программе
зависит от конкретного численного значения.
     Мы также описали переменную 'c' как int , а не char , с
тем чтобы она могла хранить значение, возвращаемое getchar .
как мы увидим в главе 2, эта величина действительно int, так
как она должна быть в состоянии в дополнение ко всем возмож-
ным символам представлять и EOF .
     Программистом, имеющим опыт работы  на  "C",  программа
копирования  была бы написана более сжато. В языке "C" любое
присваивание, такое как

c = getchar()

может быть использовано в выражении; его значение  -  просто
значение,  присваиваемое левой части. Если присваивание сим-
вола переменной 'c' поместить внутрь проверочной части  опе-
ратора  while  ,  то программа копирования файла запишется в
виде:

main()  /* copy input to output; 2nd version */
 {
 int c;

 while ((c = getchar()) != EOF)
 putchar(c);
 }

     Программа извлекает символ , присваивает его переменной
'c'  и затем проверяет, не является ли этот символ признаком
конца файла. Если нет - выполняется  тело  оператора  while,
выводящее  этот символ. Затем цикл while повторяется. когда,
наконец, будет достигнут конец файла ввода,  оператор  while
завершается, а вместе с ним заканчивается выполнение и функ-
ции main .
     В этой версии централизуется ввод - в программе  только
одно  обращение  к  функции getchar - и ужимается программа.
Вложение присваивания в проверяемое условие -  это  одно  из
тех  мест языка "C", которое приводит к значительному сокра-
щению программ. Однако, на этом пути можно увлечься и начать
писать недоступные для понимания программы. Эту тенденцию мы
будем пытаться сдерживать.
     Важно понять , что круглые скобки вокруг присваивания в
условном  выражении  действительно  необходимы.  Старшинство
операции != выше, чем операции присваивания =, а это означа-
ет,  что в отсутствие круглых скобок проверка условия != бу-
дет выполнена до присваивания =. Таким образом, оператор

 c = getchar()  != EOF

эквивалентен оператору

 c = (getchar() != EOF)

     Это, вопреки нашему желанию, приведет к тому,  что  'c'
будет  принимать значение 0 или 1 в зависимости от того, на-
толкнется или нет getchar на признак конца файла.  Подробнее
об этом будет сказано в главе 2/.
</pre>
</body>
</html>
