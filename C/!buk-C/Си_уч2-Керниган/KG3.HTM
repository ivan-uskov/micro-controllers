<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>

1.5.3. Подсчет символов.

     Следующая  программа  подсчитывает  число символов; она
представляет собой небольшое развитие программы копирования.

  main()  /* count characters in input */
  {
      long nc;

      nc = 0;
      while (getchar() != EOF )
     ++nc;
      printf("%1d\n", nc);
  }

  Оператор

  ++nc;

демонстрирует новую операцию, ++, которая означает  увеличе-
ние  на  единицу. Вы могли бы написать nc = nc + 1 , но ++nc
более кратко и зачастую более эффективно. Имеется соответст-
вующая  операция  -- уменьшение на единицу. Операции ++ и --
могут  быть  либо  префиксными  (++nc),  либо   постфиксными
(nc++); эти две формы, как будет показано в главе 2, имеют в
выражениях различные значения, но как ++nc, так и nc++  уве-
личивают  nc. Пока мы будем придерживаться префиксных опера-
ций.
     Программа подсчета символов накапливает их количество в
переменной типа long, а не int . На PDP-11 максимальное зна-
чение равно 32767, и если описать счетчик как int , то он
будет переполняться даже при сравнительно малом файле ввода;
на языке "C" для Honeywell и IBM типы long и int являются
синонимами и имеют значительно больший размер. Спецификация
преобразования %1d указывает printf, что соответствующий ар-
гумент является целым типа long.
     Чтобы справиться с еще большими числами, Вы можете  ис-
пользовать  тип  double / float двойной длины/. мы также ис-
пользуем оператор for вместо while с тем, чтобы проиллюстри-
ровать другой способ записи цикла.

  main()  /* count characters in input */
    {
        double  nc;

        for (nc = 0; getchar() != EOF; ++nc)
       ;
        printf("%.0f\n", nc);
    }

     Функция printf использует спецификацию %f как для float
, так и для double ; спецификация %.0f подавляет печать  не-
существующей дробной части.
     Тело оператора цикла for здесь пусто, так как вся рабо-
та выполняется в проверочной и  реинициализационной  частях.
Но  грамматические правила языка "C" требуют, чтобы оператор
for имел тело. Изолированная точка с запятой,  соответствую-
шая пустому оператору, появляется здесь, чтобы удовлетворить
этому требованию. Мы выделили ее на отдельную строку,  чтобы
сделать ее более заметной.
     Прежде чем мы распростимся с программой подсчета симво-
лов, отметим, что если файл ввода не содержит никаких симво-
лов, то условие в while или for не выполнится при самом пер-
вом обращении к getchar , и, следовательно ,  программа  вы-
даст  нуль, т.е. правильный ответ. это важное замечание. од-
ним из приятных свойств операторов while и for является  то,
что они проверяют условие в начале цикла, т.е. до выполнения
тела. Если делать ничего не надо, то ничего не будет  сдела-
но,  даже если это означает, что тело цикла никогда не будет
выполняться. Программы должны действовать разумно, когда они
обращаются  с  файлами  типа  "никаких  символов". Операторы
while и for помогают обеспечить правильное  поведение  прог-
рамм при граничных значениях проверяемых условий.

1.5.4. Подсчет строк.

     Следующая  программа  подсчитывает  количество  строк в
файле ввода. Предполагается, что строки ввода  заканчиваются
символом  новой  строки \n, скрупулезно добавленным к каждой
выписанной строке.

  main()  /* count lines in input */
   {
       int c,nl;

       nl = 0;
       while ((c = getchar()) != EOF)
      if (c =='\n')
          ++nl;
       printf("%d\n", nl);
  }

     Тело while теперь содержит оператор if , который в свою
очередь  управляет  оператором  увеличения ++nl. Оператор if
проверяет заключенное в круглые скобки условие и,  если  оно
истинно,  выполняет  следующий  за  ним оператор /или группу
операторов, заключенных в фигурные скобки/. Мы опять исполь-
зовали сдвиг вправо, чтобы показать, что чем управляет.
     Удвоенный  знак  равенства  ==  является обозначением в
языке "C" для "равно" /аналогично  .eq.  В  фортране/.  Этот
символ введен для того, чтобы отличать проверку на равенство
от одиночного =, используемого при присваивании. Поскольку в
типичных "C" - программах знак присваивания встречается при-
мерно в два раза чаще, чем проверка на равенство, то естест-
венно, чтобы знак оператора был вполовину короче.
     Любой  отдельный  символ может быть записан внутри оди-
ночных кавычек, и при этом ему соответствует значение,  рав-
ное численному значению этого символа в машинном наборе сим-
волов; это называется символьной константой. Так,  например,
'a'  -  символьная  константа; ее значение в наборе символов
ascii /американский стандартный код для обмена  информацией/
равно  65, внутреннему представлению символа а. Конечно, 'a'
предпочтительнее, чем 65: его смысл очевиден и он не зависит
от конкретного машинного набора символов.
     Условные  последовательности, используемые в символьных
строках, также занимают законное место среди символьных кон-
стант.  Так  в  проверках  и  арифметических выражениях '\n'
представляет значение символа новой строки. Вы должны твердо
уяснить,  что  '\n' - отдельный символ, который в выражениях
эквивалентен одиночному целому; с другой стороны "\n" -  это
символьная строка, которая содержит только один символ. Воп-
рос о сопоставлении строк и символов обсуждается в главе 2.

Упражнение  1-6.
     Напишите программу для подсчета пробелов,  табуляций  и
новых строк.

Упражнение  1-7.
     Напишите программу, которая копирует ввод на вывод, за-
меняя при этом каждую последовательность из одного или более
пробелов на один пробел.

1.5.5. Подсчет слов.

     Четвертая  программа  из  нашей серии полезных программ
подсчитывает количество строк, слов  и  символов,  используя
при этом весьма широкое определение, что словом является лю-
бая последовательность символов, не содержащая пробелов, та-
буляций  или  новых  строк. /Это - упрощенная версия утилиты
'wc' системы 'UNIX'/

  #define    YES  1
  #define    NO   0

  main()  /* count lines, words, chars in input */
  {
     int c, nl, nw, inword;

     inword = no;
     nl = nw = nc = 0;
     while((c = getchar()) != EOF)  {
         ++nc;
         if (c == '\n')
              ++nl;
         if (c==' ' || c=='\n' || c=='\t')
              inword = no;
         else if (inword == no)  {
              inword = yes;
              ++nw;
         }
     }
     printf("%d %d %d\n", nl, nw, nc);
  }

     Каждый раз, когда  программа  встречает  первый  символ
слова,  она увеличивает счетчик числа слов на единицу. Пере-
менная inword следит за тем, находится ли программа в насто-
ящий  момент  внутри  слова или нет; сначала этой переменной
присваивается " не в слове", чему соответствует значение no.
Мы  предпочитаем  символические  константы yes и no литерным
значениям 1 и 0, потому что они делают программу более удоб-
ной  для  чтения.  Конечно, в такой крошечной программе, как
эта, это не приводит к заметной разнице, но в больших  прог-
раммах увеличение ясности вполне стоит тех скромных дополни-
тельных усилий, которых требует следование этому принципу  с
самого начала. Вы также обнаружите, что существенные измене-
ния гораздо легче вносить в те программы, где числа  фигури-
руют только в качестве символьных констант.

Строка

  nl = nw = nc = 0;

полагает все три переменные равными нулю. Это не особый слу-
чай, а следствие того обстоятельства, что оператору присваи-
вания соответствует некоторое значение и присваивания прово-
дятся последовательно справа налево. Таким образом, дело об-
стоит так, как если бы мы написали

  nc = (nl = (nw = 0));

операция || Означает   or , так что строка

  if( c==' ' || c=='\n' || c=='\t')

говорит "если с - пробел, или с - символ новой строки, или с
-табуляция  ..."./условная  последовательность  \t  является
изображением символа табуляции/.
     Имеется соответствующая операция && для and. Выражения,
связанные операциями && или ||, рассматриваются слева напра-
во, и при этом гарантируется, что оценивание выражений будет
прекращено,  как только станет ясно, является ли все выраже-
ние истинным или ложным. Так, если 'c' оказывается пробелом,
то нет никакой необходимости проверять, является ли 'c' сим-
волом новой строки или табуляции, и такие проверки  действи-
тельно  не  делаются. В данном случае это не имеет принципи-
ального значения, но, как мы скоро увидим, в  более  сложных
ситуациях эта особенность языка весьма существенна.
     Этот пример также  демонстрирует  оператор  else  языка
"C",  который  указывает  то действие, которое должно выпол-
няться, если условие, содержащееся в операторе if,  окажется
ложным. Общая форма такова:

  if (выражение)
  оператор-1
  else оператор-2

выполняется один и только один из двух операторов, связанных
с конструкцией if-else. Если выражение истинно,  выполняется
оператор-1;  если  нет  - выполняется оператор-2. Фактически
каждый оператор может быть  довольно  сложным.  В  программе
подсчета слов оператор, следующий за else , является оперто-
ром if , который  управляет  двумя  операторами  в  фигурных
скобках.

Упражнение  1-9.
     Как бы Вы стали проверять программу подсчета слов ? Ка-
кие имеются ограничения ?

Упражнение  1-10.
     Напишите программу, которая  будет  печатать  слова  из
файла ввода, причем по одному на строку.

Упражнение  1-11.
     Переделайте  программу  подсчета слов, используя лучшее
определение "слова"; считайте,  например  словом  последова-
тельность букв, цифр и апострофов, начинающуюся с буквы.

1.6. Массивы.

     Давайте напишем программу подсчета числа появлений каж-
дой цифры, символов  пустых  промежутков/пробел,  табуляции,
новая  строка/ и всех остальных символов. Конечно, такая за-
дача несколько искусственна, но она позволит нам  проиллюст-
рировать  в  одной  программе сразу несколько аспектов языка
"C".
     Мы разбили вводимые символы на двенадцать категорий,  и
нам удобнее использовать массив для хранения числа появлений
каждой цифры, а не десять отдельных переменных. Вот один  из
вариантов программы:

  main()  /* count digits, white space, others */
  {
      int  c, i, nwhite, nother;
      int  ndigit[10];

      nwhite = nother = 0;
      for (i = 0; i < 10; ++i)
   ndigit[i] = 0;

      while ((c = getchar()) != EOF)
   if (c >= '0' && c <= '9')
       ++ndigit[c-'0'];
   else if(c== ' ' || c== '\n' || c== '\t')
       ++nwhite;
   else
       ++nother;

     printf("digits =");
      for (i = 0; i < 10; ++i)
     printf(" %d", ndigit[i]);
     printf("\nwhite space = %d, other = %d\n",
      nwhite, nother);
  }

Описание

  int  ndigit[10];

об'являет,  что  ndigit является массивом из десяти целых. в
языке "C" индексы массива всегда начинаются с нуля /а  не  с
1,  как в фортране или PL/1/, так что элементами массива яв-
ляются ndigit[0], ndigit[1],..., ndigit[9]. эта  особенность
отражена  в  циклах  for , которые инициализируют и печатают
массив.
     Индекс может быть любым целым выражением, которое,  ко-
нечно,  может включать целые переменные, такие как i , и це-
лые константы.
     Эта конкретная программа сильно опирается  на  свойства
символьного  представления  цифр. Так, например, в программе
проверка

  if( c >= '0' && c <= '9')...

Определяет, является ли символ в 'c' цифрой, и если это так,
то численное значение этой цифры определяется по формуле / c
- '0'/. Такой способ работает только в том случае, если зна-
чения символьных констант '0', '1' и т.д. Положительны, рас-
положены в порядке возрастания и  нет  ничего,  кроме  цифр,
между  константами  '0' и '9'. К счастью, это верно для всех
общепринятых наборов символов.
     По определению перед проведением арифметических  опера-
ций,  вовлекающих переменные типа char и int, все они преоб-
разуются к типу int, tak что в арифметических выражениях пе-
ременные  типа  char  по  существу идентичны переменным типа
int. Это вполне естественно и удобно; например, c -'0'-  это
целое  выражение  со  значением между 0 и 9 в соответствии с
тем, какой символ от '0' до '9' хранится в 'c', и,  следова-
тельно, оно является подходящим индексом для массива ndigit.
     Выяснение  вопроса,  является  ли данный символ цифрой,
символом пустого промежутка или чем-либо еще, осуществляется
последовательностью операторов

  if (c >= '0' && c <= '9')
  ++ndigit[c-'0'];
  else if(c == ' ' || c == '\n' || c == '\t')
  ++nwhite;
  else
  ++nother;

Конструкция

  if   (условие)
          оператор
  еlse if  (условие)
          оператор
  else
          оператор

часто встречаются в программах как средство выражения ситуа-
ций, в которых осуществляется  выбор  одного  из  нескольких
возможных решений.
     Программа  просто движется сверху вниз до тех пор, пока
не удовлетворится какое-нибудь  условие;  тогда  выполняется
соответствующий  'оператор',  и вся конструкция завершается.
/Конечно, 'оператор' может состоять из  нескольких  операто-
ров, заключенных в фигурные скобки/. Если ни одно из условий
не удовлетворяется, то выполняется 'оператор', стоящий после
заключительного  else, если оно присутствует. Если последнеe
else и соответствующий 'оператор' опущены (как  в  программе
подсчета  слов),  то никаких действий не производится. Между
начальным if и конечным else может  помещаться  произвольное
количество групп

  else if (условие)
     оператор

с  точки зрения стиля целесообразно записывать эту конструк-
цию так, как мы показали, с тем чтобы длинные  выражения  не
залезали за правый край страницы.

     Оператор switch (переключатель), который рассматривает-
ся в главе 3, представляет  другую  возможность  для  записи
разветвления  на несколько вариантов. этот оператор особенно
удобен, когда проверяемое выражение является либо просто не-
которым целым, либо символьным выражением, совпадающим с од-
ной из некоторого набора констант.  Версия  этой  программы,
использующая  оператор switch, будет для сравнения приведена
в главе 3.

Упражнение  1-12.
     Напишите программу, печатающую гистограмму длин слов из
файла  ввода.  Самое легкое - начертить гистограмму горизон-
тально; вертикальная ориентация требует больших усилий.

1.7. Функции.

     В языке "C" функции эквивалентны подпрограммам или фун-
кциям в фортране или процедурам в PL/1, Паскале и т.д. Функ-
ции дают удобный способ заключения некоторой части  вычисле-
ний  в черный ящик, который в дальнейшем можно использовать,
не интересуясь  его  внутренним  содержанием.  Использование
функций является фактически единственным способом справиться
с потенциальной сложностью больших  программ.  Если  функции
организованы  должным образом, то можно игнорировать то, как
делается работа; достаточно знание того, что делается.  Язык
"C"  разработан  таким  образом, чтобы сделать использование
функций легким, удобным и эффективным. Вам будут часто  вст-
речаться  функции длиной всего в несколько строчек, вызывае-
мые только один раз, и они используются только  потому,  что
это проясняет некоторую часть программы.
     До  сих  пор мы использовали только предоставленные нам
функции типа printf, getchar и putchar; теперь пора написать
несколько наших собственных. так как в "C" нет операции воз-
ведения в степень, подобной операции ** в фортране или PL/1,
давайте проиллюстрируем механику определения функции на при-
мере функции power(m,n), возводящей целое м в целую  положи-
тельную  степень n. Так значение power(2,5) равно 32. Конеч-
но, эта функция не выполняет всей работы операции  **,  пос-
кольку  она  действует только с положительными степенями не-
больших чисел, но лучше не создавать дополнительных  затруд-
нений, смешивая несколько различных вопросов.
     Ниже  приводится функция power и использующая ее основ-
ная программа, так что Вы можете видеть целиком всю структу-
ру.

  main()  /* test power function */
  {
     int i;

     for(i = 0; i < 10; ++i)
      printf("%d %d %d\n",i,power(2,i),power(-3,i));
  }

  power(x,n)  /* raise  x  n-th power; n > 0  */
  int x,n;
  {
     int i, p;
     p = 1;
     for (i =1; i <= n; ++i)
     p = p * x;
     return (p);
  }

     Все функции имеют одинаковый вид:

  имя (список аргументов, если они имеются)
  описание аргументов, если они имеются
  {
  описания
     операторы
  }

Эти функции могут быть записаны в любом порядке и находиться
в одном или двух исходных  файлах.  Конечно,  если  исходная
программа размещается в двух файлах, вам придется дать боль-
ше указаний при компиляции и загрузке, чем если бы она нахо-
дилась в одном, но это дело операционной системы, а не атри-
бут языка. В данный момент, для того  чтобы  все  полученные
сведения  о  прогоне "C"- программ, не изменились в дальней-
шем, мы будем предполагать, что обе функции находятся в  од-
ном и том же файле.
     Функция power вызывается дважды в строке

  printf("%d %d %d\n",i,power(2,i),power(-3,i));

при  каждом  обращении функция power, получив два аргумента,
вазвращает целое значение,  которое  печатается  в  заданном
формате. В выражениях power(2,i) является точно таким же це-
лым, как 2 и i. /Не все функции выдают  целое  значение;  мы
займемся этим вопросом в главе 4/.
     Аргументы  функции power должны быть описаны соответст-
вующим образом, так как их  типы  известны.  Это  сделано  в
строке

  int x,n;

которая следует за именем функции.

     Описания аргументов помещаются между списком аргументов
и открывающейся левой фигурной скобкой; каждое описание  за-
канчивается  точкой с запятой. Имена, использованные для ар-
гументов функции power, являются чисто локальными  и  недос-
тупны  никаким  другим  функциям: другие процедуры могут ис-
пользовать те же самые имена  без  возникновения  конфликта.
Это верно и для переменных i и p; i в функции power никак не
связано с i в функции main.
     Значение, вычисленное функцией power, передаются в main
с  помощью  оператора  return,  точно такого же, как в PL/1.
внутри круглых скобок можно написать любое выражение.  Функ-
ция  не  обязана  возвращать  какое-либо  значение; оператор
return, не содержащий никакого выражения, приводит  к  такой
же  передаче  управления,  как "сваливание на конец" функции
при достижении конечной правой фигурной скобки, но при  этом
в вызывающую функцию не возвращается никакого полезного зна-
чения.

Упражнение  1-13.
     Запишите программу  преобразования  прописных  букв  из
файла ввода в строчные, используя при этом функцию power(c),
которая возвращает значение 'c', если 'c'- не буква, и  зна-
чение соответствующей строчной буквы, если 'c'-буква.

1.8. Аргументы - вызов по значению.

     Один аспект в "C" может оказаться непривычным для прог-
раммистов, которые использовали другие языки,  в  частности,
фортран и PL/1. в языке "C" все аргументы функций передаются
"по значению". это означает, что вызванная функция  получает
значения  своих  аргументов  с  помощью временных переменных
/фактически через стек/, а не их адреса. Это приводит к  не-
которым особенностям, отличным от тех, с которыми мы сталки-
вались в языках типа Фортрана и PL/1, использующих "вызов по
ссылке  ",  где вызванная процедура работает с адресом аргу-
мента, а не с его значением.
     Главное отличие состоит в том, что в "C" вызванная фун-
кция не может изменить переменную из вызывающей функции; она
может менять только свою собственную временную копию.
     Вызов по значению, однако, не помеха, а  весьма  ценное
качество. Оно обычно приводит к более компактным программам,
содержащим меньше не относящихся к делу  переменных,  потому
что  с аргументами можно обращаться как с удобно инициализи-
рованными локальными перемнными  вызванной  процедуры.  Вот,
например, вариант функции power использующей это обстоятель-
ство

  power(x,n)  /* raise  x  n-th power; n > 0;
            version 2 */
  int x,n;
  {
  int p;

  for (p = 1; n > 0; --n)
       p = p * x;
  return (p);
  }

     Аргумент n используется как  временная  переменная;  из
него вычитается единица до тех пор, пока он не станет нулем.
Переменная i здесь больше не нужна. чтобы ни происходило с n
внутри power это никак не влияет на аргумент, с которым пер-
воначально обратились к функции power.
     При необходимости все же можно добиться, чтобы  функция
изменила  переменную  из вызывающей программы. Эта программа
должна обеспечить установление адреса переменной  /техничес-
ки,  через  указатель на переменную/, а в вызываемой функции
надо описать соответствующий аргумент как указатель  и  ссы-
латься к фактической переменной косвенно через него. Мы рас-
смотрим это подробно в главе 5.
     Когда в качестве аргумента выступает  имя  массива,  то
фактическим  значением, передаваемым функции, является адрес
начала массива. /Здесь нет  никакого  копирования  элементов
массива/. С помощью индексации и адреса начала функция может
найти и изменить любой элемент массива. Это - тема следующе-
го раздела.

1.9. Массивы символов.

     По-видимому  самым  общим  типом массива в "C" является
массив символов. Чтобы проиллюстрировать использование  мас-
сивов  символов и обрабатывающих их функций, давайте напишем
программу, которая читает набор строк и печатает самую длин-
ную из них. Основная схема программы достаточно проста:

  while (имеется еще строка)
    if (эта строка длиннее самой длинной из
    предыдущих)
       запомнить эту строку и ее длину
  напечатать самую длинную строку

     По  этой схеме ясно, что программа естественным образом
распадается на несколько частей.  Одна  часть  читает  новую
строку,  другая проверяет ее, третья запоминает, а остальные
части программы управляют этим процессом.
     Поскольку все так прекрасно делится, было бы  хорошо  и
написать  программу  соответсвующим образом. Давайте сначала
напишем отдельную функцию getline, которая  будет  извлекать
следующую  строку  из  файла  ввода; это - обобщение функции
getchar. мы попытаемся сделать эту  функцию  по  возможности
более  гибкой, чтобы она была полезной и в других ситуациях.
Как минимум getline должна передавать сигнал о возможном по-
явлении конца файла; более общий полезный вариант мог бы пе-
редавать длину строки или нуль, если встретится конец файла.
нуль  не может быть длиной строки, так как каждая строка со-
держит по крайней мере один символ; даже строка,  содержащая
только символ новой строки, имеет длину 1.
     Когда  мы находим строку, которая длиннее самой длинной
из предыдущих, то ее надо где-то запомнить. Это  наводит  на
мысль  о другой функции, copy , которая будет копировать но-
вую строку в место хранения.
     Наконец, нам нужна основная  программа  для  управления
функциями getline и copy . Вот результат :

  #define  MAXLINE  1000 /* maximum input
         line size */
   main()  /* find longest line */
   {
   int len; /* current line length */
   int max; /* maximum length seen so far */
   char line[maxline]; /* current input line */
   char save[maxline]; /* longest line, saved */
   max = 0;
   while ((len = getline(line, maxline)) > 0)
       if (len > max) {
      max = len;
      copy(line, save);
       }
       if (max > 0)   /* there was a line */
      printf("%s", save);
   }

   getline(s,lim) /* get line into s,return length */
   char s[];
   int lim;
   {
      int c, i;
   for(i=0;i<lim-1 && (c=getchar())!=EOF && c!='\n';++i)
      s[i] = c;
      if (c == '\n')  {
    s[i] = c;
    ++i;
      }
      s[i] = '\0';
      return(i);
   }

   copy(s1, s2)    /* copy s1 to s2;
                 assume s2 big enough */
   char s1[], s2[];
   {
   int i;
  i = 0;
   while ((s2[i] = s1[i] != '\0')
      ++i;
   }

     Функция main и getline общаются как через пару аргумен-
тов, так и через возвращаемое  значение.  аргументы  getline
описаны в строках

  char s[];
  int lim;

которые  указывают, что первый аргумент является массивом, а
второй - целым.

     Длина массива s не указана, так как  она  определена  в
main  . функция getline использует оператор return для пере-
дачи значения назад в вызывающую программу точно так же, как
это  делала функция power. Одни функции возвращают некоторое
нужное значение; другие, подобно copy, используются из-за их
действия и не возвращают никакого значения.
     Чтобы  пометить  конец строки символов, функция getline
помещает в конец создаваемого ей массива символ \0  /нулевой
символ,  значение  которого  равно нулю/. Это соглашение ис-
пользуется также компилятором с языка "C":  когда  в  "C"  -
программе встречается строчная константа типа

  "hello\n"

тo  компилятор  создает  массив символов, содержащий символы
этой строки, и заканчивает его символом \0, с тем чтобы фун-
кции, подобные printf, могли зафиксировать конец массива:

 -------------------------------------------
 |  h |  e  |  l  |  l  |  o  | \n  | \0 |
 -------------------------------------------

     Спецификация  формата  %s указывает, что printf ожидает
строку, представленную в такой форме. Проанализировав  функ-
цию  copy,  Вы  обнаружите, что и она опирается на тот факт,
что ее входной аргумент оканчивается символом \0, и копирует
этот  символ в выходной аргумент s2. /Все это подразумевает,
что символ \0 не является частью нормального текста/.
     Между прочим, стоит отметить, что даже в такой  малень-
кой программе, как эта, возникает несколько неприятных орга-
низационных проблем. Например, что должна делать main,  если
она  встретит  строку,  превышающую ее максимально возможный
размер ? Функция getline поступает разумно:  при  заполнении
массива  она прекращает дальнейшее извлечение символов, даже
если не встречает символа новой строки. Проверив  полученную
длину  и последний символ, функция main может установить, не
была ли эта строка слишком длинной, и поступить  затем,  как
она сочтет нужным. Ради краткости мы опустили эту проблему.
     Пользователь функции getline никак не может заранее уз-
нать, насколько длинной окажется вводимая строка. Поэтому  в
getline включен контроль переполнения. в то же время пользо-
ватель функции copy уже знает /или может узнать/, каков раз-
мер  строк,  так  что мы предпочли не включать в эту функцию
дополнительный контроль.

Упражнение  1-14.
     Переделайте ведущую часть программы поиска самой  длин-
ной строки таким образом, чтобы она правильно печатала длины
сколь угодно  длинных  вводимых  строк  и  возможно  больший
текст.

Упражнение   1-15.
     Напишите  программу печати всех строк длиннее 80 симво-
лов.

Упражнение  1-16.
     Напишите программу, которая  будет  удалять  из  каждой
строки  стоящие в конце пробелы и табуляции, а также строки,
целиком состоящие из пробелов.

Упражнение  1-17.
     Напишите функцию reverse(s), которая  распологает  сим-
вольную  строку  s в обратном порядке. С ее помощью напишите
программу, которая обратит каждую строку из файла ввода.

1.10. Область действия: внешние переменные.

     Переменные в main(line, save и т.д.) являются  внутрен-
ними  или локальными по отношению к функции main, потому что
они описаны внутри main и никакая другая функция не имеет  к
ним  прямого доступа. Это же верно и относительно переменных
в других функциях; например, переменная i в функции  getline
никак не связана с i в copy. Каждая локальная переменная су-
ществует только тогда, когда произошло обращение к соответс-
твующей  функции, и исчезает, как только закончится выполне-
ние этой функции. По этой причине такие  переменные,  следуя
терминологии других языков, обычно называют автоматическими.
Мы впредь будем использовать термин автоматические при ссыл-
ке  на эти динамические локальные переменные. /в главе 4 об-
суждается класс статической памяти, когда локальные перемен-
ные  все  же оказываются в состоянии сохранить свои значения
между обращениями к функциям/.
     Поскольку автоматические переменные появляются и  исче-
зают  вместе  с обращением к функции, они не сохраняют своих
значений в промежутке от одного вызова до  другого,  в  силу
чего  им  при  каждом входе нужно явно присваивать значения.
Если этого не сделать, то они будут содержать мусор.
     В качестве  альтернативы  к  автоматическим  переменным
можно определить переменные, которые будут внешними для всех
функций, т.е. глобальными переменными, к которым может обра-
титься по имени любая функция, которая пожелает это сделать.
(этот  механизм  весьма  сходен  с  "common"  в  фортране  и
"external" в PL/1). Так как внешние переменные доступны всю-
ду, их можно использовать вместо списка аргументов для пере-
дачи  данных  между функциями. Кроме того, поскольку внешние
переменные существуют постоянно, а не появляются и  исчезают
вместе  с вызываемыми функциями, они сохраняют свои значения
и после того, как функции, присвоившие им эти значения,  за-
вершат свою работу.
     Внешняя переменная должна быть определена вне всех фун-
кций; при этом ей выделяется фактическое место в памяти. Та-
кая  переменная  должна быть также описана в каждой функции,
которая собирается ее использовать; это можно  сделать  либо
явным  описанием  extern,  либо  неявным по контексту. Чтобы
сделать обсуждение более конкретным, давайте перепишем прог-
рамму  поиска  самой длинной строки, сделав line, save и max
внешними переменными. Это потребует изменения описаний и тел
всех трех функций, а также обращений к ним.

  #define MAXLINE 1000   /* max. input line size*/
  char   line[maxline];  /* input line */
  char   save[maxline];/* longest line saved here*/
  int   max;/*length of longest line seen so far*/

  main()  /*find longest line; specialized version*/
  {
     int     len;
     extern  int   max;
     extern  char   save[];
     max = 0;

  while ( (len = getline()) > 0 )
     if ( len > max )  {
             max = len;
             copy();
     }
  if ( max > 0 )  /* there was a line */
     printf( "%s", save );
  }

  getline()       /* specialized version */
  {
     int c, i;
     extern char line[];

     for (i = 0; i < maxline-1

         && (c=getchar()) !=EOF && c!='\n'; ++i)
              line[i] = c;
              ++i;
      }
      line[i] = '\0'
      return(i)
   }
   copy()  /* specialized version */
   {
      int i;
      extern char line[], save[];

      i = 0;
      while ((save[i] = line[i]) !='\0')
              ++i;
   }

     Внешние переменные для функций main, getline и copy оп-
ределены в первых строчках приведенного выше примера,  кото-
рыми указывается их тип и вызывается отведение для них памя-
ти. синтаксически внешние описания точно такие же, как  опи-
сания,  которые мы использовали ранее, но так как они распо-
ложены  вне  функций,  соответствующие  переменные  являются
внешними.  Чтобы  функция могла использовать внешнюю переме-
ную, ей надо сообщить ее имя.  Один  способ  сделать  это  -
включить  в функцию описание extern; это описание отличается
от предыдущих только добавлением ключевого слова extern.
     В определенных ситуациях  описание  extern  может  быть
опущено: если внешнее определение переменной находится в том
же исходном файле, раньше ее использования в некоторой конк-
ретной  функции,  то не обязательно включать описание extern
для этой переменной в саму функцию. Описания extern в  функ-
циях  main, getline и copy являются, таким образом, излишни-
ми. Фактически, обычная практика заключается в помещении оп-
ределений всех внешних переменных в начале исходного файла и
последующем опускании всех описаний extern.
     Если программа находится в нескольких исходных  файлах,
и  некоторая  переменная определена, скажем в файле 1, а ис-
пользуется в файле 2, то чтобы связать эти два вхождения пе-
ременной, необходимо в файле 2 использовать описание extern.
Этот вопрос подробно обсуждается в главе 4.
     Вы должно быть заметили, что  мы  в  этом  разделе  при
ссылке на внешние переменные очень аккуратно используем сло-
ва описание и определение. "Определение"  относится  к  тому
месту,  где  переменная фактически заводится и ей выделяется
память; "описание" относится к тем местам,  где  указывается
природа переменной, но никакой памяти не отводится.
     Между  прочим,  существует тенденция об'являть все, что
ни попадется, внешними переменными, поскольку  кажется,  что
это  упрощает связи, - списки аргументов становятся короче и
переменные всегда присутствуют, когда бы вам они ни  понадо-
бились. Но внешние переменные присутствуют и тогда, когда Вы
в них не нуждаетесь.  Такой  стиль  программирования  чреват
опасностью,  так  как он приводит к программам, связи данных
внутри которых не вполне очевидны. Переменные при этом могут
изменяться  неожиданным и даже неумышленным образом, а прог-
раммы становится трудно модифицировать, когда возникает  та-
кая  необходимость.  Вторая  версия  программы  поиска самой
длинной строки уступает первой отчасти по этим  причинам,  а
отчасти  потому,  что  она лишила универсальности две весьма
полезные функции, введя в них имена переменных,  с  которыми
они будут манипулировать.

Упражнение 1-18.
     Проверка в операторе for функции getline довольно неук-
люжа. Перепишите программу таким образом, чтобы сделать  эту
проверку  более ясной, но сохраните при этом то же самое по-
ведение в конце файла и при переполнении буфера. Является ли
это поведение самым разумным?

1.11. Резюме

     На  данном  этапе  мы обсудили то, что можно бы назвать
традиционным ядром языка "C". Имея эту  горсть  строительных
блоков, можно писать полезные программы весьма значительного
размера, и было бы вероятно неплохой идеей, если бы  Вы  за-
держались здесь на какое-то время и поступили таким образом:
следующие ниже упражнения предлагают вам ряд  программ  нес-
колько  большей  сложности, чем те, которые были приведены в
этой главе.
     После того как Вы овладеете этой частью "C", приступай-
те  к  чтению  следующих нескольких глав. Усилия, которые Вы
при этом затратите, полностью окупятся, потому  что  в  этих
главах обсуждаются именно те стороны "C", где мощь и вырази-
тельность языка начинает становиться очевидной.

Упражнение 1-19.
     Напишите программу detab, которая заменяет табуляции во
вводе  на нужное число пробелов так, чтобы промежуток дости-
гал следующей табуляционной остановки. Предположите фиксиро-
ванный набор табуляционных остановок, например, через каждые
n позиций.

Упражнение 1-20.
     Напишите программу entab, которая заменяет строки  про-
белов  минимальным числом табуляций и пробелов, достигая при
этом тех же самых промежутков. Используйте те же табуляцион-
ные остановки, как и в detab.

Упражнение 1-21.
     Напишите  программу  для  "сгибания"  длинных  вводимых
строк после последнего отличного от пробела символа, стояще-
го до столбца n ввода, где n - параметр. убедитесь, что ваша
программа делает что-то разумное с очень длинными строками и
в  случае,  когда перед указанным столбцом нет ни табуляций,
ни пробелов.

Упражнение 1-22.
     Напишите программу удаления из "C"-программы всех  ком-
ментариев. Не забывайте аккуратно обращаться с "закавыченны-
ми" строками и символьными константами.

Упражнение 1-23.
     Напишите программу проверки "C"-программы на элементар-
ные синтаксические ошибки, такие как несоответствие круглых,
квадратных и фигурных скобок. Не забудьте  о  кавычках,  как
одиночных,  так  и двойных, и о комментариях. (Эта программа
весьма сложна, если Вы будете писать ее  для  самого  общего
случая).


</pre>
</body>
</html>

