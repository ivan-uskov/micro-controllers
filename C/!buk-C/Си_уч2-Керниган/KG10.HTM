<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>
7. Ввод и вывод


     Средства ввода/вывода не являются составной частью язы-
ка "С", так что мы не выделяли их в нашем предыдущем изложе-
нии.  Однако реальные программы взаимодействуют со своей ок-
ружающей средой гораздо более сложным образом, чем мы видели
до  сих пор. В этой главе будет описана "стандартная библио-
тека ввода/вывода", то есть набор функций, разработанных для
обеспечения  стандартной системы ввода/вывода для "C"- прог-
рамм. Эти функции предназначены  для  удобства  программного
интерфейса,  и  все  же отражают только те операции, которые
могут быть обеспечены на большинстве современных  операцион-
ных  систем. Процедуры достаточно эффективны для того, чтобы
пользователи редко чувствовали необходимость обойти их "ради
эффективности",  как  бы ни была важна конкретная задача. И,
наконец, эти процедуры задуманы быть  "переносимыми"  в  том
смысле,  что  они  должны существовать в совместимом виде на
любой системе, где имеется язык "C", и что программы,  кото-
рые ограничивают свои взаимодействия с системой возможностя-
ми, предоставляемыми стандартной  библиотекой,  можно  будет
переносить с одной системы на другую по существу без измене-
ний.
     Мы здесь не будем пытаться описать всю библиотеку  вво-
да/вывода;  мы более заинтересованы в том, чтобы продемонст-
рировать сущность написания "C"-программ, которые взаимодей-
ствуют со своей операционной средой.

7.1. Обращение к стандартной библиотеке
     Каждый  исходный  файл, который обращается к функции из
стандартной библиотеки, должен вблизи начала содержать стро-
ку

  #include <stdio.h>

     В  файле stdio.h определяются некоторые макросы и пере-
менные, используемые библиотекой ввода/вывода. Использование
угловых  скобок  вместо  обычных  двойных кавычек - указание
компилятору искать этот файл в справочнике, содержащем заго-
ловки   стандартной   информации  (на  системе  UNIX  обычно
\usr\include).
     Кроме того, при загрузке программы может оказаться  не-
обходимым  указать  библиотеку явно; на системе PDP-11 UNIX,
например, команда компиляции программы имела бы вид:

  cc   исходные файлы и т.д. -ls

где -ls указывает на загрузку из стандартной библиотеки.

7.2. Стандартный ввод и вывод - функции getchar и putchar

     Самый простой механизм ввода заключается  в  чтении  по
одному символу за раз из "стандартного ввода", обычно с тер-
минала пользователя,  с  помощью  функции  getchar.  Функция
getchar()  при  каждом  к ней обращении возвращает следующий
вводимый символ. В большинстве  сред,  которые  поддерживают
язык "С", терминал может быть заменен некоторым файлом с по-
мощью обозначения < : если некоторая программа prog  исполь-
зует функцию getchar то командная строка

  prog<infile

приведет к тому, что prog будет читать из файла infile, а не
с терминала. Переключение ввода делается таким образом,  что
сама программа prog не замечает изменения; в частности стро-
ка"<infile" не включается в командную  строку  аргументов  в
argv. Переключение ввода оказывается незаметным и в том слу-
чае, когда вывод поступает из другой  программы  посредством
поточного (pipe) механизма; командная строка

  otherprog | prog

прогоняет две программы, otherprog и prog, и организует так,
что стандартным вводом для  prog  служит  стандартный  вывод
otherprog.
     Функция  getchar возвращает значение EOF, когда она по-
падает на конец файла, какой бы ввод она при этом не  считы-
вала. Стандартная библиотека полагает символическую констан-
ту EOF равной -1 (посредством #define в файле  stdio.h),  но
проверки следует писать в терминах EOF, а не -1, чтобы избе-
жать зависимости от конкретного значения.
     Вывод можно осуществлять с помощью функции  putchar(c),
помещающей символ 'с' в "стандартный ввод", который по умол-
чанию является терминалом. Вывод можно направить в некоторый
файл с помощью обозначения > : если prog использует putchar,
то командная строка

  prog>outfile

приведет к записи стандартного вывода в файл outfile,  а  не
на терминал. На системе UNIX можно также использовать поточ-
ный механизм. Строка

  prog | anotherprog

помещает  стандартный  вывод   prog   в   стандартный   ввод
anotherprog.  И опять prog не будет осведомлена об изменении
направления.
     Вывод, осуществляемый функцией printf, также  поступает
в  стандартный  вывод,  и обращения к putchar и printf могут
перемежаться.
     Поразительное количество программ читает только из  од-
ного  входного  потока и пишет только в один выходной поток;
для таких программ ввод и вывод с помощью  функций  getchar,
putchar и printf может оказаться вполне адекватным и для на-
чала определенно достаточным. Это особенно справедливо  тог-
да,  когда  имеется  возможность указания файлов для ввода и
вывода и поточный механизм для связи вывода одной  программы
с  вводом другой. Рассмотрим, например, программу lower, ко-
торая преобразует прописные буквы из своего ввода  в  строч-
ные:

  #include <stdio.h>

  main() /* convert input to lower case */
  {
   int c;

   while ((c = getchar()) != EOF)
      putchar(isupper(c) ? tolower(c) : c);
  }

     "Функции" isupper и tolower на самом деле являются мак-
росами, определенными в stdio.h . Макрос isupper  проверяет,
является ли его аргумент буквой из верхнего регистра, и воз-
вращает ненулевое значение, если это так, и нуль в противном
случае. Макрос tolower преобразует букву из верхнего регист-
ра в ту же букву нижнего регистра. Независимо от  того,  как
эти функции реализованы на конкретной машине, их внешнее по-
ведение совершенно одинаково, так что использующие их  прог-
раммы избавлены от знания символьного набора.
     Если требуется преобразовать несколько файлов, то можно
собрать эти файлы с помощью программы, подобной утилите  cat
системы UNIX,

  cat file1 file2 ... | lower>output

и  избежать  тем  самым вопроса о том, как обратиться к этим
файлам из программы. (Программа cat приводится позже в  этой
главе).
     Кроме  того  отметим, что в стандартной библиотеке вво-
да/вывода "функции" getchar и putchar на  самом  деле  могут
быть макросами. Это позволяет избежать накладных расходов на
обращение к функции для обработки каждого символа. В главе 8
мы продемонстрируем, как это делается.

7.3. Форматный вывод - функция printf

     Две  функции: printf для вывода и scanf для ввода (сле-
дующий раздел) позволяют преобразовывать численные  величины
в  символьное  представлeние  и обратно. Они также позволяют
генерировать и интерпретировать  форматные  строки.  Мы  уже
всюду  в  предыдущих главах неформально использовали функцию
printf; здесь приводится более  полное  и  точное  описание.
Функция

  printf(control, arg1, arg2, ...)

преобразует,  определяет  формат и печатает свои аргументы в
стандартный вывод под управлением строки control.  Управляю-
щая  строка содержит два типа об'ектов: обычные символы, ко-
торые просто копируются в  выходной  поток,  и  спецификации
преобразований,  каждая из которых вызывает преобразование и
печать очередного аргумента printf.
     Каждая спецификация преобразования начинается с символа
%  и заканчивается символом преобразования. Между % и симво-
лом преобразования могут находиться:

 - знак минус,  который  указывает  о  выравнивании
   преобразованного аргумента по  левому  краю  его
   поля.

 - Строка цифр, задающая минимальную ширину поля. Преобразо-
   ванное число будет напечатано в поле по крайней мере этой
   ширины, а если необходимо, то и  в  более  широком.  Если
   преобразованный  аргумент имеет меньше символов, чем ука-
   занная ширина поля, то он будет дополнен слева (или спра-
   ва,  если было указано выравнивание по левому краю)запол-
   няющими символами до этой  ширины.  Заполняющим  символом
   обычно  является пробел, а если ширина поля указывается с
   лидирующим нулем, то этим символом будет нуль (лидирующий
   нуль  в данном случае не означает восьмеричной ширины по-
   ля).

 - Точка, которая отделяет ширину поля от  следующей  строки
   цифр.

 -  Строка  цифр  (точность), которая указывает максимальное
   число символов строки, которые  должны  быть  напечатаны,
   или  число печатаемых справа от десятичной точки цифр для
   переменных типа float или double.

 - Модификатор длины l, который указывает, что соответствую-
   щий элемент данных имеет тип long, а не int.

     Ниже приводятся символы преобразования и их смысл:

 d
  - Аргумент преобразуется к десятичному виду.

 o
  - Аргумент преобразуется в беззнаковую восьмеричную  форму
    (без лидирующего нуля).

 x
  - Аргумент  преобразуется в беззнаковую шестнадцатеричную
    форму (без лидирующих 0x).

 u
  - Аргумент преобразуется в беззнаковую десятичную форму.

 c
  - Аргумент рассматривается как отдельный символ.

 s
  - Аргумент является строкой: символы строки печатаются  до
    тех  пор,  пока не будет достигнут нулевой символ или не
    будет напечатано количество символов, указанное в специ-
    фикации точности.

 e
  -  Аргумент, рассматриваемый как переменная типа float или
    double,  преобразуется  в  десятичную   форму   в   виде
    [-]m.nnnnnne[+-]xx,  где  длина строки из n определяется
    указанной точностью. Точность по умолчанию равна 6.

 f
  - Аргумент, рассматриваемый как переменная типа float  или
    double,   преобразуется   в   десятичную  форму  в  виде
    [-]mmm.nnnnn, где длина строки из n определяется указан-
    ной  точностью.  Точность по умолчанию равна 6. отметим,
    что эта точность не определяет количество  печатаемых  в
    формате f значащих цифр.

 g
  - Используется или формат %е или %f, какой короче; незна-
    чащие нули не печатаются.

     Если идущий за % символ не является символом преобразо-
вания, то печатается сам этот символ; следовательно,символ %
можно напечатать, указав %%.
     Большинство из форматных преобразований очевидно и было
проиллюстрировано в предыдущих главах. Единственным исключе-
нием является то, как точность взаимодействует со  строками.
Следующая  таблица  демонстрирует  влияние задания различных
спецификаций на печать "hello, world" (12 символов). Мы  по-
местили  двоеточия  вокруг  каждого  поля для того, чтобы Вы
могли видеть его протяженность.

  :%10s:          :hello, world:
  :%10-s:         :hello, world:
  :%20s:          :    hello, world:
  :%-20s:         :hello, world      :
  :%20.10s:       :      hello, wor:
  :%-20.10s:      :hello, wor      :
  :%.10s:         :hello, wor:

     Предостережение: printf использует свой первый аргумент
для определения числа последующих аргументов и их типов. Ес-
ли количество аргументов окажется недостаточным или они  бу-
дут иметь несоответственные типы, то возникнет путаница и Вы
получите бессмысленные результаты.

Упражнение 7-1.
Напишите программу, которая будет печатать разумным  образом
произвольный  ввод. Как минимум она должна печатать неграфи-
ческие символы в восьмеричном или шестнадцатеричном виде  (в
соответствии  с принятыми у Вас обычаями) и складывать длин-
ные строки.

7.4. Форматный ввод - функция scanf

     Осуществляющая ввод  функция  scanf  является  аналогом
printf  и  позволяет проводить в обратном направлении многие
из тех же самых преобразований. функция

  scanf(control, arg1, arg2, ...)

читает символы из стандартного ввода,  интерпретирует  их  в
соответствии  с  форматом,  указанном в аргументе control, и
помещает результаты в остальные аргументы. Управляющий аргу-
мент  описывается  ниже; другие аргументы, каждый из которых
должен быть указателем, определяют, куда  следует  поместить
соответствующим образом преобразованный ввод.
     Управляющая  строка обычно содержит спецификации преоб-
разования, которые используются для непосредственной интерп-
ретации  входных последовательностей. Управляющая строка мо-
жет содержать:

 - Пробелы, табуляции или  символы  новой  строки  ("символы
   пустых промежутков"), которые игнорируются.

 - Обычные символы (не %), которые предполагаются совпадаю-
   щими со следующими отличными от символов пустых промежут-
   ков символами входного потока.

 - Спецификации преобразования, состоящие из символа %, нео-
   бязательного символа подавления присваивания *,  необяза-
   тельного числа, задающего максимальную ширину поля и сим-
   вола преобразования.

     Спецификация преобразования  управляет  преобразованием
следующего  поля ввода. нормально результат помещается в пе-
ременную, которая  указывается  соответствующим  аргументом.
Если,  однако , с помощью символа * указано подавление прис-
ваивания, то это поле ввода просто пропускается  и  никакого
присваивания  не  производится.  Поле ввода определяется как
строка символов, которые отличны от символов простых  проме-
жутков;  оно продолжается либо до следующего символа пустого
промежутка, либо пока не будет исчерпана ширина  поля,  если
она  указана. Отсюда следует, что при поиске нужного ей вво-
да, функция scanf будет пересекать границы строк,  поскольку
символ новой строки входит в число пустых промежутков.
     Символ  преобразования  определяет  интерпретацию  поля
ввода; согласно требованиям основанной на вызове по значению
семантики  языка  "C"  соответствующий  аргумент должен быть
указателем. Допускаются следующие символы преобразования:

d
 - На вводе ожидается десятичное целое; соответствующий  ар-
   гумент должен быть указателем на целое.

o
 - На вводе ожидается восьмеричное целое (с лидирующим нулем
   или без него); соответствующий аргумент должен быть  ука-
   зателем на целое.

x
 - На вводе ожидается шестнадцатеричное целое (с лидирующими
   0x или без них);  соответствующий  аргумент  должен  быть
   указателем на целое.

h
 - На вводе ожидается целое типа short; соответсвующий аргу-
   мент должен быть указателем на целое типа short.

c
 - Ожидается отдельный символ; соответствующий аргумент дол-
   жен быть указателем на символы; следующий вводимый символ
   помещается в указанное место.  Обычный  пропуск  символов
   пустых  промежутков в этом случае подавляется; для чтения
   следующего символа, который не является символом  пустого
   промежутка, пользуйтесь спецификацией преобразования %1s.

s
 - Ожидается  символьная  строка;  соответствующий  аргумент
   должен  быть  указателем  символов,  который указывает на
   массив символов, который достаточно  велик  для  принятия
   строки и добавляемого в конце символа \0.

f
 - Ожидается число с плавающей точкой; соответствующий аргу-
   мент должен быть указателем на переменную типа float.

e
 - Символ преобразования e является синонимом для f.  Формат
   ввода переменной типа float включает необязательный знак,
   строку цифр, возможно содержащую десятичную точку и  нео-
   бязательное поле экспоненты, состоящее из буквы e, за ко-
   торой следует целое, возможно имеющее знак.

     Перед символами преобразования d, o и x может стоять l,
которая означает , что в списке аргументов должен находиться
указатель на переменную типа long, а не типа int.  Аналогич-
но,  буква  l  может стоять перед символами преобразования e
или f, говоря о том, что в списке  аргументов  должен  нахо-
диться указатель на переменную типа double, а не типа float.
     Например,  обращение  int  1;  float  x; char name[50];
scanf("&d %f %s", &i, &x, name);

со строкой на вводе

  25  54.32e-1   thompson

приводит к присваиванию i значения 25,x - значения  5.432  и
name  -  строки  "thompson",  надлежащим образом законченной
символом \0. эти три поля ввода  можно  разделить  столькими
пробелами,  табуляциями  и символами новых строк, сколько Вы
пожелаете. Обращение

  int  i;
  float x;
  char name[50];
  scanf("%2d %f %*d %2s", &i, &x, name);

с вводом

  56789 0123 45a72

присвоит i значение 56, x - 789.0, пропустит 0123 и поместит
в name строку "45". при следующем обращении к любой процеду-
ре ввода рассмотрение начнется с буквы a. В этих двух приме-
рах  name является указателем и, следовательно, перед ним не
нужно помещать знак &.
     В качестве другого примера перепишем теперь  элементар-
ный  калькулятор  из  главы  4, используя для преобразования
ввода функцию scanf:

  #include  <stdio.h>
  main()    /* rudimentary desk calculator */
  {
  double sum, v;
  sum =0;
  while (scanf("%lf", &v) !=EOF)
       printf("\t%.2f\n", sum += v);
  }

     Выполнение функции scanf заканчивается либо тогда, ког-
да она исчерпывает свою управляющую строку, либо когда неко-
торый элемент ввода не совпадает с управляющей  спецификаци-
ей. В качестве своего значения она возвращает число правиль-
но совпадающих и присвоенных элементов ввода. Это число  мо-
жет  быть  использовано для определения количества найденных
элементов ввода. при выходе на конец файла возвращается EOF;
подчеркнем,  что  это  значение  отлично от 0, что следующий
вводимый символ не удовлетворяет первой спецификации  в  уп-
равляющей  строке. При следующем обращении к scanf поиск во-
зобновляется непосредственно за последним  введенным  симво-
лом.
     Заключительное предостережение: аргументы функции scanf
должны быть указателями. Несомненно наиболее  распространен-
ная ошибка состоит в написании

  scanf("%d", n);

вместо

  scanf("%d", &n);

7.5. Форматное преобразование в памяти

     От  функции  scanf и printf происходят функции sscanf и
sprintf, которые осуществляют аналогичные преобразования, но
оперируют  со строкой, а не с файлом. Обращения к этим функ-
циям имеют вид:

  sprintf(string, control, arg1, arg2, ...)
  sscanf(string, control, arg1, arg2, ...)

     Как и раньше , функция sprintf преобразует  свои  аргу-
менты arg1, arg2 и т.д. В соответствии с форматом, указанным
в control, но помещает результаты в string, а не в стандарт-
ный вывод. Конечно, строка string должна быть достаточно ве-
лика, чтобы принять результат. Например,  если  name  -  это
символьный массив, а n - целое, то

  sprintf(name, "temp%d", n);

создает в name строку вида tempnnn, где nnn - значение n.
     Функция  sscanf выполняет обратные преобразования - она
просматривает строку string в соответствии с форматом в  ар-
гументе  control  и помещает результирующие значения в аргу-
менты arg1, arg2 и т.д.эти аргументы должны быть  указателя-
ми. в результате обращения

  sscanf(name, "temp%d", &n);

переменная  n  получает  значение  строки цифр, следующих за
temp в name.

Упражнение 7-2.
Перепишите настольный калькулятор из главы 4, используя  для
ввода и преобразования чисел scanf и/или sscanf.

7.6. Доступ к файлам

     Все до сих пор написанные программы читали из стандарт-
ного ввода и писали в стандартный вывод, относительно  кото-
рых мы предполагали, что они магическим образом предоставле-
ны программе местной операционной системой.
     Следующим шагом в вопросе ввода-вывода является написа-
ние  программы, работающей с файлом, который не связан зара-
нее с программой. одной из программ, которая явно демонстри-
рует  потребность  в  таких операциях, является cat, которая
об'единяет набор из нескольких именованных файлов в стандар-
тный  вывод. Программа cat используется для вывода файлов на
терминал и в  качестве  универсального  сборщика  ввода  для
программ,  которые  не имеют возможности обращаться к файлам
по имени. Например, команда

  cat x.c,y.c

печатает содержимое файлов x.c и y.c в стандартный вывод.
     Вопрос состоит в том, как организовать чтение из имено-
ванных  файлов,  т.е.,  как  связать внешние имена, которыми
мыслит пользователь, с фактически читающими данные  операто-
рами.
     Эти правила просты. Прежде чем можно считывать из неко-
торого файла или записывать в него, этот  файл  должен  быть
открыт  с  помощью  функции fopen из стандартной библиотеки.
функция fopen берет внешнее имя (подобное x.c или y.c), про-
водит некоторые обслуживающие действия и переговоры с опера-
ционной системой (детали которых не должны нас  касаться)  и
возвращает внутреннее имя, которое должно использоваться при
последующих чтениях из файла или записях в него.
     Это внутреннее имя, называемое "указателем файла", фак-
тически  является указателем структуры, которая содержит ин-
формацию о файле, такую как место размещения буфера, текущая
позиция  символа в буфере, происходит ли чтение из файла или
запись в него и тому подобное. Пользователи не обязаны знать
эти  детали,  потому  что среди определений для стандартного
ввода-вывода, получаемых из файла stdio.h, содержится  опре-
деление  структуры  с  именем file. Единственное необходимое
для указателя файла описание демонстрируется примером:

  file *fopen(), *fp;

     Здесь говорится, что fp является указателем на  file  и
fopen  возвращает  указатель на file. oбратите внимание, что
file является именем типа, подобным int, а не ярлыку  струк-
туры;  это  реализовано  как typedef. (Подробности того, как
все это работает на системе UNIX, приведены в главе 8).
     Фактическое обращение к функции fopen в программе имеет
вид:

  fp=fopen(name,mode);

     Первым  аргументом  функции fopen является "имя" файла,
которое задается в виде символьной строки.  Второй  аргумент
mode  ("режим")  также  является символьной строкой, которая
указывает, как этот файл будет  использоваться.  Допустимыми
режимами  являются:  чтение ("r"), запись ("w") и добавление
("a").
     Если Вы откроете файл, который еще  не  сущетвует,  для
записи  или добавления, то такой файл будет создан (если это
возможно). Открытие существующего файла на запись приводит к
отбрасыванию  его  старого содержимого. Попытка чтения несу-
ществующего файла является ощибкой. Ошибки могут быть  обус-
ловлены  и  другими  причинами (например, попыткой чтения из
файла, не имея на то  разрешения).  При  наличии  какой-либо
ошибки  функция  возвращает  нулевое значение указателя NULL
(которое для удобства также определяется в  файле  stdio.h).
     Другой необходимой вещью является способ чтения или за-
писи, если файл уже открыт. Здесь имеется несколько  возмож-
ностей,  из которых getc и putc являются простейшими.функция
getc возвращает следующий символ из файла; ей необходим ука-
затель файла, чтобы знать, из какого файла читать. Таким об-
разом,

  c=getc(fp)

помещает в "C" следующий символ из файла, указанного посред-
ством fp, и EOF, если достигнут конец файла.
     Функция putc, являющаяся обращением к функции getc,

  putc(c,fp)

помещает символ "C" в файл fp и возвращает "C". Подобно фун-
кциям getchar и putchar, getc и putc могут быть макросами, а
не функциями.
     При  запуске  программы  автоматически  открываются три
файла, которые снабжены  определенными  указателями  файлов.
Этими файлами являются стандартный ввод, стандартный вывод и
стандартный вывод ошибок; соответствующие  указатели  файлов
называются  stdin, stdout и stderr. Обычно все эти указатели
связаны с терминалом, но stdin и stdout могут быть  перенап-
равлены  на файлы или в поток (pipe), как описывалось в раз-
деле 7.2.
     Функции getchar и putchar могут быть определены в  тер-
миналах getc, putc, stdin и stdout следующим образом:

  #define getchar() getc(stdin)
  #define putchar(c)  putc(c,stdout)

     При работе с файлами для форматного ввода и вывода мож-
но использовать функции fscanf и fprintf. Они идентичны фун-
кциям  scanf и printf, за исключением того, что первым аргу-
ментом является указатель файла, определяющий тот файл,  ко-
торый будет читаться или куда будет вестись запись; управля-
ющая строка будет вторым аргументом.
     Покончив с предварительными замечаниями,  мы  теперь  в
состоянии  написать  программу  cat для конкатенации файлов.
Используемая здесь основная  схема  оказывается  удобной  во
многих  программах: если имеются аргументы в командной стро-
ке, то они обрабатываются последовательно. Если такие  аргу-
менты  отсутствуют,  то обрабатывается стандартный ввод. Это
позволяет использовать программу как самостоятельно,  так  и
как часть большей задачи.

  #include <stdio.h>
  main(argc, argv)   /*cat: concatenate files*/
  int argc;
  char *argv[];
  {
  file *fp, *fopen();
  if(argc==1) /*no args; copy standard input*/
  filecopy(stdin);
  else
  while (--argc > 0)
       if ((fp=fopen(*++argv,"r"))==NULL) {
          printf("cat:can't open %\n",*argv);
          break;
       } else {
          filecopy(fp);
          fclose(fp);
       }
   }
    filecopy(fp)  /*copy file fp to standard output*/
    file *fp;
    {
   int c;
   while ((c=getc(fp)) !=EOF)
   putc(c, stdout);
    }

     Указатели  файлов  stdin  и stdout заранее определены в
библиотеке ввода-вывода как стандартный ввод  и  стандартный
вывод;  они могут быть использованы в любом месте, где можно
использовать об'ект типа file*.они однако являются  констан-
тами,  а  не  переменными,  так что не пытайтесь им что-либо
присваивать.
     Функция fclose является обратной по отношению к  fopen;
она разрывает связь между указателем файла и внешним именем,
установленную функцией fopen, и высвобождает указатель файла
для  другого файла.большинство операционных систем имеют не-
которые ограничения на число одновременно  открытых  файлов,
которыми  может  распоряжаться программа. Поэтому, то как мы
поступили в cat, освободив не нужные нам более об'екты,  яв-
ляется  хорошей идеей. Имеется и другая причина для примене-
ния функции fclose к выходному файлу - она  вызывает  выдачу
информации  из  буфера,  в котором putc собирает вывод. (При
нормальном завершении работы программы функция fclose  вызы-
вается автоматически для каждого открытого файла).

7.7. Обработка ошибок - stderr и exit

     Обработка  ошибок в cat неидеальна. Неудобство заключа-
ется в том, что если один из  файлов  по  некоторой  причине
оказывается  недоступным,  диагностическое сообщение об этом
печатается в конце об'единенного вывода. Это приемлемо, если
вывод  поступает на терминал, но не годится, если вывод пос-
тупает в некоторый файл или через поточный (pipeline)  меха-
низм в другую программу.
     Чтобы  лучше  обрабатывать  такую ситуацию, к программе
точно таким же образом, как stdin и  stdout,  присоединяется
второй  выходной  файл,  называемый  stderr. Если это вообще
возможно, вывод, записанный в файле  stderr,  появляется  на
терминале  пользователя, даже если стандартный вывод направ-
ляется в другое место.
     Давайте переделаем программу cat таким  образом,  чтобы
сообщения об ошибках писались в стандартный файл ошибок.

  #include  <stdio.h>
  main(argc,argv)  /*cat: concatenate files*/
  int argc;
  char *argv[];
  {
  file *fp, *fopen();
  if(argc==1)  /*no args; copy standard input*/
  filecopy(stdin);
  else
  while (--argc > 0)
     if((fp=fopen(*++argv,"r#))==null) {
     printf(stderr,
       "cat: can't open,%s\n", argv);
     exit(1);
  } else {
     filecopy(fp);
  }
  exit(0);
   }

     Программа сообщает об ошибках двумя способами. Диагнос-
тическое сообщение, выдаваемое функцией fprintf, поступает в
stderr  и, таким образом, оказывается на терминале пользова-
теля, а не исчезает в потоке (pipeline) или в выходном  фай-
ле.
     Программа  также использует функцию exit из стандартной
библиотеки, обращение к которой вызывает завершение выполне-
ния программы. Аргумент функции exit доступен любой програм-
ме, обращающейся к данной функции, так что успешное или неу-
дачное завершение данной программы может быть проверено дру-
гой программой, использующей эту в  качестве  подзадачи.  По
соглашению величина 0 в качетсве возвращаемого значения сви-
детельствует о том, что все в порядке, а различные ненулевые
значения являются признаками нормальных ситуаций.
     Функция exit вызывает функцию fclose для каждого откры-
того выходного файла, с тем чтобы вывести всю  помещенную  в
буферы  выходную информацию, а затем вызывает функцию _exit.
Функция _exit приводит к немедленному завершению без очистки
каких-либо буферов; конечно, при желании к этой функции мож-
но обратиться непосредственно.

7.8. Ввод и вывод строк

     Стандартная библиотека содержит функцию  fgets,  совер-
шенно  аналогичную  функции getline, которую мы использовали
на всем протяжении книги. В результате обращения

  fgets(line, maxline, fp)

следующая строка ввода (включая символ новой строки)  считы-
вается  из  файла fp в символьный массив line; самое большое
maxline_1 символ будет прочитан. Результирующая  строка  за-
канчивается символом \ 0. Нормально функция fgets возвращает
line; в конце  файла  она  возвращает  NULL.  (Наша  функция
getline возвращает длину строки, а при выходе на конец файла
- нуль).
     Предназначенная для  вывода  функция  fputs  записывает
строку  (которая не обязана содержать символ новой строки) в
файл:

  fputs(line, fp)

     Чтобы показать, что в функциях типа fgets и  fputs  нет
ничего  таинственного,  мы  приводим их ниже, скопированными
непосредственно из стандартной библиотеки ввода-вывода:

  #include  <stdio.h>
  char *fgets(s,n,iop) /*get at most n chars from iop*/
  char *s;
  int n;
  register file *iop;
  {
  register int c;
  register char *cs;
  cs = s;
  while(--n>0&&(c=getc(iop)) !=EOF)
  if ((*cs++ = c)=='\n')
       break;
  *cs = '\0';
  return((c==EOF && cs==s) 7 NULL : s);
   }
   fputs(s,iop) /*put string s on fils iop*/
   register char *s;
   register file *iop;
   {
  register int c;
  while (c = *s++)
  putc(c,iop);
   }

Упражнение 7-3.
Напишите  программу сравнения двух файлов, которая будет пе-
чатать первую строку и позицию символа, где они различаются.

Упражнение 7-4.
Переделайте программу поиска заданной комбинации символов из
главы  5 таким образом, чтобы в качестве ввода использовался
набор именованных файлов или, если никакие файлы не  указаны
как  аргументы,  стандартный  ввод.  Следует ли печатать имя
файла при нахождении подходящей строки?

Упражнение 7-5.
Напишите программу печати набора  файлов,  которая  начинает
каждый  новый  файл  с новой страницы и печатает для каждого
файла заголовок и счетчик текущих страниц.

7.9. Несколько разнообразных функций

     Стандартная библиотека предоставляет множество разнооб-
разных  функций,  некоторые  из которых оказываются особенно
полезными. Мы уже упоминали функции для работы со  строками:
strlen, strcpy, strcat и strcmp. Вот некоторые другие.

7.9.1. Проверка вида символов и преобразования

     Некоторые  макросы выполняют проверку символов и преоб-
разования:

  isalpha(c) не 0, если "C" алфавитный символ,
             0 - если нет.
  isupper(c) Не 0, если "C" буква верхнего регистра,
             0 - если нет.
  islower(c) Не 0, если "C" буква нижнего регистра,
             0 - если нет.
  isdigit(c) Не 0, если "C" цифра,
             0 - если нет.
  isspacl(c) Не 0, если "C" пробел, табуляция
             или новая строка, 0 - если нет.
  toupper(c) Преобразует "C" в букву верхнего регистра.
  tolower(c) Преобразует "C" в букву нижнего регистра.

7.9.2. Функция ungetc

     Стандартная библиотека содержит  довольно  ограниченную
версию функции ungetch, написанной нами в главе 4; она назы-
вается ungetc. В результате обращения

  ungetc(c,fp)

символ "C" возвращается в файл fp. Позволяется возвращать  в
каждый  файл  только  один символ. Функция ungetc может быть
использована в любой из функций ввода  и  с  макросами  типа
scanf, getc или getchar.

7.9.3. Обращение к системе
     Функция  system(s)  выполняет  команду,  содержащуюся в
символьной строке s, и затем возобновляет выполнение текущей
программы.  Содержимое s сильно зависит от используемой опе-
рационной системы. В качестве тривиального примера,  укажем,
что на системе UNIX строка

  system("date");

приводит  к выполнению программы date, которая печатает дату
и время дня.

7.9.4. Управление памятью

     Функция calloc весьма сходна с функцией alloc,  исполь-
зованной нами в предыдущих главах. В результате обращения

  calloc(n, sizeof(object))

возвращается  либо  указатель пространства, достаточного для
размещения n об'ектов указанного размера,  либо  NULL,  если
запрос  не может быть удволетворен. Отводимая память инициа-
лизируется нулевыми значениями.
     Указатель обладает нужным для рассматриваемых  об'ектов
выравниванием,  но  ему  следует приписывать соответствующий
тип, как в

  char *calloc();
  int *ip;
  ip=(int*) calloc(n,sizeof(int));

     Функция cfree(p) освобождает пространство,  на  которое
указывает "p", причем указатель "p" певоначально должен быть
получен в результате обращения к calloc. Здесь  нет  никаких
ограничений  на  порядок освобождения пространства, но будет
неприятнейшей ошибкой освободить что-нибудь, что не было по-
лучено обращением к calloc.
     Реализация  программы  распределения  памяти,  подобной
calloc, в которой размещенные блоки  могут  освобождаться  в
произвольном порядке, продемонстрирована в главе 8.
</pre>
</body>
</html>
