<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>
5. Указатели и массивы

     Указатель - это переменная, содержащая адрес другой пе-
ременной. указатели очень широко используются в  языке  "C".
Это  происходит  отчасти потому, что иногда они дают единст-
венную возможность выразить нужное действие, а отчасти пото-
му,  что  они  обычно ведут к более компактным и эффективным
программам, чем те, которые могут быть получены другими спо-
собами.
     Указатели  обычно  смешивают  в одну кучу с операторами
goto, характеризуя их как чудесный  способ  написания  прог-
рамм, которые невозможно понять. Это безусловно справедливо,
если указатели используются беззаботно; очень просто  ввести
указатели,  которые указывают на что-то совершенно неожидан-
ное. Однако, при определенной дисциплине, использование ука-
зателей помогает достичь ясности и простоты. Именно этот ас-
пект мы попытаемся здесь проиллюстрировать.

5.1. Указатели и адреса

     Так как указатель содержит адрес об'екта, это дает воз-
можность  "косвенного"  доступа к этому об'екту через указа-
тель. Предположим, что х - переменная, например, типа int, а
рх  -  указатель, созданный неким еще не указанным способом.
Унарная операция & выдает адрес об'екта, так что оператор

  рх = &х;

присваивает адрес х переменной рх; говорят, что рх "указыва-
ет" на х. Операция & применима только к переменным и элемен-
там массива, конструкции вида &(х-1) и &3 являются  незакон-
ными. Нельзя также получить адрес регистровой переменной.
     Унарная операция * рассматривает свой операнд как адрес
конечной цели и обращается по этому  адресу,  чтобы  извлечь
содержимое. Следовательно, если y тоже имеет тип int, то

  y = *рх;

присваивает y содержимое того, на что указывает рх. Так пос-
ледовательность

  рх = &х;
  y = *рх;

присваивает y то же самое значение, что и оператор

  y = x;

переменные, участвующие во всем этом необходимо описать:

  int x, y;
  int *px;

с описанием для x и y мы уже  неодонократно  встречались.
Описание указателя

  int *px;

является  новым  и должно рассматриваться как мнемоническое;
оно говорит, что комбинация *px имеет тип int. Это означает,
что  если px появляется в контексте *px, то это эквивалентно
переменной типа int. Фактически синтаксис описания  перемен-
ной  имитирует синтаксис выражений, в которых эта переменная
может появляться. Это замечание  полезно  во  всех  случаях,
связанных со сложными описаниями. Например,

  double atof(), *dp;

говорит, что atof() и *dp имеют в выражениях  значения  типа
double.
     Вы должны также заметить, что из этого описания  следу-
ет, что указатель может указывать только на определенный вид
об'ектов.
     Указатели могут входить в выражения. Например, если  px
указывает  на  целое x, то *px может появляться в любом кон-
тексте, где может встретиться x. Так оператор

  y = *px + 1

присваивает y значение, на 1 большее значения x;

  printf("%d\n", *px)

печатает текущее значение x;

  d = sqrt((double) *px)

получает в d квадратный корень из x, причем до передачи фун-
кции  sqrt  значение  x преобразуется к типу double. (Смотри
главу 2).
     В выражениях вида

  y = *px + 1

унарные операции * и &  связаны  со  своим  операндом  более
крепко, чем арифметические операции, так что такое выражение
берет то значение, на которое указывает px, прибавляет  1  и
присваивает результат переменной y. Мы вскоре вернемся к то-
му, что может означать выражение

  y = *(px + 1)

     Ссылки  на  указатели  могут появляться и в левой части
присваиваний. Если px указывает на x, то

  *px = 0

полагает x равным нулю, а

  *px += 1

увеличивает его на единицу, как и выражение

  (*px)++

круглые скобки в последнем примере необходимы; если их опус-
тить, то поскольку унарные операции, подобные * и ++, выпол-
няются справа налево, это выражение увеличит px, а не ту пе-
ременную, на которую он указывает.
     И наконец, так как указатели являются переменными, то с
ними  можно обращаться, как и с остальными переменными. Если
py - другой указатель на переменную типа int, то

  py = px

копирует  содержимое px в py, в результате чего py указывает
на то же, что и px.

5.2. Указатели и аргументы функций

     Так  как в "C" передача аргументов функциям осуществля-
ется "по значению", вызванная процедура не имеет непосредст-
венной  возможности  изменить переменную из вызывающей прог-
раммы. Что же делать, если вам действительно  надо  изменить
аргумент?  Например,  программа сортировки захотела бы поме-
нять два нарушающих порядок элемента  с  помощью  функции  с
именем swap. Для этого недостаточно написать

  swap(a, b);

определив функцию swap при этом следующим образом:

  swap(x, y)      /* wrong */
  int x, y;
  {
     int temp;

     temp = x;
     x = y;
     y = temp;
  }

из-за  вызова  по  значению  swap не может воздействовать на
агументы a и b в вызывающей функции.
     К счастью, все же имеется возможность получить желаемый
эффект.  Вызывающая  программа передает указатели подлежащих
изменению значений:

  swap(&a, &b);

так как операция & выдает адрес переменной, то  &a  является
указателем на a. В самой swap аргументы описываются как ука-
затели и доступ к фактическим операндам осуществляется через
них.

  swap(px, py)    /* interchange *px and *py */
  int *px, *py;
  {
     int temp;

     temp = *px;
     *px = *py;
     *py = temp;
  }

     Указатели  в  качестве аргументов обычно используются в
функциях, которые должны возвращать более  одного  значения.
(Можно сказать, что swap вoзвращает два значения, новые зна-
чения ее аргументов). В качестве примера рассмотрим  функцию
getint,  которая  осуществляет  преобразование поступающих в
свободном формате данных, разделяя поток символов  на  целые
значения, по одному целому за одно обращение. Функция getint
должна возвращать либо найденное значение, либо признак кон-
ца  файла, если входные данные полностью исчерпаны. Эти зна-
чения должны возвращаться как отдельные  об'екты,  какое  бы
значение  ни  использовалось для EOF, даже если это значение
вводимого целого.
     Одно из решений, основывающееся на описываемой в  главе
7  функции  ввода  scanf, состоит в том, чтобы при выходе на
конец файла getint возвращала EOF в качестве значения  функ-
ции; любое другое возвращенное значение говорит о нахождении
нормального целого. Численное же значение найденного  целого
возвращается  через аргумент, который должен быть указателем
целого. Эта организация разделяет статус конца файла и  чис-
ленные значения.
     Следующий  цикл заполняет массив целыми с помощью обра-
щений к функции getint:

  int n, v, array[size];

  for (n = 0; n < size && getint(&v) != EOF; n++)
     array[n] = v;

в результате каждого обращения v становится равным следующе-
му целому значению, найденному во входных  данных.  Обратите
внимание, что в качестве аргумента getint необходимо указать
&v а не v. Использование просто v скорее  всего  приведет  к
ошибке адресации, поскольку getint полагает, что она работа-
ет именно с указателем.

     Сама getint является очевидной модификацией  написанной
нами ранее функции atoi:

  getint(pn)    /* get next integer from input */
  int *pn;
  {
    int c,sign;

    while ((c = getch()) == ' ' || c == '\n'
    || c == '\t'); /* skip white space */
    sign = 1;
    if (c == '+' || c == '-') { /* record
        sign */
       sign = (c == '+') ? 1 : -1;
       c = getch();
  }
  for (*pn = 0; c >= '0' && c <= '9'; c = getch())
     *pn = 10 * *pn + c - '0';
  *pn *= sign;
  if (c != EOF)
     ungetch(c);
  return(c);
  }

Выражение  *pn используется всюду в getint как обычная пере-
менная типа int.  Мы  также  использовали  функции  getch  и
ungetch  (описанные в главе 4) , так что один лишний символ,
кототрый приходится считывать, может быть помещен обратно во
ввод.

Упражнение 5-1.
Напишите функцию getfloat, аналог getint для чисел с плаваю-
щей точкой. Какой тип должна возвращать getfloat в  качестве
значения функции?

5.3. Указатели и массивы

     В языке "C" существует сильная взаимосвязь между указа-
телями и массивами , настолько сильная, что указатели и мас-
сивы действительно следует рассматривать одновременно. Любую
операцию, которую можно выполнить с помощью индексов  масси-
ва, можно сделать и с помощью указателей. Вариант с указате-
лями обычно оказывается более быстрым, но и несколько  более
трудным для непосредственного понимания, по крайней мере для
начинающего. Описание

  int a[10]

определяет массив размера 10, т.е. набор  из  10  последова-
тельных  об'ектов,  называемых a[0], a[1], ..., a[9]. Запись
a[i] соответствует элементу массива через i позиций от нача-
ла. Если pa - указатель целого, описанный как

  int *pa

то присваивание

  pa = &a[0]

приводит к тому, что pa указывает на нулевой элемент массива
a; это означает, что pa содержит адрес элемента a[0]. Теперь
присваивание

  x = *pa

будет копировать содержимое a[0] в x.
     Если  pa  указывает  на  некоторый определенный элемент
массива a, то по определению  pa+1  указывает  на  следующий
элемент,  и  вообще  pa-i указывает на элемент, стоящий на i
позиций до элемента, указываемого pa,  а  pa+i  на  элемент,
стоящий на i позиций после. Таким образом, если pa указывает
на a[0], то

  *(pa+1)

ссылается на содержимое a[1], pa+i - адрес a[i], а *(pa+i) -
содержимое a[i].
     Эти замечания справедливы независимо от типа переменных
в массиве a. Суть определения "добавления 1 к указателю",  а
также его распространения на всю арифметику указателей, сос-
тоит в том, что приращение масштабируется  размером  памяти,
занимаемой  об'ектом,  на который указывает указатель. Таким
образом, i в pa+i перед прибавлением  умножается  на  размер
об'ектов, на которые указывает pa.
     Очевидно,  существует  очень  тесное соответствие между
индексацией и  арифметикой  указателей.  В  действительности
компилятор преобразует ссылку на массив в указатель на нача-
ло массива. В результате этого имя массива  является  указа-
тельным  выражением. Отсюда вытекает несколько весьма полез-
ных следствий. Так как имя массива является синонимом место-
положения  его  нулевого  элемента, то присваивание pa=&a[0]
можно записать как

  pa = a

     Еще более  удивительным,  по  крайней  мере  на  первый
взгляд,  кажется тот факт, что ссылку на a[i] можно записать
в виде *(a+i). При анализировании выражения a[i] в языке "C"
оно  немедленно  преобразуется  к виду *(a+i); эти две формы
совершенно эквивалентны. Если применить операцию &  к  обеим
частям  такого  соотношения  эквивалентности, то мы получим,
что &a[i] и a+i тоже идентичны: a+i - адрес i-го элемента от
начала  a. С другой стороны, если pa является указателем, то
в выражениях его можно использовать с индексом: pa[i]  иден-
тично *(pa+i). Короче, любое выражение, включающее массивы и
индексы, может быть записано через указатели  и  смещения  и
наоборот, причем даже в одном и том же утверждении.
     Имеется  одно  различие между именем массива и указате-
лем, которое необходимо иметь в виду. указатель является пе-
ременной,  так  что операции pa=a и pa++ имеют смысл. Но имя
массива является константой, а  не  переменной:  конструкции
типа a=pa или a++,или p=&a будут незаконными.
     Когда  имя массива передается функции, то на самом деле
ей передается местоположение начала  этого  массива.  Внутри
вызванной функции такой аргумент является точно такой же пе-
ременной, как и любая другая, так что имя массива в качестве
аргумента  действительно  является указателем, т.е. перемен-
ной, содержащей адрес. мы можем использовать это обстоятель-
ство для написания нового варианта функции strlen, вычисляю-
щей длину строки.


  strlen(s)       /* return length of string s */
  char *s;
  {
     int n;

     for (n = 0; *s != '\0'; s++)
             n++;
     return(n);
  }

Операция увеличения s совершенно законна, поскольку эта  пе-
ременная  является  указателем;  s++ никак не влияет на сим-
вольную строку в обратившейся к  strlen  функции,  а  только
увеличивает локальную для функции strlen копию адреса.
     Описания  формальных параметров в определении функции в
виде

  char s[];
  char *s;

совершенно эквивалентны; какой вид описания следует  предпо-
честь,  определяется в значительной степени тем, какие выра-
жения будут использованы при написании функции. Если функции
передается  имя массива, то в зависимости от того, что удоб-
нее, можно полагать, что функция оперирует либо с  массивом,
либо  с  указателем, и действовать далее соответвующим обра-
зом. Можно даже использовать оба вида операций, если это ка-
жется уместным и ясным.
     Можно передать функции часть массива, если задать в ка-
честве аргумента указатель начала подмассива. Например, если
a - массив, то как

  f(&a[2])

так и

  f(a+2)

передают  функции f адрес элемента a[2], потому что и &a[2],
и a+2 являются указательными  выражениями,  ссылающимися  на
третий элемент a. внутри функции f описания аргументов могут
присутствовать в виде:

  f(arr)
  int arr[];
  {
     ...
  }

или

  f(arr)
  int *arr;
  {
     ...
  }

Что касается функции f, то тот факт, что ее аргумент в дейс-
твительности ссылается к части большего массива,не имеет для
нее никаких последствий.

5.4. Адресная арифметика

     Если p является указателем, то каков  бы  ни  был  сорт
об'екта, на который он указывает, операция p++ увеличивает p
так, что он  указывает  на  следующий  элемент  набора  этих
об'ектов,  а операция p +=i увеличивает p так, чтобы он ука-
зывал на элемент, отстоящий на i элементов от текущего  эле-
мента.эти и аналогичные конструкции представляют собой самые
простые и самые распространенные формы арифметики указателей
или адресной арифметики.
     Язык  "C"  последователен и постоянен в своем подходе к
адресной арифметике; об'единение в  одно  целое  указателей,
массивов  и  адресной  арифметики является одной из наиболее
сильных сторон языка. Давайте проиллюстрируем  некоторые  из
соответствующих  возможностей  языка на примере элементарной
(но полезной, несмотря на свою простоту) программы распреде-
ления  памяти. Имеются две функции: функция alloc(n) возвра-
щает в качестве своего значения указатель p, который  указы-
вает на первую из n последовательных символьных позиций, ко-
торые могут быть использованы вызывающей функцию alloc прог-
раммой  для  хранения  символов; функция free(p) освобождает
приобретенную таким образом память, так что ее в  дальнейшем
можно снова использовать. программа является "элементарной",
потому что обращения к free должны производиться в  порядке,
обратном  тому,  в  котором производились обращения к alloc.
Таким образом, управляемая функциями alloc и free память яв-
ляется стеком или списком, в котором последний вводимый эле-
мент извлекается первым. Стандартная  библиотека  языка  "C"
содержит  аналогичные функции, не имеющие таких ограничений,
и, кроме того, в главе 8 мы  приведем  улучшенные  варианты.
Между тем, однако, для многих приложений нужна только триви-
альная функция alloc для  распределения  небольших  участков
памяти неизвестных заранее размеров в непредсказуемые момен-
ты времени.
     Простейшая реализация состоит в том, чтобы функция раз-
давала  отрезки  большого  символьного  массива, которому мы
присвоили имя allocbuf. Этот массив является  собственностью
функций  alloc и free. Так как они работают с указателями, а
не с индексами массива,  никакой  другой  функции  не  нужно
знать  имя  этого  массива. Он может быть описан как внешний
статический, т.е. он будет локальным по отношению к исходно-
му  файлу, содержащему alloc и free, и невидимым за его пре-
делами. При практической реализации этот массив  может  даже
не иметь имени; вместо этого он может быть получен в резуль-
тате запроса к операционной системе на указатель  некоторого
неименованного блока памяти.
     Другой необходимой информацией является то, какая часть
массива allocbuf уже использована. Мы пользуемся  указателем
первого свободного элемента, названным allocp. Когда к функ-
ции alloc обращаются за выделением n символов, то она прове-
ряет, достаточно ли осталось для этого места в allocbuf. Ес-
ли достаточно, то alloc возвращает текущее  значение  allocp
(т.е.  начало свободного блока), затем увеличивает его на n,
с тем чтобы он указывал на следующую свободную область. Фун-
кция  free(p)  просто  полагает allocp равным p при условии,
что p указывает на позицию внутри allocbuf.


  define NULL 0  /* pointer value for error report */
  define allocsize 1000  /* size of available space */

  static char allocbuf[allocsize];/* storage for alloc */
  static char *allocp = allocbuf; /* next free position */

  char *alloc(n)  /* return pointer to n characters */
  int n;
  {
   if (allocp + n <= allocbuf + allocsize) {
      allocp += n;
      return(allocp - n); /* old p */
   } else         /* not enough room */
      return(NULL);
  }

  free(p)    /* free storage pointed by p */
  char *p;
  {
   if (p >= allocbuf && p < allocbuf + allocsize)
      allocp = p;
  }


     Дадим некоторые пояснения. Вообще говоря, указатель мо-
жет  быть  инициализирован  точно так же, как и любая другая
переменная, хотя обычно единственными осмысленными значения-
ми являются NULL (это обсуждается ниже) или выражение, вклю-
чающее адреса ранее определенных данных соответствующего ти-
па. Описание

  static char *allocp = allocbuf;

определяет  allocp как указатель на символы и инициализирует
его так, чтобы он указывал на allocbuf, т.е. на первую  сво-
бодную позицию при начале работы программы. Так как имя мас-
сива является адресом его нулевого элемента,  то  это  можно
было бы записать в виде

  static char *allocp = &allocbuf[0];

используйте  ту запись, которая вам кажется более естествен-
ной.
     С помощью проверки

  if (allocp + n <= allocbuf + allocsize)

выясняется, осталось ли достаточно места,  чтобы  удовлетво-
рить  запрос на n символов. Если достаточно, то новое значе-
ние allocp не будет указывать дальше, чем на последнюю пози-
цию  allocbuf. Если запрос может быть удовлетворен, то alloc
возвращает обычный указатель (обратите внимание на  описание
самой функции). Если же нет, то alloc должна вернуть некото-
рый признак, говорящий о том, что больше места не  осталось.
В  языке "C" гарантируется, что ни один правильный указатель
данных не может иметь значение нуль, так что возвращение ну-
ля  может служить в качестве сигнала о ненормальном событии,
в данном случае об отсутствии места. Мы, однако, вместо нуля
пишем  NULL, с тем чтобы более ясно показать, что это специ-
альное значение указателя. Вообще говоря, целые не могут ос-
мысленно  присваиваться указателям, а нуль - это особый слу-
чай.
     Проверки вида

  if (allocp + n <= allocbuf + aloocsize)
и
  if (p >= allocbuf && p < allocbuf + allocsize)

демонстрируют несколько важных аспектов арифметики  указате-
лей.  Во-первых  , при определенных условиях указатели можно
сравнивать. Если p и q указывают на элементы одного  и  того
же  массива,  то такие отношения, как <, >= и т.д., работают
надлежащим образом. Например,

  p < q

истинно, если p указывает на более ранний  элемент  массива,
чем q. Отношения == и != тоже работают. Любой указатель мож-
но осмысленным образом сравнить на равенство или неравенство
с  NULL.  Но  ни за что нельзя ручаться, если Вы используете
сравнения при работе с указателями, указывающими  на  разные
массивы.  Если  вам  повезет, то на всех машинах Вы получите
очевидную бессмыслицу. Если же нет, то ваша программа  будет
правильно работать на одной машине и давать непостижимые ре-
зультаты на другой.
     Во-вторых,  как  мы уже видели, указатель и целое можно
складывать и вычитать. Конструкция

  p + n

подразумевает n-ый об'ект за тем, на который p  указывает  в
настоящий момент. Это справедливо независимо от того, на ка-
кой вид об'ектов p должен указывать; компилятор сам  масшта-
бирует  n в соответствии с определяемым из описания p разме-
ром об'ектов, указываемых с помощью p. например,  на  PDP-11
масштабирующий  множитель  равен  1  для  char,  2 для int и
short, 4 для long и float и 8 для double.
     Вычитание указателей тоже возможно: если p и q указыва-
ют на элементы одного и того же массива, то p-q - количество
элементов между p и q. Этот факт можно использовать для  на-
писания еще одного варианта функции

  strlen:

   strlen(s)       /* return length of string s */
   char *s;
   {
      char *p = s;

      while (*p != '\0')
              p++;
      return(p-s);
   }


     При описании указатель p в этой функции инициализирован
посредством строки s, в результате чего он указывает на пер-
вый символ строки. В цикле while по очереди проверяется каж-
дый  символ до тех пор, пока не появится символ конца строки
\0. Так как значение \0 равно нулю, а while только выясняет,
имеет  ли выражение в нем значение 0, то в данном случае яв-
ную проверку можно опустить. Такие циклы часто записывают  в
виде

  while (*p)
     p++;

     Так  как p указывает на символы, то оператор p++ перед-
вигает p каждый раз так, чтобы он указывал на следующий сим-
вол.  В  результате  p-s  дает число просмотренных символов,
т.е. длину строки.  Арифметика  указателей  последовательна:
если  бы мы имели дело с переменными типа float, которые за-
нимают больше памяти, чем переменные типа char, и если бы  p
был  указателем на float, то оператор p++ передвинул бы p на
следующее float. таким образом, мы могли бы написать  другой
вариант  функции  alloc,  распределяющей  память  для float,
вместо char, просто заменив всюду в alloc и  free  описатель
char на float. Все действия с указателями автоматически учи-
тывают размер об'ектов, на которые они  указывают,  так  что
больше ничего менять не надо.
     За исключением упомянутых выше операций (сложение и вы-
читание указателя и целого, вычитание и сравнение двух  ука-
зателей), вся остальная арифметика указателей является неза-
конной. Запрещено складывать два  указателя,  умножать,  де-
лить,  сдвигать или маскировать их, а также прибавлять к ним
переменные типа float или double.

5.5. Указатели символов и функции

     Строчная константа, как, например,

  "i am a string"

является массивом символов. Компилятор завершает  внутреннее
представление  такого массива символом \0, так что программы
могут находить его конец. Таким образом, длина массива в па-
мяти  оказывается  на  единицу  больше  числа символов между
двойными кавычками.
     По-видимому чаще всего строчные константы появляются  в
качестве аргументов функций, как, например, в

  printf ("hello, world\n");

когда  символьная  строка, подобная этой, появляется в прог-
рамме, то доступ к ней осуществляется  с  помощью  указателя
символов;  функция printf фактически получает указатель сим-
вольного массива.
     Конечно,  символьные массивы не обязаны быть только ар-
гументами функций. Если описать message как

  char *message;

то в результате оператора

  message = "now is the time";

переменная message станет указателем на  фактический  массив
символов.  Это не копирование строки; здесь участвуют только
указатели. в языке "C" не предусмотрены какие-либо  операции
для обработки всей строки символов как целого.
     Мы проиллюстрируем другие аспекты указателей  и  масси-
вов, разбирая две полезные функции из стандартной библиотеки
ввода-вывода, которая будет рассмотрена в главе 7.
     Первая функция  -  это  strcpy(s,t),  которая  копирует
строку т в строку s. Аргументы написаны именно в этом поряд-
ке по аналогии с операцией  присваивания,  когда  для  того,
чтобы присвоить t к s обычно пишут

  s = t

сначала приведем версию с массивами:

  strcpy(s, t)    /* copy t to s */
  char s[], t[];
  {
     int i;
     i = 0;
     while ((s[i] = t[i]) != '\0')
             i++;
  }

     Для сопоставления ниже дается вариант strcpy с указате-
лями.

  strcpy(s, t)  /* copy t to s; pointer version 1 */
  char *s, *t;
  {
     while ((*s = *t) != '\0') {
             s++;
             t++;
     }
  }

так как аргументы передаются по значению, функция strcpy мо-
жет  использовать  s  и t так, как она пожелает. Здесь они с
удобством  полагаются  указателями,  которые   передвигаются
вдоль массивов, по одному символу за шаг, пока не будет ско-
пирован в s завершающий в t символ \0.
     На практике функция strcpy была бы записана не так, как
мы показали выше. Вот вторая возможность:

  strcpy(s, t)  /* copy t to s; pointer version 2 */
  char *s, *t;
  {
     while ((*s++ = *t++) != '\0')
            ;
  }

здесь увеличение s и t внесено в проверочную часть. Значени-
ем *t++ является символ, на который указывал t  до  увеличе-
ния; постфиксная операция ++ не изменяет t, пока этот символ
не будет извлечен. Точно так же  этот  символ  помещается  в
старую  позицию  s,  до того как s будет увеличено. Конечный
результат заключается в том, что все символы, включая завер-
шающий \0, копируются из t в s.
     И  как последнее сокращение мы опять отметим, что срав-
нение с \0 является излишним, так что функцию можно записать
в виде

  strcpy(s, t)  /* copy t to s; pointer version 3 */
  char *s, *t;
  {
     while (*s++ = *t++)
             ;
  }

хотя  с первого взгляда эта запись может показаться загадоч-
ной, она дает значительное удобство.  Этой  идиомой  следует
овладеть  уже хотя бы потому, что Вы с ней будете часто вст-
речаться в "C"-программах.
     Вторая функция - strcmp(s, t), которая сравнивает  сим-
вольные  строки  s и т, возвращая отрицательное, нулевое или
положительное значение в соответствии с тем,  меньше,  равно
или больше лексикографически s, чем t. Возвращаемое значение
получается в результате вычитания символов из  первой  пози-
ции, в которой s и t не совпадают.

  strcmp(s, t) /* return <0 if s<t, 0 if s==t, >0 if s>t */
  char s[], t[];
  {
   int i;

   i = 0;
   while (s[i] == t[i])
      if (s[i++] == '\0')
              return(0);
   return(s[i]-t[i]);
  }

Вот версия strcmp с указателями:

  strcmp(s, t) /* return <0 if s<t, 0 if s==t, >0 if s>t */
  char *s, *t;
  {
   for ( ; *s == *t; s++, t++)
      if (*s == '\0')
              return(0);
   return(*s-*t);
  }

     Так как ++ и -- могут быть как постфиксными, так и пре-
фиксными операциями, встречаются другие комбинации * и ++  и
--, хотя и менее часто.
     Например, *++p увеличивает p до извлечения символа,  на
который указывает p, а *--p сначала уменьшает p.

Упражнение 5-2.
Напишите  вариант  с  указателями функции strcat из главы 2:
strcat(s, t) копирует строку t в конец s.

Упражнение 5-3.
Напишите макрос для strcpy.

Упражнение 5-4.
Перепишите подходящие программы из предыдущих глав и  упраж-
нений, используя указатели вместо индексации массивов. Хоро-
шие возможности  для  этого  предоставляют  функции  getline
/главы  1  и  4/, atoi, itoa и их варианты /главы 2, 3 и 4/,
reverse /глава 3/, index и getop /глава 4/.

5.6. Указатели - не целые

     Вы, возможно, обратили внимание в предыдущих  "с"-прог-
раммах  на  довольно  непринужденное отношение к копированию
указателей. В общем это верно, что на большинстве машин ука-
затель можно присвоить целому и передать его обратно, не из-
менив его; при этом не происходит  никакого  масштабирования
или  преобразования  и ни один бит не теряется. к сожалению,
это ведет к вольному обращению  с  функциями,  возвращающими
указатели,  которые затем просто передаются другим функциям,
- необходимые описания указателей часто опускаются. Рассмот-
рим, например, функцию strsave(s), которая копирует строку s
в некоторое место для хранения, выделяемое посредством обра-
щения  к функции alloc, и возвращает указатель на это место.
Правильно она должна быть записана так:

  char *strsave(s) /* save string s somewhere */
  char *s;
  {
  char *p, *alloc();
  if ((p = alloc(strlen(s)+1)) != NULL)
           strcpy(p, s);
  return(p);
  }

на практике существует сильное стремление опускать описания:

  *strsave(s) /* save string s somewhere */
  {
  char *p;

  if ((p = alloc(strlen(s)+1)) != NULL)
         strcpy(p, s);
  return(p);
  }

эта программа будет правильно работать  на  многих  машинах,
потому что по умолчанию функции и аргументы имеют тип int, а
указатель и целое обычно можно безопасно пересылать  туда  и
обратно. Однако такой стиль программирования в своем сущест-
ве является рискованным, поскольку зависит от деталей реали-
зации  и  архитектуры машины и может привести к неправильным
результатам на конкретном используемом вами компиляторе. Ра-
зумнее всюду использовать полные описания. (Отладочная прог-
рамма lint предупредит о таких конструкциях, если они по не-
осторожности все же появятся).

5.7. Многомерные массивы

     В  языке  "C"  предусмотрены  прямоугольные многомерные
массивы, хотя на практике существует тенденция к  их  значи-
тельно  более редкому использованию по сравнению с массивами
указателей. В этом разделе мы рассмотрим некоторые их свойс-
тва.
     Рассмотрим задачу преобразования дня месяца в день года
и наоборот. Например, 1-ое марта является 60-м днем  невисо-
косного  года  и  61-м днем високосного года. Давайте введем
две функции для выполнения этих преобразований:  day_of_year
преобразует месяц и день в день года, а month_day преобразу-
ет день года в месяц и день. Так как эта  последняя  функция
возвращает  два  значения,  то аргументы месяца и дня должны
быть указателями:

  month_day(1977, 60, &m, &d)

полагает m равным 3 и d равным 1 (1-ое марта).
     Обе эти функции нуждаются в одной и той же информацион-
ной таблице, указывающей число дней в каждом месяце. Так как
число дней в месяце в високосном и в невисокосном году отли-
чается, то проще представить их в виде двух строк двумерного
массива, чем пытаться прослеживать во время вычислений,  что
именно  происходит  в феврале. Вот этот массив и выполняющие
эти преобразования функции:

  static int day_tab[2][13] = {
       (0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
       (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
  };

  day_of_year(year, month, day)      /* set day of year */
  int year, month, day;        /* from month & day */
  {
      int i, leap;
    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
      for (i = 1; i < month; i++)
   day += day_tab[leap][i];
      return(day);
  {

  month_day(year, yearday, pmonth, pday) /*set month,day */
  int year, yearday, *pmonth, *pday; /* from day of year */
  {
    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
      for (i = 1; yearday > day_tab[leap][i]; i++)
   yearday -= day_tab[leap][i];
      *pmonth = i;
      *pday = yearday;
  }

Массив day_tab должен быть внешним как для day_of_year,  так
и для month_day, поскольку он используется обеими этими фун-
кциями.
     Массив day_tab является первым  двумерным  массивом,  с
которым мы имеем дело. По определению в "C" двумерный массив
по существу является одномерным массивом, каждый элемент ко-
торого является массивом. Поэтому индексы записываются как

  day_tab[i][j]
а не
  day_tab [i, j]

как в большинстве языков. В остальном с двумерными массивами
можно в основном обращаться таким же образом, как  в  других
языках.  Элементы  хранятся по строкам, т.е. при обращении к
элементам в порядке их размещения в памяти быстрее всего из-
меняется самый правый индекс.
     Массив инициализируется с помощью списка начальных зна-
чений, заключенных в фигурные скобки; каждая строка  двумер-
ного массива инициализируется соответствующим подсписком. Мы
поместили в начало массива day_tab столбец из нулей для  то-
го,  чтобы номера месяцев изменялись естественным образом от
1 до 12, а не от 0 до 11. Так как за экономию памяти  у  нас
пока  не награждают, такой способ проще, чем подгонка индек-
сов.
     Если двумерный массив передается функции,  то  описание
соответствующего аргумента функции должно содержать количес-
тво столбцов; количество строк несущественно, поскольку, как
и  прежде, фактически передается указатель. В нашем конкрет-
ном случае это указатель об'ектов, являющихся  массивами  из
13  чисел типа int. Таким образом, если бы требовалось пере-
дать массив day_tab функции f, то описание в f имело бы вид:

  f(day_tab)
  int day_tab[2][13];
  {
     ...
  }

Так как количество строк является несущественным, то  описа-
ние аргумента в f могло бы быть таким:

  int day_tab[][13];

или таким

  int (*day_tab)[13];

в котором говорится, что аргумент является указателем масси-
ва из 13 целых. Круглые скобки здесь необходимы, потому  что
квадратные  скобки [] имеют более высокий уровень старшинст-
ва, чем *; как мы увидим в следующем  разделе,  без  круглых
скобок

  int *day_tab[13];

является описанием массива из 13 указателей на целые.

5.8. Массивы указателей; указатели указателей

     Так  как  указатели  сами  являются  переменными, то Вы
вполне могли бы ожидать  использования  массива  указателей.
Это  действительно  так.  Мы  проиллюстрируем это написанием
программы сортировки в алфавитном порядке  набора  текстовых
строк,  предельно упрощенного варианта утилиты sort операци-
онной систем UNIX.
     В главе 3 мы привели функцию сортировки по Шеллу, кото-
рая упорядочивала массив целых. Этот же алгоритм будет рабо-
тать и здесь, хотя теперь мы будем иметь дело  со  строчками
текста  различной длины, которые, в отличие от целых, нельзя
сравнивать или перемещать с помощью одной операции. Мы  нуж-
даемся  в  таком  представлении данных, которое бы позволяло
удобно и эффективно обрабатывать  строки  текста  переменной
длины.
     Здесь  и  возникают массивы указателей. Если подлежащие
сортировке сроки хранятся одна за другой в длинном  символь-
ном  массиве  (управляемом,  например, функцией alloc), то к
каждой строке можно обратиться с  помощью  указателя  на  ее
первый  символ.  Сами указатели можно хранить в массиве. Две
строки можно сравнить, передав их указатели функции  strcmp.
Если  две расположенные в неправильном порядке строки должны
быть переставлены, то фактически переставляются указатели  в
массиве указателей, а не сами тексты строк. Этим исключаются
сразу две связанные проблемы: сложного управления памятью  и
больших  дополнительных  затрат  на фактическую перестановку
строк.

  Процесс сортировки включает три шага:

    чтение всех строк ввода
    их сортировка
    вывод их в правильном порядке

Как обычно, лучше разделить программу на несколько функций в
соответствии с естественным делением задачи и выделить веду-
щую функцию, управляющую работой всей программы.
     Давайте отложим на некоторое  время  рассмотрение  шага
сортировки  и сосредоточимся на структуре данных и вводе-вы-
воде. Функция, осуществляющая ввод, должна  извлечь  символы
каждой  строки,  запомнить  их и построить массив указателей
строк. Она должна также подсчитать число строк во вводе, так
как  эта  информация необходима при сортировке и выводе. так
как функция ввода в состоянии справиться только  с  конечным
числом  вводимых  строк,  в случае слишком большого их числа
она может возвращать некоторое число, отличное от возможного
числа строк, например -1. Функция осуществляющая вывод, дол-
жна печатать строки в том порядке, в каком они появляются  в
массиве указателей.


  #define NULL 0
  #define LINES 100 /* max lines to be sorted */

  main()    /* sort input lines */
   {
   char *lineptr[lines]; /*pointers to text lines */
   int nlines;     /* number of input lines read */

   if ((nlines = readlines(lineptr, lines)) >= 0)  {
      sort(lineptr, nlines);
      writelines(lineptr, nlines);
    }
   else
      printf("input too big to sort\n");
   }

  #define MAXLEN 1000

  readlines(lineptr, maxlines) /* read input lines */
  char *lineptr[];       /* for sorting */
  int maxlines;
   {
   int len, nlines;
   char *p, *alloc(), line[maxlen];

   nlines = 0;
   while ((len = getline(line, maxlen)) > 0)
      if (nlines >= maxlines)
              return(-1);
      else if ((p = alloc(len)) == NULL)
              return (-1);
      else  {
           line[len-1] = '\0'; /* zap newline */
           strcpy(p,line);
           lineptr[nlines++] = p;
        }
    return(nlines);
    }


Символ новой строки в конце каждой строки удаляется, так что
он никак не будет влиять на порядок, в  котором  сортируются
строки.


  writelines(lineptr, nlines) /* write output lines */
  char *lineptr[];
  int nlines;
   {
   int i;

   for (i = 0; i < nlines; i++)
      printf("%s\n", lineptr[i]);
   }


     Существенно новым в этой программе является описание

  char *lineptr[lines];

которое  сообщает,  что  lineptr  является массивом из lines
элементов, каждый из которых - указатель на переменные  типа
char. Это означает, что lineptr[i] - указатель на символы, а
*lineptr[i] извлекает символ.
     Так как сам lineptr является массивом, который  переда-
ется функции writelines, с ним можно обращаться как с указа-
телем точно таким же образом, как в наших более ранних  при-
мерах. Тогда последнюю функцию можно переписать в виде:

  writelines(lineptr, nlines) /* write output lines */
  char *lineptr[];
  int nlines;
   {
   int i;

   while (--nlines >= 0)
      printf("%s\n", *lineptr++);
   }


здесь  *lineptr  сначала  указывает на первую строку; каждое
увеличение передвигает указатель на следующую строку,  в  то
время как nlines убывает до нуля.
     Справившись с вводом и выводом, мы можем перейти к сор-
тировке. программа сортировки по Шеллу из  главы  3  требует
очень небольших изменений: должны быть модифицированы описа-
ния, а операция сравнения выделена в отдельную функцию.  Ос-
новной  алгоритм остается тем же самым, и это дает нам опре-
деленную уверенность, что он по-прежнему будет работать.

  sort(v, n)   /* sort strings v[0] ... v[n-1] */
  char *v[];   /* into increasing order */
  int n;
   {
   int gap, i, j;
   char *temp;

   for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
      for (j = i - gap; j >= 0; j -= gap)  {
          if (strcmp(v[j], v[j+gap]) <= 0)
              break;
          temp = v[j];
          v[j] = v[j+gap];
          v[j+gap] = temp;
       }
   }

Так  как каждый отдельный элемент массива v (имя формального
параметра, соответствующего lineptr) является указателем  на
символы,  то и temp должен быть указателем на символы, чтобы
их было можно копировать друг в друга.
     Мы написали эту программу по возможности более просто с
тем, чтобы побыстрее получить работающую программу. Она мог-
ла бы работать быстрее, если, например, вводить  строки  не-
посредственно в массив, управляемый функцией readlines, а не
копировать их в line, а затем в скрытое место с помощью фун-
кции alloc. но мы считаем, что будет разумнее первоначальный
вариант сделать более простым для понимания, а об "эффектив-
ности"  позаботиться  позднее.  Все же, по-видимому, способ,
позволяющий добиться заметного  ускорения  работы  программы
состоит  не в исключении лишнего копирования вводимых строк.
Более вероятно, что существенной разницы  можно  достичь  за
счет  замены  сортировки по Шеллу на нечто лучшее, например,
на метод быстрой сортировки.
     В главе 1 мы отмечали, что поскольку в циклах  while  и
for  проверка  осуществляется до того, как тело цикла выпол-
нится хотя бы один раз, эти циклы оказываются  удобными  для
обеспечения правильной работы программы при граничных значе-
ниях, в частности, когда ввода  вообще  нет.  Очень  полезно
просмотреть  все  функции  программы сортировки, разбираясь,
что происходит, если вводимый текст отсутствует.

Упражнение 5-5.
Перепишите функцию readlines таким образом, чтобы она  поме-
щала  строки в массив, предоставляемый функцией main, а не в
память, управляемую обращениями к функции  alloc.  Насколько
быстрее стала программа?

5.9. Инициализация массивов указателей

     Рассмотрим  задачу написания функции month_name(n), ко-
торая возвращает указатель на символьную строку,  содержащую
имя  n-го  месяца. Это идеальная задача для применения внут-
реннего статического массива.  Функция  month_name  содержит
локальный массив символьных строк и при обращении к ней воз-
вращает указатель нужной строки. Тема настоящего  раздела  -
как инициализировать этот массив имен.

  char *month_name(n) /* return name of n-th month */
  int n;
   {
   static char *name[] =  {
      "illegal month",
      "january",
      "february",
      "march",
      "april",
      "may",
      "jun",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"
    };
       return ((n < 1 || n > 12) ? name[0] : name[n]);
   }

Описание  массива указателей на символы name точно такое же,
как аналогичное описание lineptr в  примере  с  сортировкой.
Инициализатором  является  просто  список  символьных строк;
каждая строка присваивается соответствующей позиции в масси-
ве.  Более  точно, символы i-ой строки помещаются в какое-то
иное место, а ее указатель  хранится  в  name[i].  Поскольку
размер  массива  name не указан, компилятор сам подсчитывает
количество инициализаторов  и  соответственно  устанавливает
правильное число.

5.10. Указатели и многомерные массивы

     Начинающие  изучать  язык "с" иногда становятся в тупик
перед вопросом о различии между двумерным массивом и  масси-
вом  указателей,  таким как name в приведенном выше примере.
Если имеются описания

  int a[10][10];
  int *b[10];

то а и в можно использовать сходным образом  в  том  смысле,
что  как  a[5][5], так и b[5][5] являются законными ссылками
на отдельное число типа int. Но а -  настоящий  массив:  под
него отводится 100 ячеек памяти и для нахождения любого ука-
занного элемента проводятся обычные вычисления с прямоуголь-
ными  индексами.  Для b, однако, описание выделяет только 10
указателей; каждый указатель  должен  быть  установлен  так,
чтобы  он  указывал  на массив целых. если предположить, что
каждый из них указывает на массив из 10 элементов, то  тогда
где-то будет отведено 100 ячеек памяти плюс еще десять ячеек
для указателей. Таким образом, массив указателей  использует
несколько больший об'ем памяти и может требовать наличие яв-
ного шага инициализации. Но при этом возникают  два  преиму-
щества: доступ к элементу осуществляется косвенно через ука-
затель, а не посредством умножения и сложения, и строки мас-
сива  могут  иметь различные длины. Это означает, что каждый
элемент в не должен обязательно указывать на  вектор  из  10
элементов;  некоторые могут указывать на вектор из двух эле-
ментов, другие - из двадцати, а третьи могут  вообще  ни  на
что не указывать.
     Хотя мы вели это обсуждение в терминах целых, несомнен-
но, чаще всего массивы указателей используются так,  как  мы
продемонстрировали  на  функции  month_name,  - для хранения
символьных строк различной длины.


Упражнение 5-6.
Перепишите функции day_of_year и month_day, используя вместо
индексации указатели.

5.11. Командная строка аргументов

     Системные  средства,  на  которые  опирается реализация
языка "с", позволяют передавать командную строку  аргументов
или параметров начинающей выполняться программе. Когда функ-
ция main вызывается к исполнению, она вызывается с двумя ар-
гументами.  Первый аргумент (условно называемый argc) указы-
вает число аргументов в командной строке, с которыми  проис-
ходит обращение к программе; второй аргумент (argv) является
указателем на массив символьных строк, содержащих эти  аргу-
менты,  по  одному  в строке. Работа с такими строками - это
обычное использование многоуровневых указателей.
     Самую простую иллюстрацию этой возможности и  необходи-
мых  при  этом  описаний дает программа echo, которая просто
печатает в одну строку аргументы командной строки,  разделяя
их пробелами. Таким образом, если дана команда

  echo hello, world

то выходом будет

  hello, world

по соглашению argv[0] является именем, по которому вызывает-
ся программа, так что argc по меньшей мере равен 1. В приве-
денном  выше  примере  argc  равен  3,  а argv[0], argv[1] и
argv[2] равны соответственно  "echo",  "hello,"  и  "world".
Первым фактическим агументом является argv[1], а последним -
argv[argc-1]. Если argc равен 1, то за именем  программы  не
следует никакой командной строки аргументов. Все это показа-
но в echo:

  main(argc, argv) /* echo arguments; 1st version */
  int argc;
  char *argv[];
   {
     int i;

     for (i = 1; i < argc; i++)
   printf("%s%c", argv[i], (i<argc-1) ? ' ' : '\n');
   }

Поскольку  argv является указателем на массив указателей, то
существует несколько способов написания этой программы,  ис-
пользующих  работу с указателем, а не с индексацией массива.
Мы продемонстрируем два варианта.

  main(argc, argv) /* echo arguments; 2nd version */
  int argc;
  char *argv[];
  {
    while (--argc > 0)
  printf("%s%c",*++argv, (argc > 1) ? ' ' : '\n');
  }

Так как argv является указателем на начало массива строк-ар-
гументов,  то,  увеличив его на 1 (++argv), мы вынуждаем его
указывать на подлинный аргумент argv[1], а  не  на  argv[0].
Каждое  последующее  увеличение передвигает его на следующий
аргумент; при этом *argv становится указателем на этот аргу-
мент.  одновременно величина argc уменьшается; когда она об-
ратится в нуль, все аргументы будут уже напечатаны.
     Другой вариант:

  main(argc, argv) /* echo arguments; 3rd version */
  int argc;
  char *argv[];
   {
     while (--argc > 0)
   printf((argc > 1) ? "%s" : "%s\n", *++argv);
   }

Эта версия показывает, что аргумент формата  функции  printf
может быть выражением, точно так же, как и любой другой. Та-
кое использование встречается не очень часто, но его все  же
стоит запомнить.
     Как второй пример, давайте внесем некоторые усовершенс-
твования в программу отыскания заданной комбинации  символов
из главы 4. Если Вы помните, мы поместили искомую комбинацию
глубоко внутрь программы, что очевидно  является  совершенно
неудовлетворительным.  Следуя утилите grep системы UNIX, да-
вайте изменим программу так, чтобы эта  комбинация  указыва-
лась в качестве первого аргумента строки.

  #define MAXLINE 1000

  main(argc, argv) /* find pattern from first argument */
  int argc;
  char *argv[];
   {
   char line[maxline];

   if (argc != 2)
      printf ("usage: find pattern\n");
   else
    while (getline(line, maxline) > 0)
          if (index(line, argv[1] >= 0)
              printf("%s", line);
   }

     Теперь может быть развита основная модель, иллюстрирую-
щая дальнейшее использование  указателей.  Предположим,  что
нам  надо  предусмотреть  два необязательных аргумента. Один
утверждает: "напечатать все строки за исключением тех, кото-
рые  содержат данную комбинацию", второй гласит: "перед каж-
дой выводимой строкой должен печататься ее номер".
     Общепринятым соглашением в "с"-программах является  то,
что  аргумент,  начинающийся со знака минус, вводит необяза-
тельный признак или параметр. Если мы, для того, чтобы сооб-
щить  об  инверсии,  выберем  -x, а для указания о нумерации
нужных строк выберем -n("номер"), то команда

  find -x -n the

при входных данных

  now is the time
  for all good men
  to come to the aid
  of their party.

Должна выдать

  2:for all good men

     Нужно, чтобы необязательные  аргументы  могли  распола-
гаться в произвольном порядке, и чтобы остальная часть прог-
раммы не зависела от  количества  фактически  присутствующих
аргументов.  в  частности, вызов функции index не должен со-
держать ссылку на argv[2], когда присутствует один  необяза-
тельный  аргумент,  и на argv[1], когда его нет. Более того,
для пользователей  удобно,  чтобы  необязательные  аргументы
можно было об'единить в виде:

  find -nx the

вот сама программа:


  #define MAXLINE 1000

  main(argc, argv) /* find pattern from first argument */
  int argc;
  char *argv[];
   {
   char line[maxlin!], *s;
   long lineno = 0;
   int except = 0, number = 0;
   while (--argc > 0 && (*++argv)[0] == '-')
      for (s = argv[0]+1; *s != '\0'; s++)
              switch (*s)  {
              case 'x':
       except = 1;
       break;
              case 'n':
       number = 1;
       break;

             default:
     printf("find: illegal option %c\n", *s);
     argc = 0;
     break;
              }
  if (argc != 1)
      printf("usage: find -x -n pattern\n");
  else
      while (getlinе(line, maxline) > 0)  {
     lineno++;
     if ((index(line, *argv) >= 0) != except) \
         if (number)
             printf("%ld: ", lineno);
         printf("%s", line);
      }
       }
  }


     Аргумент argv увеличивается перед каждым необязательным
аргументом, в то время как аргумент argc  уменьшается.  если
нет  ошибок, то в конце цикла величина argc должна равняться
1, а *argv должно указывать на заданную комбинацию. Обратите
внимание  на то, что *++argv является указателем аргументной
строки; (*++argv)[0] -  ее  первый  символ.  Круглые  скобки
здесь  необходимы,  потому  что без них выражение бы приняло
совершенно отличный (и неправильный) вид *++(argv[0]).  Дру-
гой правильной формой была бы **++argv.

Упражнение 5-7.
Напишите  программу add, вычисляющую обратное польское выра-
жение из командной строки. Например,

  add 2 3 4 + *

вычисляет 2*(3+4).

Упражнение 5-8n
Модифицируйте программы entab и detab (указанные в  качестве
упражнений в главе 1) так, чтобы они получали список табуля-
ционных остановок в качестве аргументов. Если аргументы  от-
сутствуют, используйте стандартную установку табуляций.

Упражнение 5-9.
Расширьте entab и detab таким образом, чтобы они воспринима-
ли сокращенную нотацию

  entab m +n

означающую табуляционные остановки через каждые n  столбцов,
начиная  со  столбца  m. Выберите удобное (для пользователя)
поведение функции по умолчанию.

Упражнение 5-10.
Напишите программу для функции tail, печатающей последние  n
строк  из своего файла ввода. Пусть по умолчанию n равно 10,
но это число может быть изменено с  помощью  необязательного
аргумента, так что

  tail -n

печатает последние n строк. программа должна действовать ра-
ционально, какими бы неразумными ни были бы ввод или  значе-
ние  n. Составьте программу так, чтобы она оптимальным обра-
зом использовала доступную память: строки должны  храниться,
как  в функции sort, а не в двумерном массиве фиксированного
размера.

5.12. Указатели на функции

     В языке "с" сами функции не  являются  переменными,  но
имеется возможность определить указатель на функцию, который
можно обрабатывать, передавать другим функциям,  помещать  в
массивы  и  т.д. Мы проиллюстрируем это, проведя модификацию
написанной ранее программы сортировки так, чтобы при задании
необязательного аргумента -n она бы сортировала строки ввода
численно, а не лексикографически.
     Сортировка часто состоит из трех  частей  -  сравнения,
которое  определяет  упорядочивание любой пары об'ектов, пе-
рестановки, изменяющей их порядок, и  алгоритма  сортировки,
осуществляющего  сравнения  и  перестановки до тех пор, пока
об'екты не расположатся в нужном порядке. Алгоритм сортиров-
ки не зависит от операций сравнения и перестановки, так что,
передавая в него различные функции сравнения и перестановки,
мы  можем  организовать  сортировку  по различным критериям.
Именно такой подход используется  в  нашей  новой  программе
сортировки.
     Как  и  прежде, лексикографическое сравнение двух строк
осуществляется  функцией  strcmp,  а  перестановка  функцией
swap;  нам нужна еще функция numcmp, сравнивающая две строки
на основе численного значения и возвращающая условное указа-
ние  того же вида, что и strcmp. Эти три функции описываются
в main и указатели на них передаются в sort. В свою  очередь
функция  sort обращается к этим функциям через их указатели.
Мы урезали обработку ошибок в аргументах с тем, чтобы сосре-
доточиться на главных вопросах.

  #define LINES 100 /* max number of lines
         to be sorted */

  main(argc, argv) /* sort input lines */
  int argc;
  char *argv[];
   {
   char *lineptr[lines]; /* pointers to text lines */
   int nlines; /* number of input lines read */
   int strcmp(), numcmp(); /* comparsion functions */
   int swap(); /* exchange function */
   int numeric = 0; /* 1 if numeric sort */

   if(argc>1 && argv[1][0] == '-' && argv[1][1]=='n')
      numeric = 1;
   if(nlines = readlines(lineptr, lines)) >= 0)  {
      if (numeric)
            sort(lineptr, nlines, numcmp, swap);
      else
            sort(lineptr, nlines, strcmp, swap);
      writelines(lineptr, nlines);
    } else
      printf("input too big to sort\n");
   }


Здесь strcmp, nimcmp и swap -  адреса функций; так  как
известно, что это функции,  операция  &  здесь  не  нужна
совершенно аналогично тому, как  она  не  нужна и  перед
именем массива.  Передача  адресов  функций  организуется
компилятором.
     Второй шаг состоит в модификации sort:

  sort(v, n, comp, exch) /* sort strings v[0] ... v[n-1] */
  char *v[];           /* into increasing order */
  int n;
  int (*comp)(), (*exch)();
   {
   int gap, i, j;

   for(gap = n/2; gap > 0; gap /= 2)
       for(i = gap; i < n; i++)
      for(j = i-gap; j >= 0; j -= gap)  {
          if((*comp)(v[j], v[j+gap]) <= 0)
              break;
          (*exch)(&v[j], &v[j+gap]);
       }
   }

     Здесь  следует  обратить определенное внимание на описа-
ния. Описание

  int (*comp)()

говорит, что comp является указателем  на  функцию,  которая
возвращает  значение  типа  int. Первые круглые скобки здесь
необходимы; без них описание

  int *comp()

говорило бы, что comp является функцией, возвращающей указа-
тель на целые, что, конечно, совершенно другая вещь.
     Использование comp в строке

  if (*comp)(v[j], v[j+gap]) <= 0)

полностью согласуется с описанием: comp - указатель на функ-
цию, *comp - сама функция, а

  (*comp)(v[j], v[j+gap])

- обращение к ней. Круглые скобки необходимы для правильного
об'единения компонентов.
     Мы уже приводили функцию strcmp, сравнивающую две стро-
ки по первому численному значению:


  numcmp(s1, s2) /* compare s1 and s2 numerically */
  char *s1, *s2;
   {
   double atof(), v1, v2;

   v1 = atof(s1);
   v2 = atof(s2);
   if(v1 < v2)
      return(-1);
   else if(v1 > v2)
      return(1);
   else
      return (0);
   }

     Заключительный шаг состоит в добавлении  функции  swap,
переставляющей два указателя. Это легко сделать, непосредст-
венно используя то, что мы изложили ранее в этой главе.

  swap(px, py) /* interchange *px and *py */
  char *px[], *py[];
   {
   char *temp;

   temp = *px;
   *px = *py;
   *py = temp;
   }

     Имеется множество других необязятельных аргументов, ко-
торые  могут быть включены в программу сортировки: некоторые
из них составляют интересные упражнения.

Упражнение 5-11.
Модифицируйте sort таким образом, чтобы она работала с  мет-
кой -r, указывающей на сортировку в обратном (убывающем) по-
рядке. Конечно, -r должна работать с -n.

Упражнение 5-12.
Добавьте необязательный  аргумент  -f,  об'единяющий  вместе
прописные  и строчные буквы, так чтобы различие регистров не
учитывалось во время сортировки: данные из верхнего и нижне-
го регистров сортируются вместе, так что буква 'а' прописное
и 'а' строчное оказываются соседними , а не разделенными це-
лым алфавитом.

Упражнение 5-13.
Добавьте необязательный аргумент -d ("словарное упорядочива-
ние"), при наличии которого сравниваются только буквы, числа
и  пробелы. Позаботьтесь о том, чтобы эта функция работала и
вместе с -f.

Упражнение 5-14.
Добавьте возможность обработки полей, так чтобы  можно  было
сортировать  поля  внутри строк. Каждое поле должно сортиро-
ваться в соответствии с независимым  набором  необязательных
аргументов.  (предметный указатель этой книги сортировался с
помощью аргументов -df для категории указателя и  с  -n  для
номеров страниц).

</pre>
</body>
</html>
