<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>
3. Поток управления


    Управляющие  операторы языка определяют порядок вычисле-
ний. В приведенных ранее примерах мы уже встречались с  наи-
более употребительными управляющими конструкциями языка "C";
здесь мы опишем остальные  операторы  управления  и  уточним
действия операторов, обсуждавшихся ранее.

3.1. Операторы и блоки

     Такие  выражения,  как  x=0,  или i++, или printf(...),
становятся операторами, если за ними следует точка  с  запя-
той, как, например,

  x = 0;
  i++;
  printf(...);

В  языке "C" точка с запятой является признаком конца опера-
тора, а не разделителем операторов, как в языках типа  алго-
ла.
     Фигурные  скобки  /(  и /) используются для об'единения
описаний и операторов в составной оператор или блок, так что
они оказываются синтаксически эквивалентны одному оператору.
Один явный пример такого типа дают фигурные скобки, в  кото-
рые  заключаются  операторы,  составляющие функцию, другой -
фигурные скобки вокруг группы операторов в конструкциях  if,
else,  while и for.(на самом деле переменные могут быть опи-
саны внутри любого блока; мы поговорим об этом в  главе  4).
Точка  с  запятой  никогда не ставится после первой фигурной
скобки, которая завершает блок.

3.2. if - else

     Оператор if - else используется при необходимости  сде-
лать выбор. Формально синтаксис имеет вид

  if  (выражение)
          оператор-1
  else
          оператор-2,

где  часть else является необязательной. Сначала вычисляется
выражение; если оно "истинно" /т.е. значение  выражения  от-
лично  от  нуля/,  то выполняется оператор-1. Если оно ложно
/значение выражения равно нулю/, и если есть часть  с  else,
то вместо оператора-1 выполняется оператор-2.
     Так  как if просто проверяет численное значение выраже-
ния, то возможно некоторое сокращение записи. Самой  очевид-
ной возможностью является запись

  if  (выражение)

вместо

  if  (выражение !=0)

Иногда такая запись является ясной и естественной, но време-
нами она становится загадочной.
     То, что часть else в конструкции if - else является не-
обязательной,  приводит  к  двусмысленности  в случае, когда
else опускается во вложенной  последовательности  операторов
if.  Эта  неоднозначность разрешается обычным образом - else
связывается с ближайшим предыдущим if, не  содержащим  else.
Например, в

  if ( n > 0 )
     if( a > b )
             z = a;
     else
             z = b;

конструкция  else относится к внутреннему if, как мы и пока-
зали, сдвинув else под соответствующий if. Если это  не  то,
что Вы хотите, то для получения нужного соответствия необхо-
димо использовать фигурные скобки:

  if (n > 0)      {
     if (a > b)
             z = a;
  }
  else
     z = b;

     Такaя двусмысленность особенно пагубна в ситуациях типа

  if (n > 0)
     for (i = 0; i < n; i++)
             if (s[i] > 0) {
      printf("...");
      return(i);
             }
  else   /* wrong */
     printf("error - n is zero\n");

     Запись else под if ясно показывает, чего Вы хотите,  но
компилятор  не  получит  соответствующего  указания и свяжет
else с внутренним if. Ошибки такого рода очень трудно  обна-
руживаются.
     Между прочим, обратите внимание, что в

  if (a > b)
     z = a;
  else
     z = b;

после  z=a  стоит  точка с запятой. Дело в том, что согласно
грамматическим правилам за if должен следовать  оператор,  а
выражение типа z=a, являющееся оператором, всегда заканчива-
ется точкой с запятой.

3.3. else - if

Конструкция

  if (выражение)
     оператор
  else    if (выражение)
             оператор
  else    if (выражение)
             оператор
  else
     оператор

встречается  настолько  часто,  что  заслуживает  отдельного
краткого  рассмотрения.  Такая последовательность операторов
if является наиболее распространенным способом  программиро-
вания  выбора  из  нескольких возможных вариантов. выражения
просматриваются  последовательно;  если  какое-то  выражение
оказывается  истинным,то выполняется относящийся к нему опе-
ратор, и этим вся цепочка заканчивается. Каждый оператор мо-
жет  быть либо отдельным оператором, либо группой операторов
в фигурных скобках.
     Последняя часть с else имеет дело со случаем, когда  ни
одно  из проверяемых условий не выполняется. Иногда при этом
не надо предпринимать никаких явных действий; в этом  случае
хвост

  else
     оператор

может  быть опущен, или его можно использовать для контроля,
чтобы засечь "невозможное" условие.
     Для иллюстрации выбора из трех возможных вариантов при-
ведем программу функции, которая методом половинного деления
определяет, находится ли данное значение х в отсортированном
массиве  v. Элементы массива v должны быть расположены в по-
рядке возрастания. Функция возвращает номер  позиции  (число
между  0  и  n-1), в которой значение х находится в v, и -1,
если х не содержится в v.

  binary(x, v, n) /* find x in v[0]...v[n-1] */
  int x, v[], n;
  {
     int low, high, mid;

     low = 0;
     high = n - 1;
     while (low <= high) {
             mid = (low + high) / 2;
             if (x < v[mid])
      high = mid - 1;
             else if (x > v[mid])
      low = mid + 1;
             else   /* found match */
      return(mid);
     }
     return(-1);
  }

     Основной частью каждого шага алгоритма является провер-
ка,  будет  ли  х меньше, больше или равен среднему элементу
v[mid]; использование конструкции else - if здесь вполне ес-
тественно.

3.4. Переключатель

     Оператор  switch  дает специальный способ выбора одного
из многих вариантов, который заключается в проверке совпаде-
ния  значения данного выражения с одной из заданных констант
и соответствующем ветвлении. В главе 1 мы привели  программу
подсчета  числа вхождений каждой цифры, символов пустых про-
межутков и всех остальных символов, использующую  последова-
тельность  if...else  if...else. Вот та же самая программа с
переключателем.

  main() /* count digits,white space, others */
  {
     int c, i, nwhite, nother, ndigit[10];

     nwhite = nother = 0;
     for (i = 0; i < 10; i++)
             ndigit[i] = 0;

     while ((c = getchar()) != EOF)
             switch (c) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
       ndigit[c-'0']++;
       break;
              case ' ':
              case '\n':
              case '\t':
      nwhite++;
       break;
              default :
       nother++;
       break;
              }
      printf("digits =");
      for (i = 0; i < 10; i++)
              printf(" %d", ndigit[i]);
      printf("\nwhite space = %d, other = %d\n",
              nwhite, nother);

     Переключатель вычисляет целое выражение в круглых скоб-
ках (в данной программе - значение символа с)  и  сравнивает
его  значение со всеми случаями (case). Каждый случай должен
быть помечен либо целым, либо  символьной  константой,  либо
константным  выражением.  Если значение константного выраже-
ния, стоящего после вариантного префикса case, совпадает  со
значением целого выражения, то выполнение начинается с этого
случая. Если ни один из случаев не подходит, то  выполняется
оператор  после  префикса  default. Префикс default является
необязательным, если его нет, и ни один из случаев не подхо-
дит, то вообще никакие действия не выполняются. Случаи и вы-
бор по умолчанию могут располагаться в  любом  порядке.  Все
случаи должны быть различными.
     Оператор break приводит к немедленному выходу из перек-
лючателя. Поскольку случаи служат только в  качестве  меток,
то  если  Вы  не предпримите явных действий после выполнения
операторов, соответствующих одному случаю, Вы провалитесь на
следующий  случай.  Операторы  break и return являются самым
обычным способом выхода из  переключателя.  Как  мы  обсудим
позже  в этой главе, оператор breaк можно использовать и для
немедленного выхода из операторов цикла while, for и do.
     Проваливание сквозь случаи имеет как свои  достоинства,
так  и  недостатки.  К положительным качествам можно отнести
то, что оно позволяет связать несколько случаев с одним дей-
ствием,  как  было  с пробелом, табуляцией и новой строкой в
нашем примере. Но в то же время оно обычно приводит к  необ-
ходимости  заканчивать каждый случай оператором break, чтобы
избежать перехода к следующему случаю. Проваливание с одного
случая  на  другой  обычно  бывает неустойчивым, так как оно
склонно к расщеплению при модификации программы. За исключе-
нием, когда одному вычислению соответствуют несколько меток,
проваливание следует использовать умеренно.
     Заведите привычку ставить оператор brеак после  послед-
него  случая (в данном примере после defaulт), даже если это
не является логически необходимым. В один  прекрасный  день,
когда Вы добавите в конец еще один случай, эта маленькая ме-
ра предосторожности избавит Вас от неприятностей.

Упражнение 3-1.
     Напишите программу для функции  expand(s,  t),  которая
копирует  строку s в т, заменяя при этом символы табуляции и
новой строки на видимые условные последовательности, как  \n
и \т. используйте переключатель.

3.5. Циклы - while и for

     Мы  уже сталкивались с операторами цикла while и for. В
конструкции

  while (выражение)
     оператор

вычисляется выражение. Если его значение отлично от нуля, то
выполняется  оператор  и  выражение  вычисляется снова. Этот
цикл продолжается до тех пор,  пока  значение  выражения  не
станет нулем, после чего выполнение программы продолжается с
места после оператора.

    Оператор

  for (выражение 1; выражение 2; выражение 3)
     оператор

эквивалентен последовательности

  выражение 1;
  while (выражение 2) {
     оператор
     выражение 3;
  }

Грамматически все три компонента в for являются выражениями.
наиболее распространенным является случай, когда выражение 1
и выражение 3 являются присваиваниями или обращениями к фун-
кциям, а выражение 2 - условным выражением.  любая  из  трех
частей  может  быть  опущена,  хотя точки с запятой при этом
должны оставаться. Если отсутствует выражение 1 или  выраже-
ние 3, то оно просто выпадает из расширения. Если же отсутс-
твует проверка, выражение 2, то  считается,  как  будто  оно
всегда истинно, так что

  for (;;)        {
     ...
  }

является  бесконечным  циклом, о котором предполагается, что
он будет прерван другими средствами (такими  как  break  или
return).
     Использовать  ли  while  или for - это, в основном дело
вкуса. Например в

  while ((c = getchar())
      == ' ' || c == '\n' || c == '\t')
    ;    /* skip white space characters */

нет ни инициализации, ни реинициализации, так что цикл whilе
выглядит самым естественным.
     Цикл  for,  очевидно, предпочтительнее там, где имеется
простая инициализация и реинициализация, поскольку при  этом
управляющие  циклом  операторы наглядным образом оказываются
вместе в начале цикла. Это наиболее очевидно в конструкции

  for (i = 0; i < n; i++)

которая является идиомой языка "C" для  обработки  первых  n
элементов массива, аналогичной оператору цикла do в фортране
и PL/1. Аналогия, однако, не полная, так как  границы  цикла
могут  быть  изменены внутри цикла, а управляющая переменная
сохраняет свое значение после выхода из цикла, какова бы  ни
была  причина этого выхода. Поскольку компонентами for могут
быть произвольные выражения, они  не  ограничиваются  только
арифметическими  прогрессиями.  Тем не менее является плохим
стилем включать в for вычисления, которые не относятся к уп-
равлению  циклом,  лучше  поместить  их в управляемые циклом
операторы.
     В качестве большего по размеру примера приведем  другой
вариант  функции  atoi,  преобразующей строку в ее численный
эквивалент. Этот вариант является более общим; он  допускает
присутствие  в  начале символов пустых промежутков и знака +
или -. (В главе 4 приведена функция atof, которая  выполняет
то же самое преобразование для чисел с плавающей точкой).
     Общая  схема  программы отражает форму поступающих дан-
ных:

  - пропустить пустой промежуток, если он имеется

  - извлечь знак, если он имеется

  - извлечь целую часть и преобразовать ее

каждый шаг выполняет свою часть работы  и  оставляет  все  в
подготовленном  состоянии  для следующей части. Весь процесс
заканчивается на  первом  символе,  который  не  может  быть
частью числа.

  atoi(s)   /* convert s to integer */
  char s[];
  {
  int i, n, sign;
  for(i=0;s[i]==' ' ||
           s[i]=='\n' || s[i]=='\t';i++)
     ; /* skip white space */
  sign = 1;
  if(s[i] == '+' || s[i] == '-')  /* sign */
     sign = (s[i++]=='+') ? 1 : - 1;
  for( n = 0; s[i] >= '0' && s[i] <= '9'; i++)
     n = 10 * n + s[i] - '0';
  return(sign * n);
  }

     Преимущества централизации управления циклом становятся
еще более очевидными, когда имеется несколько вложенных цик-
лов. Следующая функция сортирует массив целых чисел по мето-
ду шелла. основная идея сортировки по  шеллу  заключается  в
том, что сначала сравниваются удаленные элементы, а не смеж-
ные, как в обычном методе сортировки. Это приводит к быстро-
му  устранению  большой  части неупорядоченности и сокращает
последующую работу.  Интервал  между  элементами  постепенно
сокращается  до единицы, когда сортировка фактически превра-
щается в метод перестановки соседних элементов.

  shell(v, n)   /* sort v[0]...v[n-1]
                 into increasing order */
  int v[], n;
  {
    int gap, i, j, temp;

    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
    for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {
     temp = v[j];
     v[j] = v[j+gap];
     v[j+gap] = temp;
    }
  }

     Здесь имеются три вложенных цикла. Самый  внешний  цикл
управляет  интервалом между сравниваемыми элементами, умень-
шая его от n/2 вдвое при каждом проходе, пока он  не  станет
равным  нулю. Средний цикл сравнивает каждую пару элементов,
разделенных на величину интервала; самый внутренний цикл пе-
реставляет  любую  неупорядоченную  пару. Так как интервал в
конце концов сводится к единице, все элементы  в  результате
упорядочиваются правильно. Отметим, что в силу общности кон-
струкции for внешний цикл укладывается в ту же самую  форму,
что  и остальные, хотя он и не является арифметической прог-
рессией.
     Последней операцией языка "C" является запятая ",", ко-
торая  чаще  всего используется в операторе for. Два выраже-
ния, разделенные запятой, вычисляются слева направо,  причем
типом и значением результата являются тип и значение правого
операнда. Таким образом, в  различные  части  оператора  for
можно включить несколько выражений, например, для параллель-
ного изменения двух индексов.  Это  иллюстрируется  функцией
reverse(s),  которая располагает строку s в обратном порядке
на том же месте.

  reverse(s)    /* reverse string s in place */
  char s[];
  {
  int c, i, j;

  for(i = 0, j = strlen(s) - 1; i < j; i++, j--)  {
     c = s[i];
     s[i] = s[j];
     s[j] = c;
  }
  }

Запятые, которые разделяют аргументы функций,  переменные  в
описаниях и т.д., не имеют отношения к операции запятая и не
обеспечивают вычислений слева направо.

Упражнение 3-2.
     Составьте программу для функции expand(s1,s2),  которая
расширяет  сокращенные  обозначения  вида а-z из строки s1 в
эквивалентный полный список авс...xyz в s2. Допускаются сок-
ращения  для строчных и прописных букв и цифр. Будьте готовы
иметь дело со случаями типа а-в-с, а-z0-9 и -а-z.  (Полезное
соглашение состоит в том, что символ -, стоящий в начале или
конце, воспринимается буквально).

3.6. Цикл do - while

     Как уже отмечалось в главе 1, циклы while и for облада-
ют тем приятным свойством, что в них проверка окончания осу-
ществляется в начале, а не в конце  цикла.  Третий  оператор
цикла  языка  "C",  do-while,  проверяет условие окончания в
конце, после каждого прохода через тело  цикла;  тело  цикла
всегда выполняется по крайней мере один раз. Синтаксис этого
оператора имеет вид:

  do
     оператор
  while (выражение)

     Сначала выполняется оператор, затем вычисляется выраже-
ние.  Если оно истинно, то оператор выполняется снова и т.д.
Если выражение становится ложным, цикл заканчивается.
     Как и можно было ожидать,  цикл  do-while  используется
значительно  реже,  чем while и for, составляя примерно пять
процентов от всех циклов. Тем не менее, иногда он оказывает-
ся  полезным, как, например, в следующей функции itoa, кото-
рая преобразует число в символьную строку (обратная  функции
atoi).  Эта  задача оказывается несколько более сложной, чем
может показаться сначала. Дело в том, что простые методы вы-
деления  цифр генерируют их в неправильном порядке. Мы пред-
почли получить строку в обратном порядке, а  затем  обратить
ее.

  itoa(n,s)   /*convert n to characters in s */
  char s[];
  int n;
  {
  int i, sign;

  if ((sign = n) < 0)   /* record sign */
     n = -n;     /* make n positive */
  i = 0;
  do {    /* generate digits in reverse order */
     s[i++] = n % 10 + '0';/* get next digit */
  }   while ((n /=10) > 0); /* delete it */
  if (sign < 0)
     s[i++] = '-'
  s[i] = '\0';
  reverse(s);
  }

     Цикл do-while здесь необходим, или по крайней мере удо-
бен, поскольку, каково бы ни было значение n, массив s  дол-
жен  содержать  хотя бы один символ. Мы заключили в фигурные
скобки один оператор, составляющий тело do-whilе, хотя это и
не  обязательно, для того, чтобы торопливый читатель не при-
нял часть while за начало оператора цикла while.

Упражнение 3-3.
     При представлении чисел в двоичном дополнительном  коде
наш  вариант  itoa не справляется с наибольшим отрицательным
числом, т.е. со значением n рaвным -2 в степени м-1, где м -
размер слова. об'ясните почему. Измените программу так, что-
бы она правильно печатала это значение на любой машине.

Упражнение 3-4.
     Напишите аналогичную функцию itob(n,s), которая  преоб-
разует целое без знака n в его двоичное символьное представ-
ление в s. Запрограммируйте функцию itoh, которая преобразу-
ет целое в шестнадцатеричное представление.

Упражнение 3-5.
     Напишите  вариант iтоа, который имеет три, а не два ар-
гумента. Третий аргумент - минимальная ширина поля; преобра-
зованное число должно, если это необходимо, дополняться сле-
ва пробелами, так чтобы оно имело достаточную ширину.

3.7. Оператор break

     Иногда бывает удобным иметь возможность управлять выхо-
дом  из  цикла  иначе,  чем проверкой условия в начале или в
конце. Оператор brеак позволяет  выйти  из  операторов  for,
while  и do до окончания цикла точно так же, как и из перек-
лючателя. Оператор brеак приводит к немедленному  выходу  из
самого внутреннего охватывающего его цикла (или переключате-
ля).
     Следующая программа удаляет хвостовые пробелы и табуля-
ции  из конца каждой строки файла ввода. Она использует опе-
ратор brеак для выхода из цикла, когда найден крайний правый
отличный от пробела и табуляции символ.

  #define MAXLINE 1000
  main()    /* remove trailing blanks and tabs */
  {
  int n;
  char line[maxline];

  while ((n = getline(line,maxline)) > 0) {
   while (--n >= 0)
         if (line[n] != ' ' && line[n] != '\t'
         && line[n] != '\n')
               break;
   line[n+1] = '\0';
   printf("%s\n",line);
  }
  }

     Функция  getline  возвращает  длину  строки. Внутренний
цикл начинается с последнего символа line (напомним, что --n
уменьшает  n до использования его значения) и движется в об-
ратном направлении в поиске первого символа , который  отли-
чен  от пробела, табуляции или новой строки. Цикл прерывает-
ся, когда либо найден такой символ, либо n становится  отри-
цательным (т.е., когда просмотрена вся строка). Советуем вам
убедиться, что такое поведение правильно  и  в  том  случае,
когда строка состоит только из символов пустых промежутков.
     В качестве альтернативы к brеак можно ввести проверку в
сам цикл:

  while ((n = getline(line,maxline)) > 0) {
   while (--n >= 0
       && (line[n] == ' ' || line[n] == '\t'
       || line[n] == '\n'))
             ;
     ...
  }

Это уступает предыдущему варианту, так как  проверка  стано-
вится  труднее  для понимания. Проверок, которые требуют пе-
реплетения &&, ||, ! И круглых скобок, по возможности сле-
дует избегать.

3.8. Оператор continue

     Оператор  continue  родственен  оператору brеак, но ис-
пользуется реже; он приводит к началу следующей итерации ох-
ватывающего цикла (for, while, do ). В циклах while и do это
означает непосредственный переход к  выполнению  проверочной
части;  в цикле for управление передается на шаг реинициали-
зации. (Оператор continue применяется только в циклах, но не
в  переключателях.  Оператор  continue  внутри переключателя
внутри цикла вызывает выполнение следующей итерации цикла).
     В качестве примера приведем фрагмент, который обрабаты-
вает  только положительные элементы массива а; отрицательные
значения пропускаются.

  for (i = 0; i < n; i++) {
   if (a[i] < 0) /* skip negative elements */
         continue;
       ...  /* do positive elements */
  }

     Оператор continue часто используется, когда последующая
часть  цикла оказывается слишком сложной, так что рассмотре-
ние условия, обратного проверяемому, приводит к слишком глу-
бокому уровню вложенности программы.

Упражнение 3-6.
     Напишите  программу  копирования  ввода на вывод, с тем
исключением, что из каждой группы последовательных  одинако-
вых строк выводится только одна. (Это простой вариант утили-
ты uniq систем UNIX).

3.9. Оператор goto и метки

     В языке "C" предусмотрен и оператор goto, которым  бес-
конечно  злоупотребляют, и метки для ветвления. С формальной
точки зрения оператор goto никогда не является  необходимым,
и  на  практике  почти всегда можно обойтись без него. Мы не
использовали goto в этой книге.
     Тем не менее, мы укажем несколько ситуаций, где  опера-
тор  goto может найти свое место. Наиболее характерным явля-
ется его использование тогда, когда нужно прервать  выполне-
ние в некоторой глубоко вложенной структуре, например, выйти
сразу из двух циклов. Здесь нельзя непосредственно использо-
вать оператор brеак, так как он прерывает только самый внут-
ренний цикл. Поэтому:

  for ( ... )
     for ( ... )    {
             ...
             if (disaster)
      goto error;
     }
  ...

  error:
  clean up the mess

если программа обработки ошибок нетривиальна и ошибки  могут
возникать в нескольких местах, то такая организация оказыва-
ется удобной. Метка имеет такую же форму, что и имя перемен-
ной,  и  за  ней  всегда следует двоеточие. Метка может быть
приписана к любому оператору той же функции, в которой нахо-
дится оператор goto.
     В качестве другого примера рассмотрим задачу нахождения
первого отрицательного элемента в двумерном массиве. (Много-
мерные  массивы рассматриваются в главе 5). Вот одна из воз-
можностей:

  for (i = 0; i < n; i++)
     for (j = 0; j < m; j++)
             if (v[i][j] < 0)
      goto found;
     /* didn't find */
  ...
  found:
  /* found one at position i, j */
  ...

     Программа, использующая  оператор  goto,  всегда  может
быть  написана  без него, хотя, возможно, за счет повторения
некоторых проверок  и  введения  дополнительных  переменных.
Например, программа поиска в массиве примет вид:

  found = 0;
  for (i = 0; i < n && !found; i++)
     for (j = 0; j < m && !found; j++)
             found = v[i][j] < 0;
  if (found)
     /* it was at i-1, j-1 */
     ...
  else
     /* not found */
     ...

     Хотя мы не являемся в этом вопросе догматиками, нам все
же кажется, что если и нужно использовать оператор goto,  то
весьма умеренно.
</pre>
</body>
</html>
