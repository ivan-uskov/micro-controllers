<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Керниган и Ричи - Введение в язык C</title>
</head>
<body background="../IMG/BACKGRND.GIF">
<pre>
6. Структуры.


     Структура  -  это  набор из одной или более переменных,
возможно различных типов, сгруппированных под  одним  именем
для удобства обработки. (В некоторых языках, самый известный
из которых Паскаль, структуры называются "записями").
     Традиционным примером структуры является  учетная  кар-
точка  работающего: "служащий" описывается набором атрибутов
таких, как фамилия, имя, отчество (ф.и.о.), адрес, код соци-
ального обеспечения, зарплата и т.д. Некоторые из этих атри-
бутов сами могут оказаться структурами:  ф.и.о.  Имеет  нес-
колько компонент, как и адрес, и даже зарплата.
     Структуры оказываются полезными при организации сложных
данных особенно в больших программах,  поскольку  во  многих
ситуациях они позволяют сгруппировать связанные данные таким
образом, что с ними можно обращаться, как с одним  целым,  а
не  как  с отдельными об'ектами. В этой главе мы постараемся
продемонстрировать то, как используются структуры.  Програм-
мы,  которые  мы  для  этого будем использовать, больше, чем
многие другие в этой книге, но все же  достаточно  умеренных
размеров.

6.1. Основные сведения.
     Давайте снова обратимся к процедурам преобразования да-
ты из главы 5. Дата состоит из нескольких частей таких,  как
день, месяц, и год, и, возможно, день года и имя месяца. Эти
пять переменных можно об'еденить в одну структуру вида:

  struct date {
  int  day;
  int  month;
  int  year;
  int  yearday;
  char mon_name[4];
  } ;

     Описание структуры, состоящее из заключенного в  фигур-
ные  скобки  списка  описаний,  начинается с ключевого слова
struct. За словом struct может следовать необязательное имя,
называемое  ярлыком  структуры (здесь это date). Такой ярлык
именует структуры этого вида и может использоваться в  даль-
нейшем как сокращенная запись подробного описания.
     Элементы  или переменные, упомянутые в структуре, назы-
ваются членами. Ярлыки и члены структур могут иметь такие же
имена,  что и обычные переменные (т.е. не являющиеся членами
структур), поскольку их имена всегда можно различить по кон-
тексту.  Конечно, обычно одинаковые имена присваивают только
тесно связанным об'ектам.
     Точно так же, как в случае любого другого базисного ти-
па,  за  правой фигурной скобкой, закрывающей список членов,
может следовать список переменных.

Оператор

  struct   { ...}  x,y,z;

синтаксически аналогичен

  int x,y,z;

в том смысле, что каждый из операторов описывает x , y и z в
качестве  переменных соотвествующих типов и приводит к выде-
лению для них памяти.
     Описание структуры, за которым не следует списка  пере-
менных, не приводит к выделению какой-либо памяти; оно толь-
ко определяет шаблон или форму структуры. Однако, если такое
описание  снабжено ярлыком, то этот ярлык может быть исполь-
зован позднее при определении фактических экземпляров струк-
тур. Например, если дано приведенное выше описание date, то

  struct  date d;

определяет переменную d в качестве структуры  типа  date.
Внешнюю или статическую структуру можно инициализировать,
поместив вслед за ее определением список  инициализаторов
для ее компонент:

  struct date d={ 4, 7, 1776, 186, "jul"} ;

     Член определенной структуры может быть указан в выраже-
нии с помощью конструкции вида

   имя структуры . Член
   --------------------

     Операция указания члена  структуры  "."  связывает  имя
структуры  и  имя  члена.  В качестве примера определим leap
(признак високосности года) на основе  даты,  находящейся  в
структуре d,

  leap = d.year % 4 == 0 && d.year % 100 != 0
     || d.year % 400 == 0;

или проверим имя месяца

  if (strcmp(d.mon_name, "aug") == 0) ...

или  преобразуем  первый  символ имени месяца так, чтобы оно
начиналось со строчной буквы

  d.mon_name[0] = lower(d.mon_name[0]);

     Структуры могут быть вложенными; учетная карточка  слу-
жащего может фактически выглядеть так:

  struct  person  {
     char name[namesize];
     char address[adrsize];
     long zipcode;   /* почтовый индекс */
     long ss_number; /* код соц. Обеспечения */
     double salary;  /* зарплата */
     struct date birthdate; /* дата рождения */
     struct date hiredate; /* дата поступления
      на работу */
  } ;
     Структура person содержит две структуры типа date . Ес-
ли мы определим emp как

  struct person emp;

то

  emp.birthdate.month

будет ссылаться на месяц рождения. Операция  указания  члена
структуры "." ассоциируется слева направо.

6.2. Структуры и функции.

     В языке "с" существует ряд ограничений на использование
структур. Обязательные правила заключаются в том, что единс-
твенные  операции, которые Вы можете проводить со структура-
ми, состоят в определении ее адреса с помощью операции  &  и
доступе  к  одному из ее членов. Это влечет за собой то, что
структуры нельзя присваивать или копировать как целое, и что
они  не  могут быть переданы функциям или возвращены ими. (В
последующих версиях эти ограничения будут сняты). На  указа-
тели  структур  эти ограничения однако не накладываются, так
что структуры и функции все же могут  с  удобством  работать
совместно.  И наконец, автоматические структуры, как и авто-
матические массивы, не могут быть инициализированы;  инициа-
лизация  возможна  только  в  случае внешних или статических
структур.
     Давайте разберем некоторые из этих вопросов,  переписав
с этой целью функции перобразования даты из предыдущей главы
так, чтобы они использовали структуры. Так как правила  зап-
рещают  непосредственную  передачу  структуры функции, то мы
должны либо передавать отдельно  компоненты,  либо  передать
указатель всей структуры. Первая возможность демонстрируется
на примере функции day_of_year, как мы ее написали  в  главе
5:

  d.yearday = day_of_year(d.year, d.month, d.day);

     Другой  способ  состоит  в  передаче указателя. если мы
опишем hiredate как

  struct  date hiredate;

и перепишем day_of_year нужным образом, мы сможем тогда  на-
писать

  hiredate yearday = day_of_year(&hiredate);

передавая указатель на hiredate функции day_of_year. Функция
должна быть модифицирована, потому что  ее  аргумент  теперь
является указателем, а не списком переменных.

  day_of_year(pd) /* set day of year from month, day */
  struct date *pd;
  {
   int i, day, leap;

   day = pd->day;
   leap = pd->year % 4 == 0 && pd->year % 100 != 0
      || pd->year % 400 == 0;
   for (i =1;  i < pd->month; i++)
      day += day_tab[leap][i];
   return(day);
       }

Описание

  struct date *pd;

говорит,  что  pd  является указателем структуры типа date .
Запись, показанная на примере

  pd->year

является новой. Если p - указатель на структуру, то

  p-> член структуры
      --------------

обращается к конкретному члену. (Операция -> - это знак  ми-
нус, за которым следует знак ">".)
    Так как pd указывает на структуру, то к члену year можно
обратиться и следующим образом

  (*pd).year

     Но указатели структур используются настолько часто, что
запись  -> оказывается удобным сокращением. Круглые скобки в
(*pd).year необходимы, потому что  операция  указания  члена
стуктуры старше , чем * . Обе операции, "->" и ".", ассоции-
руются слева направо, так что  конструкции  слева  и  справа
зквивалентны

  p->q->memb    (p->q)->memb
  emp.birthdate.month    (emp.birthdate).month

     Для  полноты ниже приводится другая функция, month_day,
переписанная с использованием структур.

  month_day(pd) /* set month and day from day of year */
    struct date *pd;
    {
  int i, leap;

  leap = pd->year % 4 == 0 && pd->year % 100 != 0
     || pd->year % 400 == 0;
  pd->day = pd->yearday;
  for (i = 1; pd->day > day_tab[leap][i]; i++)
     pd->day -= day_tab[leap][i];
  pd->month = i;
     }

     Операции работы со структурами "->" и "." наряду со  ()
для  списка  аргументов и [] для индексов находятся на самом
верху иерархии страшинства операций и, следовательно, связы-
ваются очень крепко. Если, например, имеется описание

  struct {
     int x;
     int *y;
  }  *p;

то выражение

  ++p->x

увеличивает  х,  а  не р, так как оно эквивалентно выражению
++(p->х). Для изменения порядка  выполнения  операций  можно
использовать  круглые скобки: (++p)->х увеличивает p до дос-
тупа к х, а (p++)->x увеличивает p после. (круглые скобки  в
последнем случае необязательны. Почему ?)
     Совершенно аналогично *p->y извлекает то, на что указы-
вает y; *p->y++ увеличивает y после обработки того,  на  что
он  указывает (точно так же, как и *s++); (*p->y)++ увеличи-
вает то, на что указывает y; *p++->y увеличивает p после вы-
борки того, на что указывает y.

6.3. Массивы сруктур.

     Структуры  особенно  подходят  для управления массивами
связанных переменных. Рассмотрим, например, программу  подс-
чета  числа вхождений каждого ключевого слова языка "C". Нам
нужен массив символьных строк для хранения имен и массив це-
лых для подсчета. Одна из возможностей состоит в использова-
нии двух параллельных массивов keyword и keycount:

  char *keyword [nkeys];
  int  keycount [nkeys];

но сам факт, что массивы параллельны, указывает  на  возмож-
ность другой организации. Каждое ключевое слово здесь по су-
ществу является парой:

  char *keyword;
  int  keycount;

и, следовательно, имеется массив пар. Описание структуры

  struct key  {
     char *keyword;
     int  keycount;
  }  keytab [nkeys];

определяет массив keytab структур такого типа и отводит  для
них  память. Каждый элемент массива является структурой. Это
можно было бы записать и так:

  struct key  {
     char *keyword;
     int  keycount;
  } ;
  struct key keytab [nkeys];

     Так как структура keytab фактически содержит постоянный
набор  имен,  то  легче всего инициализировать ее один раз и
для всех  членов  при  определении.  Инициализация  структур
вполне аналогична предыдущим инициализациям - за определени-
ем следует заключенный в фигурные скобки список  инициализа-
торов:

  struct key  {
     char *keyword;
     int  keycount;
  }  keytab[] ={
     "break", 0,
     "case", 0,
     "char", 0,
     "continue", 0,
     "default", 0,
     /* ... */
     "unsigned", 0,
     "while", 0
  } ;


     Инициализаторы перечисляются парами соответственно чле-
нам структуры. Было бы  более  точно  заключать  в  фигурные
скобки инициализаторы для каждой "строки" или структуры сле-
дующим образом:

  { "break", 0 } ,
  { "case", 0 } ,
  . . .

     Но когда инициализаторы являются  простыми  переменными
или символьными строками и все они присутствуют, то во внут-
ренних фигурных скобках нет необходимости. Как обычно,  ком-
пилятор  сам  вычислит  число элементов массива keytab, если
инициализаторы присутствуют, а скобки [] оставлены пустыми.
     Программа подсчета ключевых слов начинается с определе-
ния  массива keytab. ведущая программа читает свой файл вво-
да, последовательно обращаясь к функции getword, которая из-
влекает  из ввода по одному слову за обращение. Каждое слово
ищется в массиве keytab с помощью варианта функции бинарного
поиска, написанной нами в главе 3. (Конечно, чтобы эта функ-
ция работала, список ключевых слов должен быть расположен  в
порядке возрастания).

  #define    MAXWORD   20

  main()   /* count "C" keywords */
  {
  int  n, t;
  char word[maxword];

  while ((t = getword(word,maxword)) != EOF)
     if (t == letter)
       if((n = binary(word,keytab,nkeys)) >= 0)
          keytab[n].keycount++;
  for (n =0; n < nkeys; n++)
     if (keytab[n].keycount > 0)
      printf("%4d %s\n",
        keytab[n].keycount, keytab[n].keyword);
  }

  binary(word, tab, n) /* find word in tab[0]...tab[n-1] */
  char *word;
  struct key tab[];
  int n;
  {
   int low, high, mid, cond;

   low = 0;
   high = n - 1;
   while (low <= high) {
     mid = (low+high) / 2;
     if((cond = strcmp(word, tab[mid].keyword)) < 0)
      high = mid - 1;
     else if (cond > 0)
      low = mid + 1;
     else
      return (mid);
   }
   return(-1);
  }

     Мы  вскоре  приведем  функцию  getword; пока достаточно
сказать, что она возвращает letter каждый раз, как она нахо-
дит слово, и копирует это слово в свой первый аргумент.
     Величина nkeys - это количество ключевых слов в массиве
keytab . Хотя мы можем сосчитать это число вручную,  гораздо
легче и надежнее поручить это машине, особенно в том случае,
если список ключевых слов  подвержен  изменениям.  Одной  из
возможностей было бы закончить список инициализаторов указа-
нием на нуль и затем пройти в цикле  сквозь  массив  keytab,
пока не найдется конец.
     Но,  поскольку размер этого массива полностью определен
к моменту компиляции, здесь имеется  более  простая  возмож-
ность.
     Число элементов просто есть

  size of keytab / size of struct key

     Дело  в том, что в языке "C" предусмотрена унарная опе-
рация sizeof, выполняемая во время компиляции, которая  поз-
воляет вычислить размер любого об'екта. Выражение

  sizeof(object)

выдает целое, равное размеру указанного об'екта. (Размер оп-
ределяется  в неспецифицированных единицах, называемых "бай-
тами", которые имеют тот же размер, что  и  переменные  типа
char).  Об'ект может быть фактической переменной, массивом и
структурой, или именем основного типа, как int  или  double,
или  именем производного типа, как структура. В нашем случае
число ключевых слов равно размеру массива, деленному на раз-
мер  одного  элемента массива. Это вычисление используется в
утверждении #define для установления значения nkeys:

  #define nkeys (sizeof(keytab) / sizeof(struct key))

     Теперь перейдем к функции getword. Мы фактически  напи-
сали более общий вариант функции getword, чем необходимо для
этой программы, но он не  на  много  более  сложен.  Функция
getword  возвращает  следующее  "слово" из ввода, где словом
считается либо строка букв и цифр, начинающихся с буквы, ли-
бо отдельный символ. Тип об'екта возвращается в качетве зна-
чения функции; это - letter, если  найдено  слово,  EOF  для
конца файла и сам символ, если он не буквенный.

  getword(w, lim)   /* get next word from input */
  char *w;
  int lim;
  {
   int c, t;
   if (type(c=*w++=getch()) !=letter) {
        *w='\0';
        return(c);
   }
  while (--lim > 0)  {
   t = type(c = *w++ = getch());
   if (t ! = letter && t ! = digit) {
        ungetch(c);
        break;
   }
  }
  *(w-1) - '\0';
  return(letter);
  }

     Функция getword использует функции getch и ungetch, ко-
торые мы написали в главе 4: когда набор алфавитных символов
прерывается,  функция getword получает один лишний символ. В
результате вызова ungetch этот символ  помещается  назад  во
ввод для следующего обращения.
     Функция getword обращается к функции type для определе-
ния типа каждого отдельного символа из файла ввода. Вот  ва-
риант, справедливый только для алфавита ascii.

  type(c)  /* return type of ascii character */
  int c;
  {
  if (c>= 'a' && c<= 'z' || c>= 'a' && c<= 'z')
       return(letter);
  else if (c>= '0' && c<= '9')
       return(digit);
  else
       return(c);
  }

     Символические  константы letter и digit могут иметь лю-
бые значения, лишь бы они не вступали в конфликт с  символа-
ми, отличными от буквенно-цифровых, и с EOF; очевидно возмо-
жен следующий выбор

  #define   letter   'a'
  #define   digit   '0'

     Функция getword могла бы работать быстрее, если бы  об-
ращения к функции type были заменены обращениями к соответс-
твующему массиву type[ ]. В стандартной библиотеке языка "C"
предусмотрены макросы isalpha и isdigit, действующие необхо-
димым образом.

Упражнение 6-1.
Сделайте  такую  модификацию  функции getword и оцените, как
изменится скорость работы программы.

Упражнение 6-2.
Напишите вариант функции type, не зависящий  от  конкретного
набора символов.

Упражнение 6-3.
Напишите  вариант  программы подсчета ключевых слов, который
бы не учитывал появления этих слов в заключенных  в  кавычки
строках.

6.4. Указатели на структуры.

     Чтобы  проиллюстрировать некоторые соображения, связан-
ные с использованием указателей и массивов структур, давайте
снова  составим программу подсчета ключевых строк, используя
на этот раз указатели, а не индексы массивов.
     Внешнее описание массива keytab не нужно  изменять,  но
функции main и binary требуют модификации.

  main()   /* count c keyword; pointer version */
   {
  int  t;
  char word[maxword];
  struct key *binary(), *p;
  while ((t = getword(word, maxword;) !=EOF)
    if (t==letter)
    if ((p=binary(word,keytab,nkeys)) !=NULL)
            p->keycount++;
  for (p=keytab; p>keytab + nkeys; p++)
    if (p->keycount > 0)
  printf("%4d %s/n", p->keycount, p->keyword);
    }
    struct key *binary(word, tab, n) /* find word */
   char *word   /* in tab[0]...tab[n-1] */
   struct key tab [];
   int n;
   {
  int  cond;
  struct key *low = &tab[0];
  struct key *high = &tab[n-1];
  struct key *mid;
  while (low <= high) {
  mid = low + (high-low) / 2;
  if ((cond = strcmp(word, mid->keyword)) < 0)
       high = mid - 1;
  else if (cond > 0)
        low = mid + 1;
  else
        return(mid);
   }
   return(NULL);
    }

     Здесь  имеется  несколько моментов, которые стоит отме-
тить. Во-первых, описание функции binari  должно  указывать,
что  она возвращает указатель на структуру типа key, а не на
целое; это об'является как в функции main, так и  в  binary.
Если  функция binari находит слово, то она возвращает указа-
тель на него; если же нет, она возвращает NULL.
     Во-вторых, все обращения  к  элементам  массива  keytab
осуществляются через указатели. Это влечет за собой одно су-
щественное изменение в функции binary: средний элемент боль-
ше нельзя вычислять просто по формуле

  mid = (low + high) / 2

потому  что  сложение  двух указателей не дает какого-нибудь
полезного результата (даже после деления на 2) и в  действи-
тельности является незаконным. эту формулу надо заменить на

  mid = low + (high-low) / 2

в  результате  которой mid становится указателем на элемент,
расположенный посередине между low и high.
     Вам также следует разобраться  в  инициализации  low  и
high. указатель можно инициализировать адресом ранее опреде-
ленного об'екта; именно как мы здесь и поступили.
     В функции main мы написали

  for (p=keytab; p < keytab + nkeys; p++)

если p является указателем структуры, то любая арифметика  с
p учитывает фактический размер данной структуры, так что p++
увеличивает p на нужную величину, в результате чего p указы-
вает  на следующий элемент массива структур. Но не считайте,
что размер структуры равен сумме размеров ее членов, - из-за
требований  выравнивания  для различных об'ектов в структуре
могут возникать "дыры".
     И, наконец, несколько второстепенный вопрос о форме за-
писи  программы.  Если  возвращаемая функцией величина имеет
тип, как, например, в

  struct key *binary(word, tab, n)

тo может оказаться, что имя функции  трудно  выделить  среди
текста.  В связи с этим иногда используется другой стиль за-
писи:

  struct key *
       binary(word, tab, n)

Это главным образом дело вкуса; выберите ту  форму,  которая
вам нравится, и придерживайтесь ее.

6.5. Структуры, ссылающиеся на себя.

     Предположим,  что нам надо справиться с более общей за-
дачей, состоящей в подсчете числа появлений всех слов в  не-
котором  файле  ввода. Так как список слов заранее не извес-
тен, мы не можем их упорядочить удобным образом и  использо-
вать  бинарный поиск. Мы даже не можем осуществлять последо-
вательный просмотр при поступлении каждого слова, с тем что-
бы  установить, не встречалось ли оно ранее; такая программа
будет работать вечно. (Более точно, ожидаемое  время  работы
растет  как квадрат числа вводимых слов). Как же нам органи-
зовать программу, чтобы справиться со  списком  произвольных
слов?
     Одно  из решений состоит в том, чтобы все время хранить
массив поступающих до сих пор слов в упорядоченном виде, по-
мещая  каждое  слово  в нужное место по мере их поступления.
oДнако это не следует делать,  перемещая  слова  в  линейном
массиве, - это также потребует слишком много времени. Вместо
этого мы используем структуру данных, называемую доичным де-
ревом.
     Каждому  новому слову соответствует один "узел" дерева;
каждый узел содержит:

  указатель текста слова
  ----------------------

  счетчик числа появлений
  -----------------------

  указатель узла левого потомка
  -----------------------------

  указатель узла правого потомка
  ------------------------------

     Никакой узел не может иметь более двух детей;  возможно
отсутсвие детей или наличие только одного потомка.

     Узлы  создаются таким образом, что левое поддерево каж-
дого узла содержит только те слова, которые меньше  слова  в
этом узле, а правое поддерево только те слова, которые боль-
ше. Чтобы определить, находится ли новое слово уже в дереве,
начинают  с корня и сравнивают новое слово со словом, храня-
щимся в этом узле. Если слова совпадают, то вопрос  решается
утвердительно.  Если  новое  слово меньше слова в дереве, то
переходят к рассмотрению левого потомка; в противном  случае
исследуется  правый потомок. Если в нужном направлении пото-
мок отсутствует, то значит новое слово не находится в дереве
и  место  этого недостающего потомка как раз и является мес-
том, куда следует поместить новое слово. Поскольку поиск  из
любого узла приводит к поиску одного из его потомков, то сам
процесс поиска по существу является рекурсивным. В соответс-
твии  с  этим  наиболее естественно использовать рекурсивные
процедуры ввода и вывода.
     Возвращаясь назад к описанию узла, ясно, что это  будет
структура с четырьмя компонентами:

  struct tnode { /* the basic node */
    char *word; /* points to the text */
    int   count; /* number of occurrences */
    struct tnode *left; /* left child */
    struct tnode *right; /* right child */
  } ;

     Это "рекурсивное" описание узла может показаться риско-
ванным, но на самом деле оно вполне корректно. Структура  не
имеет права содержать ссылку на саму себя, но

  struct tnode *left;

описывает left как указатель на узел, а не как сам узел.
     Текст  самой  программы оказывается удивительно малень-
ким, если, конечно, иметь в  распоряжении  набор  написанных
нами ранее процедур, обеспечивающих нужные действия. Мы име-
ем в виду функцию getword для извлечения  каждого  слова  из
файла ввода и функцию alloc для выделения места для хранения
слов.
     Ведущая программа просто считывает слова с помощью фун-
кции getword и помещает их в дерево, используя функцию tree.

  #define   MAXWORD   20
  main()    /* word freguency count */
  {
      struct tnode *root, *tree();
      char word[maxword];
      int   t;
      root = NULL;
      while ((t = getword(word, maxword)) | = EOF)
         if (t == letter)
              root = tree(root, word);
      treeprint(root);
  }

     Функция tree сама по себе проста. Слово передается фун-
кцией main к верхнему уровню (корню) дерева. На каждом этапе
это  слово сравнивается со словом, уже хранящимся в этом уз-
ле, и с помощью рекурсивного обращения к tree  просачивается
вниз либо к левому, либо к правому поддереву. В конце концов
это слово либо совпадает с каким-то словом, уже  находящимся
в  дереве  (в этом случае счетчик увеличивается на единицу),
либо программа натолкнется на нулевой указатель,  свидетель-
ствующий  о необходимости создания и добавления к дереву но-
вого узла. В случае создания нового узла функция tree  возв-
ращает  указатель этого узла, который помещается в родитель-
ский узел.

  struct tnode *tree(p, w)
         /* install w at or below p */
  struct tnode *p;
  char *w;
  {
     struct tnode *talloc();
     char *strsave();
     int cond;
     if (p == NULL) { /* a new word
        has arrived */
          p == talloc(); /* make a new node */
          p->word = strsave(w);
          p->count = 1;
          p->left = p->right = NULL;
  }  else if ((cond = strcmp(w, p->word)) == 0)
          p->count++;     /* repeated word */
      else if (cond < 0)/* lower goes into left subtree */
          p->left = tree(p->left, w);
  else            /* greater into right subtree */
          p->right = tree(p->right, w);
  return(p);
  }

     Память для нового узла выделяется функцией talloc,  яв-
ляющейся  адаптацией для данного случая функции alloc, напи-
санной нами ранее. Она возвращает указатель свободного прос-
транства,  пригодного  для  хранения нового узла дерева. (Мы
вскоре обсудим это подробнее). Новое слово копируется  функ-
цией  strsave в скрытое место, счетчик инициализируется еди-
ницей, и указатели обоих потомков полагаются  равными  нулю.
Эта часть программы выполняется только при добавлении нового
узла к ребру дерева. Мы здесь опустили  проверку  на  ошибки
возвращаемых функций strsave и talloc значений (что неразум-
но для практически работающей программы).
     Функция treeprint печатает  дерево,  начиная  с  левого
поддерева;  в каждом узле сначала печатается левое поддерево
(все слова, которые младше этого слова), затем само слово, а
затем  правое поддерево (все слова, которые старше). Если Вы
неуверенно оперируете с рекурсией, нарисуйте дерево  сами  и
напечатайте  его  с  помощью функции treeprint ; это одна из
наиболее ясных рекурсивных процедур, которую можно найти.

  treeprint (p) /* print tree  p  recursively */
  struct tnode *p;
  {
     if (p != NULL)    {
        treeprint (p->left);
        printf("%4d %s\n", p->count, p->word);
        treeprint (p->right);
     }

  }

     Практическое замечание: если дерево становится  "несба-
лансированным"  из-за того, что слова поступают не в случай-
ном порядке, то время работы программы может  расти  слишком
быстро.  В худшем случае, когда поступающие слова уже упоря-
дочены, настоящая программа осуществляет дорогостоящую  ими-
тацию  линейного поиска. Существуют различные обобщения дво-
ичного дерева, особенно 2-3 деревья и avl  деревья,  которые
не  ведут  себя так "в худших случаях", но мы не будем здесь
на них останавливаться.
     Прежде чем расстаться с этим примером, уместно  сделать
небольшое отступление в связи с вопросом о распределении па-
мяти. Ясно, что в программе  желательно  иметь  только  один
распределитель  памяти,  даже  если ему приходится размещать
различные виды об'ектов. Но если мы хотим использовать  один
распределитель  памяти  для  обработки запросов на выделение
памяти для указателей на переменные типа char и для указате-
лей на struct tnode, то при этом возникают два вопроса. Пер-
вый: как выполнить то существующее на  большинстве  реальных
машин  ограничение,  что  об'екты  определенных типов должны
удовлетворять требованиям выравнивания (например, часто  це-
лые  должны размещаться в четных адресах)? Второй: как орга-
низовать описания, чтобы справиться с тем, что функция alloc
должна возвращать различные виды указателей ?
     Вообще  говоря, требования выравнивания легко выполнить
за счет выделения некоторого  лишнего  пространства,  просто
обеспечив  то,  чтобы распределитель памяти всегда возвращал
указатель, удовлетворяющий всем  ограничениям  выравнивания.
Например,  на  PDP-11 достаточно, чтобы функция alloc всегда
возвращала четный указатель, поскольку в четный адрес  можно
поместить  любой тип об'екта. единственный расход при этом -
лишний символ при запросе  на  нечетную  длину.  Аналогичные
действия  предпринимаются  на других машинах. Таким образом,
реализация alloc может не оказаться переносимой, но  ее  ис-
пользование  будет  переносимым. Функция alloc из главы 5 не
предусматривает никакого определенного выравнивания; в главе
8 мы продемонстрируем, как правильно выполнить эту задачу.
     Вопрос описания типа функции alloc является мучительным
для любого языка, который серьезно относится к проверке  ти-
пов. Лучший способ в языке "C" - об'явить, что alloc возвра-
щает указатель на переменную типа char, а затем явно  преоб-
разовать  этот указатель к желаемому типу с помощью операции
перевода типов. Таким образом, если описать p в виде

  char *p;

то

  (struct tnode *) p

преобразует его в выражениях в указатель на  структуру  типа
tnode . Следовательно, функцию talloc можно записать в виде:

  struct tnode *talloc()
  {
     char *alloc();

     return ((struct tnode *) alloc(sizeof(struct tnode)));
  }

это  более  чем  достаточно для работающих в настоящее время
компиляторов, но это и самый безопасный путь с учетом будую-
щего.

Упражнение 6-4.
Напишите  программу, которая читает "C"-программу и печатает
в алфавитном порядке каждую группу имен переменных,  которые
совпадают в первых семи символах, но отличаются где-то даль-
ше. (Сделайте так, чтобы 7 было параметром).

Упражнение 6-5.
Напишите программу выдачи перекрестных ссылок, т.е. програм-
му, которая печатает список всех слов документа и для каждо-
го из этих слов печатает список номеров строк, в которые это
слово входит.

Упражнение 6-6.
Напишите  программу,  которая печатает слова из своего файла
ввода, расположенные в порядке убывания частоты  их  появле-
ния. Перед каждым словом напечатайте число его появлений.

6.6. Поиск в таблице.

     Для   иллюстрации   дальнейших  аспектов  использования
структур в этом разделе мы напишем программу, представляющую
собой  содержимое пакета поиска в таблице. Эта программа яв-
ляется типичным представителем подпрограмм  управления  сим-
вольными таблицами макропроцессора или компилятора. Рассмот-
рим, например, оператор #define языка "C". Когда встречается
строка вида

  #define YES    1

то  имя yes и заменяющий текст 1 помещаются в таблицу. Позд-
нее, когда имя yes появляется в операторе вида

  inword = yes;

oно должно быть замещено на 1.

     Имеются две основные процедуры, которые управляют  име-
нами и заменяющими их текстами. Функция install(s,t) записы-
вает имя s и заменяющий текст t в таблицу; здесь s и t прос-
то символьные строки. Функция lookup(s) ищет имя s в таблице
и возвращает либо указатель того места, где это имя найдено,
либо null, если этого имени в таблице не оказалось.
     При  этом используется поиск по алгоритму хеширования -
поступающее имя преобразуется в маленькое положительное чис-
ло, которое затем используется для индексации массива указа-
телей. Элемент массива указывает на начало цепочных  блоков,
описывающих  имена,  которые имеют это значение хеширования.
Если никакие имена при хешировании не получают этого  значе-
ния, то элементом массива будет null.
     Блоком цепи является структура, содержащая указатели на
соответствующее имя, на заменяющий текст и на следующий блок
в  цепи. Нулевой указатель следующего блока служит признаком
конца данной цепи.

  struct nlist  {  /* basic table entry */
       char *name;
       char *def;
       struct nlist *next; /* next entry in chain */
  } ;


Массив указателей это просто

  define    hashsize     100
  tatic struct nlist *hashtab[hashsize] /* pointer table */

     Значение функции хеширования, используемой обеими функ-
циями  lookup  и  install , получается просто как остаток от
деления суммы символьных значений строки на размер  массива.
(Это  не самый лучший возможный алгоритм, но его достоинство
состоит в исключительной простоте).

  hash(s)   /* form hash value for string */
  char *s;
  {
   int hashval;

   for (hashval = 0; *s != '\0'; )
       hashval += *s++;
   return(hashval % hashsize);
  }

     В результате процесса  хеширования  выдается  начальный
индекс  в  массиве  hashtab  ; если данная строка может быть
где-то найдена, то именно в цепи блоков, начало которой ука-
зано там. Поиск осуществляется функцией lookup. Если функция
lookup находит, что данный элемент уже присутствует, то  она
возвращает  указатель  на  него; если нет, то она возвращает
NULL.

  struct nlist *lookup(s) /* look for s in hashtab */
  char *s;
  {
  struct nlist *np;

  for (np = hashtab[hash(s)]; np != NULL;np=np->next)
      if (strcmp(s, np->name) == 0)
    return(np);  /* found it */
  return(NULL);    /* not found */

     Функция install использует функцию lookup для определе-
ния,  не  присутствует  ли уже вводимое в данный момент имя;
если это так, то новое определение должно вытеснить  старое.
В  противном случае создается совершенно новый элемент. Если
по какой-либо причине для нового элемента больше нет  места,
то функция install возвращает NULL.

  struct nlist *install(name, def) /* put (name, def) */
  char *name, *def;
  {
  struct nlist *np, *lookup();
  char *strsave(), *alloc();
  int hashval;

  if((np = lookup(name)) == NULL) { /* not found */
   np = (struct nlist *) alloc(sizeof(*np));
   if (np == NULL)
      return(NULL);
   if ((np->name = strsave(name)) == NULL)
      return(NULL);
  hashval = hash(np->name);
  np->next = hashtab[hashval];
  hashtab[hashval] = np;
  }  else        /* already there */
      free((np->def);/* free previous definition */
  if ((np->def = strsave(def)) == NULL)
      return (NULL);
  return(np);
   }

     Функция strsave просто копирует строку, указанную в ка-
честве аргумента, в место хранения, полученное в  результате
обращения к функции alloc. Мы уже привели эту функцию в гла-
ве 5. Так как обращение к функции alloc и free могут  проис-
ходить  в  любом порядке и в связи с проблемой выравнивания,
простой вариант функции alloc из главы 5 нам больше не  под-
ходит; смотрите главы 7 и 8.

Упражнение 6-7.
Напишите  процедуру, которая будет удалять имя и определение
из таблицы, управляемой функциями lookup и install.

Упражнение 6-8.
Разработайте простую, основанную на функциях этого  раздела,
версию  процессора  для обработки конструкций #define , при-
годную для использования с "C"-программами. Вам могут  также
оказаться полезными функции getchar и ungetch.

6.7. Поля.

     Когда  вопрос  экономии памяти становится очень сущест-
венным, то может оказаться необходимым помещать в  одно  ма-
шинное  слово несколько различных об'ектов; одно из особенно
распросраненных употреблений - набор однобитовых признаков в
применениях, подобных символьным таблицам компилятора. внеш-
не обусловленные форматы данных, такие как интерфейсы  аппа-
ратных средств также зачастую предполагают возможность полу-
чения слова по частям.
     Представьте себе фрагмент компилятора, который работает
с  символьной  таблицей.  С каждым идентификатором программы
связана определенная информация, например, является  он  или
нет  ключевым  словом,  является ли он или нет внешним и/или
статическим и т.д. Самый компактный способ закодировать  та-
кую информацию - поместить набор однобитовых признаков в от-
дельную переменную типа char или int.
     Обычный способ, которым это делается, состоит в опреде-
лении  набора "масок", отвечающих соответствущим битовым по-
зициям, как в

  #define   KEYWORD   01
  #define   EXTERNAL  02
  #define   STATIC    04

(числа должны быть степенями двойки). Тогда обработка  битов
сведется к "жонглированию битами" с помощью операций сдвига,
маскирования и дополнения, описанных нами в главе 2.
     Некоторые часто встречающиеся идиомы:

  flags |= external  | static;

включает биты external и static в flags, в то время как

  flags &= ~(еxternal | static);

их выключает, а

  if ((flags & (external | static)) == 0) ...

истинно, если оба бита выключены.
     Хотя этими идиомами легко овладеть, язык "C" в качестве
альтернативы  предлагает возможность определения и обработки
полей внутри слова непосредственно, а не посредством побито-
вых  логических  операций.  Поле  -  это набор смежных битов
внутри одной переменной типа int.  Синтаксис  определения  и
обработки  полей  основывается на структурах. Например, сим-
вольную таблицу конструкций #define, приведенную выше, можно
бы было заменить определением трех полей:

    struct  {
  unsigned is_keyword : 1;
  unsigned is_extern  : 1;
  unsigned is_static  : 1;
    }     flags;

здесь определяется переменная с именем flags, которая содер-
жит три 1-битовых поля. Следующее за двоеточием число задает
ширину  поля  в битах. Поля описаны как unsigned, чтобы под-
черкнуть, что они действительно будут величинами без знака.
     На отдельные поля можно ссылаться, как flags.is_statie,
flags. is_extern, flags.is_keyword И т.д., то есть точно так
же, как на другие члены структуры. Поля ведут  себя  подобно
небольшим целым без знака и могут участвовать в арифметичес-
ких выражениях точно так же, как и другие целые. Таким обра-
зом, предыдущие примеры более естественно переписать так:

  flags.is_extern = flags.is_static = 1;

для включения битов;

  flags.is_extern = flags.is_static = 0;

для выключения битов;

  if (flags.is_extern == 0 &&flags.is_static == 0)...

для их проверки.
     Поле  не  может перекрывать границу int; если указанная
ширина такова, что это должно случиться, то поле  выравнива-
ется  по  границе следующего int. Полям можно не присваивать
имена; неименованные поля (только двоеточие  и  ширина)  ис-
пользуются  для  заполнения свободного места. Чтобы вынудить
выравнивание на границу следующего int,  можно  использовать
специальную ширину 0.
     При  работе  с  полями имеется ряд моментов, на которые
следует обратить внимание. По-видимому наиболее существенным
является  то, что отражая природу различных аппаратных сред-
ств, распределение полей на некоторых машинах осуществляется
слева  направо,  а на некоторых справа налево. Это означает,
что хотя поля очень полезны для работы с  внутренне  опреде-
ленными структурами данных, при разделении внешне определяе-
мых данных следует тщательно рассматривать вопрос о том, ка-
кой конец поступает первым.
     Другие ограничения, которые следует  иметь в  виду:
поля  не  имеют  знака;  они  могут  храниться  только  в
переменных  типа  int  (или,   что   эквивалентно,   типа
unsigned);  они  не  являются  массивами;  они  не  имеют
адресов, так что к ним не применима операция &.

6.8. Об'единения.

     Об'единения  -  это переменная, которая в различные мо-
менты времени может содержать об'екты разных типов и  разме-
ров,  причем компилятор берет на себя отслеживание размера и
требований выравнивания.  Об'единения  представляют  возмож-
ность  работать  с  различными видами данных в одной области
памяти, не вводя в программу никакой  машинно-зависимой  ин-
формации.
     В  качестве примера, снова из символьной таблицы компи-
лятора, предположим, что константы могут  быть  типа  int  ,
float или быть указателями на символы. значение каждой конк-
ретной константы должно храниться в переменной  соотвествую-
щего  типа,  но все же для управления таблицей самым удобным
было бы, если это значение занимало бы один и тот  же  об'ем
памяти  и  хранилось  в том же самом месте независимо от его
типа. это и является назначением об'единения - выделить  от-
дельную  переменную,  в  которой можно законно хранить любую
одну из переменных нескольких типов. Как и в  случае  полей,
синтаксис основывается на структурах.

  union u_tag {
  int ival;
  float fval;
  char *pval;
  }  uval;

     Переменная  uval  будет  иметь  достаточно большой раз-
мер,чтобы хранить наибольший из трех  типов,  независимо  от
машины, на которой осуществляется компиляция, - программа не
будет зависить от характеристик аппаратных средств. Любой из
этих трех типов может быть присвоен uvar и затем использован
в выражениях, пока такое использование совместимо: извлекае-
мый  тип должен совпадать с последним помещенным типом. Дело
программиста - следить за тем, какой тип хранится в  об'еди-
нении  в данный момент; если что-либо хранится как один тип,
а извлекается как другой, то результаты  будут  зависеть  от
используемой машины.
     Синтаксически доступ к членам об'единения осуществляет-
ся следующим образом:

   имя об'единения.член
   --------------------

или

   указатель об'единения ->член
   ----------------------------

то есть точно так же, как и в случае структур. если для отс-
леживания  типа, хранимого в данный момент в uval, использу-
ется переменная utype,  то  можно  встретить  такой  участок
программы:

  if (utype == int)
  printf("%d\n", uval.ival);
  else if (utype == float)
  printf("%f\n", uval.fval);
  else if (utype == string)
  printf("%s\n", uval.pval);
  else
  printf("bad type %d in utype\n", utype);

     Об'единения могут появляться внутри структур и массивов
и наоборот. Запись  для  обращения  к  члену  об'единения  в
структуре  (или  наоборот) совершенно идентична той, которая
используется во вложенных структурах.  например,  в  массиве
структур, определенным следующим образом

  struct {
  char *name;
  int flags;
  int utype;
  union {
  int ival;
  float fval;
  char *pval;
  }  uval;
   }  symtab[nsym];

     На переменную ival можно сослаться как

  symtab[i].uval.ival

а на первый символ строки pval как

  *symtab[i].uval.pval

     В  сущности  об'единение является структурой, в которой
все члены имеют нулевое смещение. Сама структура  достаточно
велика,  чтобы  хранить "самый широкий" член, и выравнивание
пригодно для всех типов, входящих в  об'единение.  Как  и  в
случае структур, единственными операциями, которые в настоя-
щее время можно проводить с об'единениями, являются доступ к
члену и извлечение адреса; об'единения не могут быть присво-
ены, переданы функциям или возвращены ими. указатели об'еди-
нений можно использовать в точно такой же манере, как и ука-
затели структур.
     Программа распределения памяти, приводимая в  главе  8,
показывает,  как  можно использовать об'единение, чтобы сде-
лать некоторую переменную выровненной по определенному  виду
границы памяти.

6.9. Определение типа

     В   языке  "C"  предусмотрена  возможность,  называемая
typedef для введения новых имен для типов данных.  Например,
описание

  typedef int length;

делает имя length синонимом для int. "Тип" length может быть
использован в описаниях, переводов типов и т.д. Точно  таким
же образом, как и тип int:

  length   len, maxlen;
  length   *lengths[];

аналогично описанию

  typedef char *string;

делает  string синонимом для char*, то есть для указателя на
символы, что затем можно использовать в описаниях вида

  string p, lineptr[lines], alloc();

     Обратите  внимание,  что  об'являемый   в   конструкции
typedef тип появляется в позиции имени переменной, а не сра-
зу за словом typedef. Синтаксически конструкция typedef  по-
добна описаниям класса памяти extern, static и т. Д. мы так-
же использовали прописные буквы, чтобы яснее выделить имена.
     В качестве более сложного примера мы используем  конст-
рукцию  typedef для описания узлов дерева, рассмотренных ра-
нее в этой главе:

  typedef struct tnode {     /* the basic node */
  char *word; /* points to the text */
  int count; /* number of occurrences */
  struct tnode *left;     /* left child */
  struct tnode *right;    /* right child */
  }  treenode, *treeptr;

     В  результате  получаем  два  новых   ключевых   слова:
treenode  (структура)  и  treeptr  (указатель на структуру).
Тогда функцию talloc можно записать в виде

  treeptr talloc()
  {
     char *alloc();
     return((treeptr) alloc(sizeof(treenode)));
  }

     Необходимо подчеркнуть, что описание typedef не  приво-
дит  к  созданию нового в каком-либо смысле типа; оно только
добавляет новое имя для некоторого существующего  типа.  при
этом не возникает и никакой новой семантики: описанные таким
способом переменные обладают точно теми же свойствами, что и
переменные, описанные явным образом. По существу конструкция
typedef сходна с #define за исключением того, что она интер-
претируется компилятором и потому может осуществлять подста-
новки текста, которые выходят за пределы  возможностей  мак-
ропроцессора языка "C". Например,

  typedef int (*pfi) ();

создает  тип pfi для "указателя функции, возвращающей значе-
ние типа int", который затем можно было  бы  использовать  в
программе сортировки из главы 5 в контексте вида

  pfi strcmp, numcmp, swap;


     Имеются  две  основные  причины   применения   описаний
typedef. Первая причина связана с параметризацией программы,
чтобы облегчить решение проблемы переносимости. Если для ти-
пов данных, которые могут быть машинно-зависимыми, использо-
вать описание typedef, то при переносе программы  на  другую
машину придется изменить только эти описания. Одна из типич-
ных ситуаций состоит в использовании определяемых с  помощью
typedef  имен  для  различных  целых величин и в последующем
подходящем выборе типов short, int и long для  каждой  имею-
щейся машины.
     Второе  назначение typedef состоит в обеспечении лучшей
документации для программы - тип с именем treeptr может ока-
заться более удобным для восприятия, чем тип, который описан
только как указатель сложной структуры.
     И, наконец, всегда существует вероятность, что в  буду-
щем  компилятор  или  некоторая  другая программа, такая как
lint, сможет использовать содержащуюся в  описаниях  typedef
информацию  для проведения некоторой дополнительной проверки
программы.
</pre>
</body>
</html>
