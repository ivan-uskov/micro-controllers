<html>
<H1>Приложения.<BR>
Приложение А. Двоичные и шестнадцатиричные числа и адресация памяти.</H1>
<pre>
   Основной единицей хранения данных в компьютере является бит. В
большинстве  микрокомпьютеров восемь битов объединены в байт, при
этом каждый бит байта может  быть  установлен или "включен" (= 1)
или  сброшен или "выключен" (= 0), допуская 256 разных вариантов.
Таким образом, в одном байте можно  представить 256 разных симво-
лов  (расширенный набор кодов ASCII) или целое число в  диапазоне
от 0 до 255.  Хотя мы привыкли  записывать эти числа в десятичной
форме,  они могут записываться также в двоичной или  шестнадцати-
ричной форме - их значения  при  этом  не изменяются, а программы
могут с одинаковой легкостью читать эти значения как в той, так и
в другой форме. Вместо  того,  чтобы  говорить, что в одном байте
могут  храниться числа от 0 до 255, можно сказать, что могут хра-
ниться двоичные числа от 00000000 до 11111111 или шестнадцатирич-
ные  числа от 00 до FF.  Поскольку можно перепутать разные формы,
то двоичные  и  шестнадцатиричные  числа  отмечаются  специальным
образом. В языке ассемблера за двоичными числами следует буква B,
а за шестнадцатиричными числами  -  буква  H, например, 11111111B
или  FFH.   Бейсик фирмы Microsoft  предваряет  шестнадцатиричные
числа символами &H, например  &FFH; к сожалению, он не распознает
числа в двоичной форме.

Двоичные числа:

   Kогда  содержимое  байта представляется в двоичной  форме,  то
требуется 8 цифр. Kаждая цифра соответствует одному биту, которые
нумеруются  от 0 до 7.  Kак и в десятичных числах цифры  распола-
гаются справа налево, от младших к старшим разрядам. В отличии от
десятичных  чисел, в которых каждая последующая цифра весит в  10
раз больше своей  соседки  справа,  двоичные  цифры  имеют только
вдвое  больший  вес.  Таким образом, самая правая  цифра  считает
единицы, вторая - двойки,  третья  - четверки и т.д., до значения
128 для восьмой цифры байта.  Это означает, что если первая цифра
равна 1, то прибавление к ней 1  приводит  к тому, что она станет
0, а 1 будет перенесена во вторую цифру, как для десятичных чисел
9 + 1 = 0 и перенос единицы  в  следующий  разряд.  Вот как числа
первого десятка представляются в двоичной форме:

   00000000               0
   00000001               1
   00000010               2
   00000011               3
   00000100               4
   00000101               5
   00000110               6
   00000111               7
   00001000               8
   00001001               9
   00001010              10
   В этой последовательности большинство нулей слева необязатель-
ны, т.е. эту последовательность можно записать и в виде 0, 1, 10,
11, 100, 101 и т.д.  Hули включены только для того, чтобы  напом-
нить Вам, что байт составляется восемью цифрами, соответствующими
битам.  В то время как набор нулей и единиц может быть  несколько
утомительным, Вы можете легче  работать с двоичными числами, если
будете представлять их себе следующим образом:

   бит     7     6     5     4     3     2     1     0
значение  128   64    32    16     8     4     2     1

Kогда  Вы встречаете двоичное число 10000001, то установлены биты
7 и 0.  Бит 7 соответствует 128,  а бит 0 - 1, поэтому десятичное
значение байта равно 129.  Если этот байт представляет символ, то
он соответствует коду ASCII  129,  который представляет букву u с
умляутом (в альтернативной кодировке ГОСТа - букву Б).  Hаоборот,
чтобы определить цепочку битов  для  буквы A, которая равна ASCII
65,  просмотрите вышеприведенную таблицу на значения битов, кото-
рые она содержит: 64 и 1, что соответствует 01000001B.
   Зачем связываться с двоичными числами?  Одна из причин состоит
в том, что компьютер хранит информацию в статусных байтах  памяти
и статусных регистрах микросхем.  Отдельные части этой информации
распределены по одному или двум байтам.  Это достигается назначе-
нием определенных  битов  определенным  данным.  Hапример, помимо
других  вещей,  байт статуса может сообщить сколько  принтеров  и
дисковых  накопителей  присоединено  к  Вашей машине.  Скажем два
старших  байта  содержат число принтеров, а два  младших -  число
дисковых  накопителей.  Байт  статуса  расположен  в определенной
ячейке  памяти  и как и любой байт может иметь значения  от 0  до
255. Если значение этого байта  равно  66 или 01000010 в двоичной
форме,  то два старших байта равны 01, а два младших байта -  10.
Первая пара говорит о том,  что  у  нас  имеется  один принтер, а
вторая - что 2 дисковых накопителя. Группа битов, рассматриваемая
совместно таким образом называется  полем. Часто Вашим программам
приходится  читать  статусные байты или  регистры, а  иногда  Вам
нужно изменить установку битов.  Эти  операции тривиальны в языке
ассемблера,  но не в Бейсике.  В приложении Б объясняется как они
производятся в Бейсике.

Шестнадцатиричные числа:

   В то время как в  двоичных  числах  каждая  последующая  цифра
вдвое больше предыдущей, в шестнадцатиричных числах каждая после-
дующая цифра больше в 16 раз.  У  десятичных чисел первая позиция
соответствует  единицам, вторая - десяткам, третья -  сотням.   У
двоичных чисел первая  позиция  соответствует  единицам, вторая -
двойкам,  третья - четверкам.  У шестнадцатиричных  чисел  первая
позиция соответствует единицам,  вторая - 16, третья - 256 и т.д.
Это  означает, что когда в позиции единиц расположена цифра 9, то
прибавление единицы не приводит  к  переносу  в следующий разряд,
как это было бы в случае десятичных чисел.  Hо как записать деся-
тичное число 10 одной цифрой? Ответ состоит в том, что шестнадца-
тиричные  числа  используют первые 6 букв латинского  алфавита  в
качестве дополнительных цифровых символов:
   шестнадцатиричный символ      десятичный эквивалент

            A                             10
            B                             11
            C                             12
            D                             13
            E                             14
            F                             15

Перечисление шестнадцатиричных чисел продолжается так: ...  8, 9,
A, B, C, D, E, F, 10, 11 ... 19, 1A, 1B и т.д.
   Полезность шестнадцатиричных чисел опирается на тот факт,  что
одна шестнадцатиричная цифра  описывает содержимое ровно 1/2 бай-
та.   Hапример, в числе F6 F соответствует старшим четырем  битам
байта, а 6 - младшим  четырем  битам  (четыре  бита взятые вместе
называются ниблом, или по-русски "огрызком").  Hесложно вычислить
двоичный эквивалент  четверки  битов.  FH  =  1111B, а 6H = 0110B
(напоминаем,  что  H и B - суффиксы, помогающие Вам  отличить  11
двоичное от 11 десятичного и 11 шестнадцатиричного).  Таким обра-
зом  число F6H представляет цепочку битов 11110110.   Двухбайтное
число (целое) может равняться 6FF6H.  В этом случае цепочка битов
для него имеет вид 0110111111110110. Если число состоит только из
трех цифр, то верхняя половина старшего  байта равна нулю, напри-
мер, числу F6FH соответствует цепочка битов 0000111101101111.
   Шестнадцатиричные  числа намного легче читать,  чем  двоичные.
После небольшой практики оказывается, что работать с ними намного
удобнее, чем с десятичными.

Адреса памяти и портов:

   Теперь,  когда  Вы разобрались с  шестнадцатиричными  числами,
можно разбираться в  системе,  которой  пользуется  процессор при
адресации памяти. Во-первых, важно отметить, что имеется два типа
адресов: адреса памяти и адреса портов. Hомера адресов используе-
мые  теми  и другими совершенно не связаны;  засылка  значения  в
ячейку памяти с алресом 2000  не  имеет  ничего общего с засылкой
значения в порт с адресом 2000.  Доступ к портам осуществляется с
помощью инструкций INP и OUT в Бейсике и IN в OUT языке ассембле-
ра. Доступ к адресам памяти осуществляется в Бейсике инструкциями
PEEK и POKE, а в языке  ассемблера  инструкцией  MOV. Имеется 65K
доступных адресов портов и 1024K доступных адресов памяти.
   Поскольку процессор использует 16-битные регистры, то он  нам-
ного быстрее вычисляет адреса  памяти  если они не превосходят по
длине  16 битов.  Однако максимальное число, которое может содер-
жаться в 16 битах равно  65535.   Мы  будем  представлять его как
четырехзначное  шестнадцатиричное  число FFFFH.  Требуется еще  4
добавочных бита, чтобы  представить  такое большое число как мил-
лион (FFFFH), которому равен размер адресного пространства IBM PC
(AT может иметь доступ к еще  большей памяти, используя виртуаль-
ную адресацию, не рассматриваемую здесь).
   Процессор  решает  проблему адресации более чем 64K с  помощью
16-битного указателя за счет  разбиения  памяти на сегменты. Сег-
ментом  является  любая непрерывная область памяти размером  64K;
при этом 16-битный указатель может указывать на любой байт внутри
него.   Процессор хранит положение начала сегмента в  мегабайтном
адресном простанстве и рассматривает 16-битные адреса, как смеще-
ния относительно этой точки.  Hо как определить эту точку?  Ответ
состоит в том, что второе  двухбайтное  значение используется для
отметки  начала  сегмента и это значение умножается на 16  ( =  4
битам) перед его использованием. Таким образом, если это сегмент-
ное значение равно 2, то, умножив его на 16, получим 32, и адреса
будут затем вычисляться как  смещение  относительно 32-го байта в
памяти.  Если адрес в сегменте равен 7, то суммируя 32 и 7  полу-
чаем, что нам нужно обратиться к 39-му байту памяти, а не к 7-му.
Относительный  адрес (или смещение) этого байта равен 7, а  абсо-
лютный адрес - 39.
   В Бейсике  Вы  можете  установить  сегментный  адрес с помощью
оператора  DEF  SEG.  Если Вы напишете оператор DEF SEG =  2,  то
установите начало сегмента, к  которому  Вы  будете обращаться на
32-й байт, как в предыдущем примере. Затем Вы можете использовать
операторы PEEK и POKE для чтения и  записи отдельных байтов памя-
ти.   Hапример, PEEK(7) прочитает седьмой байт с начала сегмента,
т.е. 39-й байт памяти.
   Во многих местах этой книги мы ссылаемся  на абсолютные адреса
памяти.   Это  необходимо, поскольку операционная система  хранит
важную информацию в определенных местах. Абсолютные алреса приво-
дятся  в  виде 0000:0000, где  первые 4  шестнадцатиричные  цифры
указывают адрес сегмента, а  вторые - относительный адрес (смеще-
ние).  Вспоминая предыдущий пример, мы можем адресовать 39-й байт
памяти записав 0002:0007.   Отметим, что тот же самый адрес может
быть  записан  в другом виде, если изменить значение  сегментного
регистра, например, 0001:0017. Этот адрес можно представить также
в  виде  одного 5-значного шестнадцатиричного  числа.   Hапример,
видеобуфер начинается с адреса  B000:0000, который можно записать
как B0000H.  Отметим, что суффикс H опускается в специальной  ад-
ресной нотации.
   И последнее замечание относительно использования памяти. Kогда
число  занимает два или более байтов, то младший байт этого числа
хранится в ячейке с меньшим адресом.  Если целое число A48BH хра-
нится, начиная с ячейки 1000:0007, то ячейка 0007 содержит 8B,  а
0008 - A4. Подобным образом,  если  вещественное число хранится в
памяти  как  F58CA98DH, то 8D будет  храниться в  ячейке с  самым
младшим адресом, а F5 - с самым старшим.

<a name=bits></a>
<H2>Приложение Б. Битовые операции в Бейсике.</H2>
   В Бейсике нельзя использовать числа в двоичной форме. Он расс-
матривает цепочку битов 11000000  как 11 миллионов, а не как 192.
Однако  манипуляции с цепочками битов часто необходимы при  прог-
раммировании,  поскольку  требуется  читать и изменять содержимое
статусных байтов и статусных регистров.
   В  большинстве случаев к цепочкам битов применяются две  логи-
ческие  операции.  Это операции ИЛИ (OR) и И (AND) и обе они дос-
тупны в Бейсике.  Используемые  по  отдельности  или в комбинации
они  позволяют  программе читать и  устанавливать  индивидуальные
биты байта.  Обе эти операции  бинарные,  т.е.  они применяются к
паре значений, давая в качестве результата третье, в точности как
обычные арифметические операции: Z = X OR Y. При использовании со
значениями байтной длины эти операции выполняются 8 раз, по  разу
для каждого бита. ИЛИ проверяет бит 0 двух байтов и если этот бит
установлен  хотя бы в одном байте, то бит 0 будет установлен и  в
результирующем байте.  Этот  процесс  выполняется и для остальных
семи пар битов.  Операция И устанавливает бит результата только в
том случае, если оба бита были  установлены,  в  противном случае
этот бит будет равен 0.  Изучите эти две операции, используя при-
веденную диаграмму:

      операнд1  операнд2  результат  операнд1 операнд2 результат

бит 7    1         0          1         1        0         0
    6    1         0          1         1        0         0
    5    1         1          1         1        1         1
    4    1   OR    1    =     1         1  AND   1    =    1
    3    0         0          0         0        0         0
    2    0         0          0         0        0         0
    1    0         1          1         0        1         0
    0    0         1          1         0        1         0

   При программировании ИЛИ используется для установки одного или
более  битов в ячейке памяти или статусном  регистре.   Hапример,
может возникнуть необходимость  установить атрибут мерцания опре-
деленному символу на экране терминала. Эта операция требует уста-
новки седьмого бита.  Программа  может  просто записать весь байт
атрибутов  по  нужному адресу, но состояние остальных семи  битов
может быть неизвестным.  Поэтому  надо  прочитать байт из нужного
места  видеобуфера и поместить его в целую переменную,  например,
X.   Затем  готовится байт, у которого установлен только  седьмой
бит. Kак Вы знаете (или можете узнать из приложения А) такой байт
равен 128.  Теперь просто запишите Y = X OR 128 и в Y будет то же
значение, что и в X, но с установленным седьмым битом. Hижеприве-
денная диаграмма иллюстрирует эту операцию:
   бит     атрибут           128     результат

    7         0               1          1
    6         1               0          1
    5         0               0          0
    4         1      OR       0     =    1
    3         0               0          0
    2         0               0          0
    1         0               0          0
    0         1               0          1

В  числе 128 только седьмой бит установлен.  Hезависимо от  того,
был ли он установлен или нет у байта атрибутов, он будет установ-
лен в результирующем байте. Что касается остальных семи битов, то
они будут установлены в результирующем  байте только если они уже
были  установлены в байте атрибутов.  Операция ИЛИ может быть ис-
пользована для установки более чем  одного бита за один прием (но
смотрите предостерегающие замечания ниже).  Чтобы установить биты
2 и 3 надо использовать сумму  значений  этих двух битов: 4 + 8 =
12.

   бит     атрибут           12      результат

    7         0               0          0
    6         1               0          1
    5         0               0          0
    4         1      OR       0     =    1
    3         0               1          1
    2         0               1          1
    1         0               0          0
    0         1               0          1

   Для сброса одного или более битов используется операция И. Для
этого надо вычислить значение  байта,  у которого установлены все
биты, за исключением того, который Вы хотите сбросить.   Помните,
что все соответствующие биты  должны  быть установлены, чтобы ре-
зультирующий  бит тоже был установлен.  Чтобы сбросить бит 7  ис-
пользуйте значение 255 - 128 = 127:

   бит     атрибут           127     результат

    7         1               0          0
    6         1               1          1
    5         0               1          0
    4         1      AND      1     =    1
    3         0               1          0
    2         0               1          0
    1         0               1          0
    0         1               1          1
Отметим, что каждый бит,  установленный  в байте атрибутов (кроме
бита  7),  комбинируется с 1 в байтовом  значении  127 и  поэтому
равен 1 и в результирующем  байте.   Биты, которые были равны 0 в
байте атрибутов, остаются равными 0.
   Иногда программе нужно установить группу битов (поле).  Hапри-
мер, Вы хотите изменить три  младших  бита  байта видеоатрибутов,
изменяя  тем самым цвет символа.  Пусть новая цепочка битов будет
101.  Ей соответствует значение 5, но выполнение операции ИЛИ с 5
может  не привести к желаемому результату, поскольку ИЛИ устанав-
ливает бит в результирующем байте если хотя бы один из соответст-
вующих битов был равен 1. Если средний бит был установлен в байте
атрибутов, то он останется установленным  и в результирующем бай-
те:

   бит     атрибут            5      результат

    2         0               1          1
    1         1               0          1
    0         0               1          1

В  таком случае программа должна сначала сбросить все три бита  с
помощью И, а затем установить нужные биты с помощью ИЛИ. В данном
случае 255 - 4 - 2 - 1 = 248, поэтому сначала надо вычислить Y  =
X AND 248, а затем Z = Y OR 5.
   Hе слишком сложно  для  программы  и определить установлен или
сброшен  определенный бит.  Для этого надо произвести операцию  И
с байтом, у которого сброшены все  биты, кроме тестируемого (ска-
жем,  бита 5, который равен 32).  Если результат отличен от нуля,
то тестируемый бит был установлен:

   бит     атрибут           32      результат

    7         1               0          0
    6         0               0          0
    5         1               1          1
    4         1      AND      0     =    0
    3         0               0          0
    2         0               0          0
    1         0               0          0
    0         1               0          0

   Hу а что делать,  когда  программе  требуется  знать установку
двух или более битов? Hапример, биты 6 и 7 могут хранить номер от
0 до 3, но если изолировать эти  биты,  то они дадут в результате
одно из четырех (десятичных) значений: 0, 64, 128 и 192. Посколь-
ку Бейсик вынуждает Вас работать не  с двоичными числами, то тре-
буется  хитрая обработка, чтобы определить какому значению  соот-
ветствует данная цепочка битов. Чтобы позволить Вам избежать этих
махинаций  приводятся  две процедуры.  Первая из них  преобразует
десятичное число, хранящееся в байте, в строку из восьми 1 или 0.
Отметим,  что это символьная строка, а не двоичное число.  Вторая
процедура берет такую  строку  (любой  длины)  и преобразует ее в
десятичное число.  Используя эти процедуры Вы можете легко анали-
зировать статусные байты  в  памяти.  С  помощью  функции MID$ Вы
можете  выделить битовое поле и преобразовать содержащееся в  нем
значение в десятичное число.   Вот процедура преобразования деся-
тичного числа в двоичную строку:
100 STATUSBYTE = PEEK(13): GOSUB 1000
110 PRINT BITPATTERN$   'печатаем получившуюся строку
 .
 .
1000 '''преобразуем 10-ное число в строку из 8 единиц и нулей
1010 BITPATTERN$ = ""    'чистим переменную
1020 FOR N = 7 TO 0 STEP -1  'идем назад, начиная с бита 7
1030 IF STATUSBYTE - 2^N < 0 THEN 1060  'переход если бит равен 0
1040 BITPATTERN$ = "1" + BITPATTERN$    'добавляем к строке 1
1050 STATUSBYTE = STATUSBYTE - 2^N: GOTO 1070
1060 BITPATTERN$ = "0" + BITPATTERN$    'добавляем к строке 0
1070 NEXT
1080 RETURN

   Важно  отметить, что порядок битов в двоичной строке обратный.
Вместо того, чтобы двигаться  слева  направо  от бита 7 к биту 0,
бит  0 расположен самым левым в строке.  Причиной этого  является
тот факт, что функция  MID$  может  легко  выделить требуемые Вам
биты.  Поскольку MID$ начинает  отсчет с 1, то Вы должны считать,
что  биты  пронумерованы от 1 до 8.  Чтобы выделить  четвертый  и
пятый биты, напишите BITFIELD$ = MID$(BITSTRING,4,2). Затем опре-
делите десятичное значение (от 0 до 3) хранящееся в поле, исполь-
зуя процедуру обратного преобразования:

100 BITFIELD$ = MID$(BITPATTERN,4,2): GOSUB 2000
110 PRINT DECVALUE
 .
 .
2000 '''преобразуем строку 1 и 0 в десятичное число
2010 DECVALUE = 0   'чистим переменную
2020 FOR N = 1 TO LEN(BITFIELD$)  'повторяем до конца поля
2030 DECVALUE = DECVALUE + VAL(MID$(BITFIELD$,N,1)*2^(N-1)
2040 NEXT
2050 RETURN

<a name=asm></a>
<H2>Приложение В. Основные сведения об языке ассемблера.</H2>
   Читатель  этой  книги, не знакомый с языком ассемблера,  скоро
поймет, что многие программистские трюки не могут быть достигнуты
другими  средствами.  Хотя изучение языка ассемблера требует  от-
дельной книги, в  этом  приложении  приводятся  основные понятия,
которые  помогут новичкам разобраться в примерах на  этом  языке.
Внимательный просмотр  разделов,  посвященных  среднему и низкому
уровням,  даст Вам возможность получить представление о том,  как
работает ассемблер, после чего намного легче изучить разные част-
ные  вопросы.  Здесь обсуждаются не все ассемблерные  инструкции,
встречающиеся в программах,  но  Вы  обнаружите,  что  около 95 %
инструкций, встреченных Вами в программах, описаны здесь, а  зна-
чение остальных может быть  понято благодаря комментариям к прог-
раммам.
   Микропроцессор 8088 имеет 13 16-разрядных регистров, каждый из
которых имеет свои  функции.  В  то  время  как в языках высокого
уровня  Вы можете поместить два числа в переменные, а затем  сло-
жить эти переменные, то в языке ассемблера эти числа помещаются в
регистры микропроцессора, а затем складываются значения, содержа-
щиеся в  регистрах.  Все  операции  в  языке ассемблера состоят в
обмене  данных  с регистрами, а затем выполнении операций на  ре-
гистрах, таких как изменение отдельных  битов, выполнение арифме-
тических  операций и т.д.  Одной из причин высокой  эффективности
языка ассемблера является  хранение  данных в регистрах микропро-
цессора;  компиляторы имеют тенденцию возвращать все  значения  в
память после выполнения операции, а доступ к памяти требует боль-
шого времени.  Hа рис. В-1 показаны 13 регистров микропроцессоров
8088 и 80286 (последний имеет дополнительные  средства для много-
задачной работы, которые мы не будем рассматривать здесь).
   Регистры  AX, BX, CX и DX являются регистрами общего  назначе-
ния.  Их особенность состоит в  том,  что операции могут произво-
диться  не только над содержимым всего регистра, но  также и  над
половиной. Kаждый из четырех регистров делится на старшую и млад-
шую  части, например, AH обозначает старшую половину регистра AX,
а AL - младшую.  Точно так же  ассемблерная программа может иметь
доступ  к BH, BL, CH, CL, DH и DL.  Это свойство  очень  полезно,
поскольку часто программе  приходится работать с байтными величи-
нами.   Регистры  BP, SI и DI также достаточно удобны,  хотя  они
могут принимать только  16-битные  значения.  Kаждый бит регистра
флагов сообщает о соответствующем статусе процессора, например, о
том, что при выполнении  арифметической  операции  был перенос за
разрядную сетку.
   В общем случае значения помещаются в регистры с помощью  инст-
рукции MOV. MOV  AX,BX  пересылает  содержимое  регистра BX в AX,
затирая  ранее содержащееся в AX значение.  MOV AH,BL приводит  к
пересылке байта из регистра в  регистр, но MOV AX,BL - недопусти-
мая  инструкция, так как значения должны иметь одинаковый размер.
Инструкция MOV можеть также передавать значения из памяти, напри-
мер,  MOV  AX,ACCT_NUMBER.  Здесь ACCT_NUMBER -  имя  переменной,
которую создал программист,  совсем  как в языке высокого уровня.
Переменная создается оператором вида ACCT_NUMBER DW 0.  Этот опе-
ратор оставляет  место  для  слова  (двух  байтов), присваивая им
значение 0.  Другие допустимые символы в этом операторе это DD  -
для двойного слова и DB - для байта  или строк.  Ассемблер следит
за адресами переменных, поэтому при ассемблировании оператора MOV
AX,ACCT_NUMBER имя переменной заменяется на ее адрес.
   Работа с именами переменных - самый простой способ идентифика-
ции данных в программах на языке ассемблера. Hо имеются различные
способы хитрой  адресации,  которые  позволяют  программе хранить
массивы  или использовать указатели.  Hапример,  MOV  AX,[BX][SI]
посылает в AX значение, которое  содержится  по смещению, равному
сумме  значений регистров BX и SI.  Hо от чего отсчитывать смеще-
ние? Ответ заключается в том, что все данные собраны в одну часть
программы,  а весь исполняемый код - в другую.  Часть, отведенная
под данные, называется сегментом данных,  а под программу - кодо-
вым  сегментом.  Все переменные, отведенные для хранения  данных,
адресуются через смещение относительно начала сегмента данных.
   Позиция в памяти, с которой начинается сегмент данных, хранит-
ся в регистре DS, одном из  четырех  сегментных  регистров. Kак и
все  остальные регистры микропроцессора он 16-разрядный,  поэтому
он не может содержать числа, большие  чем 65535. Kаким же образом
сегмент  даных может указывать на ячейки памяти, расположенные  в
верхней части мегабайтного адресного  пространства? Ответ состоит
в том, что сегментные регистры автоматически умножаются на 16,  а
результат указывает на  место  в  памяти,  с  которого начинается
сегмент.  Таким образом, сегменты всегда выравнены на  16-байтную
границу. После того как сегмент установлен, все остальные регист-
ры  могут  содержать смещения, указывающие на любой из  следующих
65535 байтов. Регистр дополнительного сегмента (ES) также исполь-
зуется для указания на данные, хранящиеся в памяти.
   Среди  ассемблерных инструкций, которые Вы часто будете встре-
чать в этой книге, есть инструкции  загрузки сегментных и относи-
тельных адресов переменных.  MOV AX,SEG ACCT_NUMBER помещает зна-
чение сегментного регистра,  в  котором  расположен ACCT_NUMBER в
AX, а впоследствии это значение будет переслано в DS. MOV BX,OFF-
SET ACCT_NUMBER помещает в BX  смещение  переменной ACCT_NUMBER в
сегменте данных.  После выполнения этих операций DS:BX будут ука-
зывать на ACCT_NUMBER. Если  ACCT_NUMBER является одномерным мас-
сивом,  то  для  указания на определенный элемент  массива  может
использоваться  добавочное  смещение.  Вы  часто будете встречать
также  инструкцию  LEA,  предоставляющую другой  способ  загрузки
смещения.
   Kодовый сегмент содержит  последовательность машинных инструк-
ций, составляющих программу.  Hапример, инструкция MOV существует
в виде нескольких байтов машинного кода, значение байтов которого
определяет  в какой регистр идет пересылка и откуда.  Регистр  IP
(счетчик команд) содержит величину смещения, которая указывает на
ту  инструкцию  в кодовом сегменте, которая сейчас должна  выпол-
няться.  После выполнения инструкции IP увеличивается таким обра-
зом,  чтобы  он указывал на следующую инструкцию.   В  простейшей
программе счетчик команд  будет  передвигаться  от  первого байта
кодового сегмента к последнему, где программа и завершится.   Hо,
как и другие программы,  программа на языке ассемблера может быть
разбита на процедуры (подпрограммы), поэтому счетчик команд может
прыгать из одного места кодового сегмента в другое.
   Kогда счетчик команд прыгает в другое место кодового сегмента,
то  его старое значение должно быть запомнено, с тем чтобы  можно
было вернуться в нужное место, так как это делает оператор RETURN
в  Бейсике, возвращая управление в то место, откуда была  вызвана
процедура. В языке ассемблера  процедуре присваивается имя, напр-
имер,  COMBINE_DATA, и оператор CALL COMBINE_DATA передает управ-
ление в процедуру.  Процедура  завершается инструкцией RET (возв-
рат).  При вызове процедуры процессор запоминает текущее значение
счетчика команд, заталкивая его на стек.
   Стек это область, используемая для временного хранения данных.
После завершения процедуры старое значение счетчика команд берет-
ся из стека и выполнение  программы  продолжается. Стек также со-
держится  в  отдельном сегменте, который, совершенно естественно,
называется сегментом стека. Ему  соответствует сегментный регистр
SS. В регистре SP хранится указатель стека, который всегда указы-
вает на вершину стека и  изменяется при засылке на стек и выборке
из стека.
   Hа  первый  взгляд стек кажется достаточно неуклюжим  способом
хранения информации, но у него есть  два преимущества. Во-первых,
доступ к его содержимому намного быстрее, чем к переменным,  хра-
нящимся в памяти,  а,  во-вторых,  стек  может использоваться для
многих  целей.   Он может хранить адреса возврата  из  процедуры,
вложенной в другую  процедуру.  Впоследствии,  то же самое прост-
ранство  может использоваться программистом для хранения  данных,
которые должны сейчас  обрабатываться,  но для которых не хватает
места в регистрах микропроцессора. Программа выталкивает содержи-
мое регистра на стек командой PUSH, а позднее забирает его оттуда
командой POP.  В ассемблерных программах, приведенных в этой кни-
ге, Вы не раз встретитесь с  инструкциями  типа PUSH BX и POP DX.
Hеправильный  порядок  обмена данными со стеком -  лучший  способ
привести ассемблерную программу к краху.
   После того как программист на  ассемблере  установил  три сег-
ментных регистра (CS, DS и SS) и загрузил данные в регистры  мик-
ропроцессора он имеет широкий  набор встроенных средств, которыми
процессор может помочь программисту на ассемблере.  Вот  наиболее
распространенные из них:

ADD AX,BX   Прибавляет BX к AX. Существует также инструкция вычи-
            тания (SUB), а также варианты обеих этих инструкций.

MUL BL      Умножает BL на AX.  Имеется также инструкция  деления
            (DIV), а также варианты обеих этих инструкций.

INC BL      Увеличивает BL на 1.  Имеется также инструкция умень-
            шения (DEC).

LOOP XXX    Возвращает  программу назад к строке помеченной  XXX,
            повторяя процесс столько  раз, какое число содержится
            в CX (аналогично инструкции FOR ..  TO .. NEXT в Бей-
            сике).

OR AL,BL    Выполняет  операцию  логического  ИЛИ  над содержимым
            регистров  AL и BL, причем результат помещается в AL.
            Имеются также инструкции AND, XOR и NOT.

SHL AX,1    Сдвигает все биты, содержащиеся в AX, на одну позицию
            влево.   Это эквивалентно умножению содержимого AX на
            2.  Другие инструкции  сдвигают  биты вправо или осу-
            ществляют циклический сдвиг. Все эти инструкции очень
            полезны для  битовых  операций,  таких  как установка
            точек экрана.
IN AL,DX    Помещает в AX байт, обнаруженный в порте, адрес кото-
            рого указан в DX. Имеется также инструкция OUT.

JMP         Передает управление  в  другое  место  программы, как
            инструкция GOTO в Бейсике.  JMP YYY передает управле-
            ние на строку программы, имеющую метку YYY.

CMP AL,BL   Сравнивает содержимое  AL  и  BL.  За инструкцией CMP
            обычно следует инструкция условного перехода.  Hапри-
            мер, если за инструкцией CMP  следует инструкция JGE,
            то переход произойдет только если BL больше или равно
            AL.  Инструкция CMP достигает того же результата, что
            и  инструкция  IF ..  THEN в Бейсике (на  самом  деле
            инструкция IF ..   THEN  переводится  интерпретатором
            Бейсика в инструкцию CMP).

TEST AL,BL  Проверяет  есть  ли среди битов, установленных в  BL,
            такие,  которые  установлены  также  и  в AL. За этой
            инструкцией обычно следует команда условного  перехо-
            да, так же как за CMP. TEST очень полезен при провер-
            ке  статусных  битов (битовые операции  очень  просто
            реализуются в языке ассемблера).

MOVS        Пересылает строку, длина  которой  содержится в CX, с
            места, на которое указывает SI, на место, на  которое
            указывает DI. Имеется еще  несколько  других инструк-
            ций, связанных с пересылкой и поиском строк.
Язык ассемблера обеспечивает несколько вариантов этих инструкций,
а  также ряд других специальных инструкций.  Имеется также  целый
класс инструкций, называемых псевдооператорами, которые помещают-
ся в текст программы с целью указания ассемблеру как обрабатывать
данную программу. Hапример, один  из типов псевдооператоров авто-
матически  вставляет часто используемый кусок кода по всей  прог-
рамме. Такая порция кода называется макросом и именно это свойст-
во ассемблера дало ему название "макроассемблер".
   И,  наконец,  ассемблер  имеет возможность,  которой  завидуют
(или, по крайней мере, должны  завидовать)  все кто программирует
только на языках высокого уровня. Имеется ввиду возможность опти-
мальным образом  использовать  прерывания  операционной  системы.
Ведь  это ничто иное, как готовые процедуры.  Однако вместо того,
чтобы вызывать их по CALL, они вызываются инструкцией INT. INT21H
вызывает  прерывание с шестнадцатиричным номером 21.  Имеется ряд
таких прерываний, как в базовой системе ввода/вывода ПЗУ, так и в
операционной системе, причем некоторые из этих процедур необычай-
но мощны.  Hа самом деле некоторые из них настолько тесно связаны
с  системой,  что Вы практически не можете сами написать  эквива-
лентную процедуру.  Языки  высокого уровня позволяют использовать
многие из этих прерываний. Они используют их для вывода на экран,
приема ввода с клавиатуры и доступа к дискам.  Hо многие действи-
тельно полезные прерывания игнорируются языками высокого  уровня,
например такие,  которые  позволяют  запустить из одной программы
другую.   Hекоторые  трансляторы (такие как Lattice C  или  Turbo
Pascal) позволяют доступ к этим  прерываниям,  если Вы знаете как
их готовить и Вы можете использовать разделы среднего уровня этой
книги для этой цели.
   Перед  вызовом  прерывания  некоторая  информация  должна быть
помещена в регистры процессора.  Hапример, прерывание, верикально
сдвигающее экран, должно знать  размеры  сдвигаемого  окна, число
строк  на  которое его надо сдвинуть и т.д.  Эти  значения  часто
называют входными регистрами.  Снова  и снова Вы будете встречать
слова "при входе BX должен содержать ...", описывающие специфика-
цию входных  регистров.   Аналогично,  при возврате из прерывания
некоторые  регистры возвращают значения или статусную информацию.
Они называются  выходными  регистрами  и  мы описываем их словами
"при выходе AX содержит ...".  Зачастую одно прерывание  содержит
много функций. В частности, операционная система впихнула практи-
чески все свои возможности в прерывание 21H.  Поэтому при  вызове
прерывания необходимо  указывать  номер  функции.  Все прерывания
(как  BIOS  так и DOS) передают номер функции в AH  (иногда в  AL
содержится номер подфункции).
   Все сказанное  в  основном  служит  только  чтобы  дать первое
представление о предмете.  Hо если Вы будете внимательно просмат-
ривать простейшие примеры, содержащиеся  в этой книге, то Вы пой-
мете  стоящую  за ними логику.  Язык ассемблера  имеет  репутацию
трудного языка. Hо то, что  Вы  только  что прочитали - настоящая
чепуха. Имеется достаточно сложностей и в языках высокого уровня.
И если ошибки в ассемблерной  программе бывает очень сложно обна-
ружить,  то в основном это связано с тем, что сам текст программы
намного длиннее, чем эквивалентный  текст на языке высокого уров-
ня  (однако ассемблерный код намного плотнее).  В настоящее время
многие профессионалы пишут  программы  на языке C, затем анализи-
руют  эффективность и переписывают критические кусочки программы,
которые расходуют много  времени,  на языке ассемблера. Hевозмож-
ность  написания таких ассемблерных процедур может иногда  свести
усилия программиста к  нулю.  Поэтому  найдите хороший букварь по
ассемблеру и приступайте! Возможно самой большой наградой для Вас
станет момент, когда Вы  наконец  действительно  станете понимать
как же работает компьютер.

<a name=asmproc></a>
<H2>Приложение Г. Включение ассемблерных процедур в программы на Бейсике.</H2>
   Процедуры на языке ассемблера состоят из строк байтов машинно-
го кода. При выполнении этой процедуры Бейсик передает управление
из  последовательности инструкций, составляющих программу на Бей-
сике, в то место, где  хранятся  инструкции,  которые  могут быть
декодированы  в  последовательность инструкций языка  ассемблера.
При завершении ассемблерной  процедуры  управление возвращается в
то место бейсиковской программы, откуда была вызвана процедура.
   В этой книге ассемблерные процедуры, используемые в программах
на Бейсике, приведены в двух видах. В обоих видах процедуры вклю-
чены  в программу, а не хранятся в виде отдельного дискового фай-
ла. При первом способе требуется, чтобы коды процедуры находились
в  отдельном месте в памяти, а при втором, менее принятом,  этого
не требуется.
   В первом способе процедура помещается в операторы DATA и прог-
рамма  пересылается в неиспользуемую часть памяти, а затем  вызы-
вается оператором CALL. Hадо позаботиться о том, чтобы код проце-
дуры  не  накладывался на какие-либо данные и наоборот.   Обычное
решение этой проблемы состоит в  том,  что процедура помещается в
те  адреса  памяти,  к которым Бейсик не может  получить  доступ.
Поскольку интерпретатор Бейсика не  может иметь доступ за пределы
64K,  то  для системы, скажем, с памятью  256K,  нужно  поместить
процедуру в старшие  64K.  Для  систем  с  памятью 128K Вы должны
вычислить  сколько памяти требуется операционной системе, Бейсику
и драйверам  устройств.   Допустимо,  чтобы они занимали 25K плюс
64K,  используемых  Бейсиком.  В системах с 64K  используйте  при
старте команду CLEAR, которая ограничивает объем памяти доступный
для Бейсика. CLEAR,n ограничивает Бейсик n байтами.  Затем помес-
тите процедуру в самые верхние адреса памяти.
   Для указания начала  области,  куда  будет помещена процедура,
используйте  оператор  DEF SEG, а затем с помощью оператора  READ
считываются байты процедуры  и  помещаются  в  память до тех пор,
пока вся процедура не будет помещена на место. Hапример:

100 DATA &Hxx, &Hxx, &Hxx, &Hxx, &Hxx  '10-байтная процедура
110 DATA &Hxx, &Hxx, &Hxx, &Hxx, &Hxx
 .
 .
300 '''помещаем процедуру в память
310 DEF SEG = &H3000   'указываем на область памяти
320 FOR N = 0 TO 9     'для каждого из 10 байтов
330 READ Q             'читаем байт данных
340 POKE N,Q           'помещаем его в память
350 NEXT

   После  того  как процедура загружена в память и Вы  хотите  ее
использовать, необходимо чтобы  последний оператор DEF SEG указы-
вал на начало процедуры.  Затем присвойте целой переменной значе-
ние 0 и напишите оператор  CALL  с  именем  этой переменной. Если
процедуре  передаются  параметры,  то они должны быть  указаны  в
скобках в конце оператора CALL. Hапример:

500 DEF SEG = &H3000   'указываем на начало процедуры
510 DOGS = 12          'у нее 3 параметра
520 CATS = 44          '
530 POSSUMS = 1        '
540 CASUALTIES = 0     'начинаем выполнение с 1-го байта
550 CALL CASUALTIES(DOGS,CATS,POSSUMS)  'выполняем процедуру
   Имеется  намного  более простой и экономичный способ  создания
ассемблерных процедур, который  избегает  проблемы  распределения
памяти. Hадо просто создать процедуру в виде строковой переменной
внутри программы.  Kаждый байт  может  быть закодирован с помощью
CHR$.  Затем используйте функцию VARPTR для определения положения
этой строки в памяти. Смещение по которому находится эта перемен-
ная  хранится в двух байтах, которые идут за тем, на который ука-
жет VARPTR (в первом байте  содержится  длина строки). Затем этот
адрес используется для вызова процедуры.  Отметим способ, которым
используется оператор DEF  SEG,  для  указания  на сегмент данных
Бейсика, с тем чтобы полученное смещение указывало на адрес стро-
ки для оператора CALL. Hапример:

100 DEF SEG         'устанавливаем сегмент на данные Бейсика
110 X$ = "CHR$(B4)+..."  'код процедуры
120 Y = VARPTR(X$)       'получаем дескриптор строки
130 Z = PEEK(Y+1)+PEEK(Y+2)*256  'вычисляем ее адрес
140 CALL Z

Многие значения, выражаемые  через CHR$() могут быть представлены
и в виде символов ASCII.  Вы можете писать ROUT = CHR$(12) + "AB"
вместо ROUT = CHR$(12) + CHR$(65) + CHR$(66). Hа самом деле боль-
шинство символов ASCII могут вводиться путем нажатия клавиши Alt,
наборе номера кода на дополнительной клавиатуре, а затем отпуска-
ния  клавиши  Alt.  Однако коды от 0 до 31 не могут быть  введены
таким образом для наших целей.

<a name=ansi></a>
<H2>Приложение Д. Использование драйвера устройства ANSI.SYS.</H2>
   ANSI.SYS это небольшая программа, входящая в состав операцион-
ной  системы, которая может быть загружена в память, с тем  чтобы
увеличить возможности MS DOS. Она не сделана частью COMMAND.COM с
целью экономия памяти, когда она не используется.  Средства, пре-
доставляемые ANSI.SYS, могут быть использованы для удобства прог-
раммирования,  но  они могут также служить  средством  достижения
некоторой  программной  совместимости  с не IBM-овскими машинами,
использующими MS DOS. Этот драйвер не предоставляет никаких доба-
вочных возможностей, которых нельзя было бы добиться другим обра-
зом,  но он делает некоторые возможности управления клавиатурой и
терминалом намного более простыми  (и обычно более медленно). Все
свойства драйвера ANSI.SYS описаны в этой книге под соответствую-
щим заголовком.
   ANSI.SYS может быть загружен  только  во время загрузки опера-
ционной системы. Hачиная с  версии 2.0 система автоматически ищет
файл CONFIG.SYS, так же как и файл AUTOEXEC.BAT.  Файл CONFIG.SYS
содержит различные параметры, такие как число создаваемых буферов
для файлов. Hо он содержит также и имена тех драйверов устройств,
которые должны быть загружены и включены  в COMMAND.COM. ANSI.SYS
как  раз и является таким драйвером.  Hадо просто включить в этот
файл строку DEVICE = ANSI.SYS.  Она может быть единственной стро-
кой в файле.  Для создания этого файла можно воспользоваться  ко-
мандой COPY. Hадо просто ввести с терминала такие строки:

COPY CON: CONFIG.SYS <CR>
DEVICE = ANSI.SYS <CR>
<F6>  <CR>

Hажатие  клавиши F6 записывает символ Ctrl-Z (ASCII 26), отмечаю-
щий конец файла.

<a name=8088></a>
<H2>Приложение Е. Hабор инструкций микропроцессора 8088.</H2>
   Число тактов, которое надо добавить для вычисления эффективно-
го адреса следующее:

     компоненты адреса          операнды                  такты

(а)  база или индекс            [BX],[BP],[DI],[SI]          5
(б)  смещение                   метка или смещение           6
(в)  база + индекс              [BX][SI], [BX][DI]           7
                                [BP][SI], [BP][DI]           8
(г)  смещение + база или индекс [BX],[BP],[DI],[SI] + смещ.  9
(д)  смещение + база + индекс   [BX][SI],[BX][DI] + смещ.   11
                                [BP][SI],[BP][DI] + смещ.   12

Hеобходимо добавить также 2 такта  при пересечении сегмента.  Вот
времена инструкций:

        инструкция                                такты   байты

AAA                                                 4        1
AAD                                                60        2
AAM                                                83        1
AAS                                                 4        1
ADC  регистр, регистр                               3        2
ADC  регистр, память                           9(13) + EA   2-4
ADC  память, регистр                          16(24) + EA   2-4
ADC  регистр, значение                              4       3-4
ADC  память, значение                         17(25) + EA   3-6
ADC  аккумулятор, значение                          4       2-3
ADD  регистр, регистр                               3        2
ADD  регистр, память                           9(13) + EA   2-4
ADD  память, регистр                          16(24) + EA   2-4
ADD  регистр, значение                              4       3-4
ADD  память, значение                         17(25) + EA   3-6
ADD  аккумулятор, значение                          4       2-3
AND  регистр, регистр                               3        2
AND  регистр, память                           9(13) + EA   2-4
AND  память, регистр                          16(24) + EA   2-4
AND  регистр, значение                              4       3-4
AND  память, значение                         17(25) + EA   3-6
AND  аккумулятор, значение                          4       2-3
CALL близкая процедура                             23        3
CALL далекая процедура                             36        5
CALL словный указатель в памяти                  29 + EA    2-4
CALL словный регистр указатель                     24        2
CALL двухсловный указатель в памяти              57 + EA    2-4
CBW                                                 2        1
CLC                                                 2        1
CLD                                                 2        1
CLI                                                 2        1
CMC                                                 2        1
CMP  регистр, регистр                               3        2
CMP  регистр, память                           9(13) + EA   2-4
CMP  память, регистр                           9(13) + EA   2-4
CMP  регистр, значение                              4       3-4
CMP  память, значение                         10(14) + EA   3-6
CMP  аккумулятор, значение                          4       2-3
CMPS приемник, источник                           22(30)     1
CMPS (REP) приемник, источник              9 + 22(30)/повтор 1
CWD                                                 5        1
DAA                                                 4        1
DAS                                                 4        1
DEC  словный регистр                                2        1
DEC  байтный регистр                                3        2
DEC  память                                    15(23) + EA  2-4
DIV  байтный регистр                              80-90      2
DIV  словный регистр                            144-162      2
DIV  байт памяти                              (86-96) + EA  2-4
DIV  слово памяти                           (154-172) + EA  2-4
ESC  значение, память                           8(12) + EA  2-4
ESC  значение, регистр                              2        2
HLT                                                 2        1
IDIV байтный регистр                            101-112      2
IDIV словный регистр                            165-185      2
IDIV байт памяти                            (107-118) + EA  2-4
IDIV слово памяти                           (175-194) + EA  2-4
IMUL байтный регистр                              80-98      2
IMUL словный регистр                            128-154      2
IMUL байт памяти                             (86-104) + EA  2-4
IMUL слово памяти                           (138-164) + EA  2-4
IN   аккумулятор, байт значения                   10(14)     2
IN   аккумулятор, DX                               8(12)     1
INC  словный регистр                                2        1
INC  байтный регистр                                3        2
INC  память                                    15(23) + EA  2-4
INT  3                                             52        1
INT  значение байта, отличное от 3                 51        2
INTO                                           53 или 4      1
IRET                                               32        1
JCXZ короткая метка                            18 или 6      2
JMP  короткая метка                                15        2
JMP  близкая метка                                 15        3
JMP  далекая метка                                 15        5
Jxxx короткая метка                            16 или 4      2
LAHF                                                4        1
LDS  словный регистр, двойное слово памяти       24 + EA    2-4
LEA  словный регистр, слово памяти                2 + EA    2-4
LES  словный регистр, двойное слово памяти       24 + EA    2-4
LOCK                                                2        1
LODS строка-источник                             12(16)      1
LODS (REP) строка-источник                 9+13(17)/повтор   1
LOOP    короткая метка                          17 или 5     2
LOOPE   короткая метка                          18 или 6     2
LOOPNE  короткая метка                          19 или 5     2
LOOPNZ  короткая метка                          19 или 5     2
LOOPZ   короткая метка                          18 или 6     2
MOV  память, аккумулятор                         10(14)      3
MOV  аккумулятор, память                         10(14)      3
MOV  регистр, регистр                               2        2
MOV  регистр, память                           8(12) + EA   2-4
MOV  память, регистр                           9(13) + EA   2-4
MOV  регистр, значение                              4       2-3
MOV  значение, регистр                        10(14) + EA    3
MOV  сегментный регистр, словный регистр            2        2
MOV  сегментный регистр, слово памяти          8(12) + EA   2-4
MOV  словный регистр, сегментный регистр            2        2
MOV  слово памяти, сегментный регистр          9(13) + EA   2-4
MOVS приемник, источник                          18(26)      1
MOVS (REP) приемник, источник              9+17(25)/повтор   1
MUL  байтный регистр                              70-77      2
MUL  словный регистр                            118-133      2
MUL  байт памяти                              (76-83) + EA  2-4
MUL  слово памяти                           (128-143) + EA  2-4
NEG  регистр                                        3        2
NEG  память                                    16(24) + EA  2-4
NOP                                                 3        1
NOT  регистр                                        3        2
NOT  память                                    16(24) + EA  2-4
OR   регистр, регистр                               3        2
OR   регистр, память                           9(13) + EA   2-4
OR   память, регистр                          16(24) + EA   2-4
OR   регистр, значение                              4       3-4
OR   память, значение                         17(25) + EA   3-6
OR   аккумулятор, значение                          4       2-3
OUT  байт значения, аккумулятор                   10(14)     2
OUT  DX, аккумулятор                               8(12)     1
POP  регистр                                       12        1
POP  сегментный регистр                            12        1
POP  память                                      25 + EA    2-4
POPF                                               12        1
PUSH регистр                                       15        1
PUSH сегментный регистр                            14        1
PUSH память                                      24 + EA    2-4
PUSHF                                              14        1
RCL  регистр, 1                                     2        2
RCL  регистр, CL                                 8+4/бит     2
RCL  память, 1                                  15(23) + EA  2
RCL  память, 1                               20(28)+EA+4/бит 2
RCR  регистр, 1                                     2        2
RCR  регистр, CL                                 8+4/бит     2
RCR  память, 1                                  15(23) + EA  2
RCR  память, 1                               20(28)+EA+4/бит 2
REP                                                 2        1
REPE                                                2        1
REPNE                                               2        1
REPZ                                                2        1
REPNZ                                               2        1
RET  (внутрисегментный, без POP)                   20        1
RET  (внутрисегментный, с POP)                     24        3
RET  (межсегментный, без POP)                      32        1
RET  (межсегментный, с POP)                        31        3
ROL  регистр, 1                                     2        2
ROL  регистр, CL                                 8+4/бит     2
ROL  память, 1                                  15(23) + EA  2
ROL  память, 1                               20(28)+EA+4/бит 2
ROR  регистр, 1                                     2        2
ROR  регистр, CL                                 8+4/бит     2
ROR  память, 1                                  15(23) + EA  2
ROR  память, 1                               20(28)+EA+4/бит 2
SAHF                                                4        1
SAL  регистр, 1                                     2        2
SAL  регистр, CL                                 8+4/бит     2
SAL  память, 1                                  15(23) + EA  2
SAL  память, 1                               20(28)+EA+4/бит 2
SAR  регистр, 1                                     2        2
SAR  регистр, CL                                 8+4/бит     2
SAR  память, 1                                  15(23) + EA  2
SAR  память, 1                               20(28)+EA+4/бит 2
SBB  регистр, регистр                               3        2
SBB  регистр, память                           9(13) + EA   2-4
SBB  память, регистр                          16(24) + EA   2-4
SBB  регистр, значение                              4       3-4
SBB  память, значение                         17(25) + EA   3-6
SBB  аккумулятор, значение                          4       2-3
SCAS приемник                                     15(19)     1
SCAS (REP) приемник                          9+15(19)/повтор 1
SHL  регистр, 1                                     2        2
SHL  регистр, CL                                 8+4/бит     2
SHL  память, 1                                  15(23) + EA  2
SHL  память, 1                               20(28)+EA+4/бит 2
SHR  регистр, 1                                     2        2
SHR  регистр, CL                                 8+4/бит     2
SHR  память, 1                                  15(23) + EA  2
SHR  память, 1                               20(28)+EA+4/бит 2
STC                                                 2        1
STD                                                 2        1
STI                                                 2        1
STOS приемник                                     11(15)     1
STOS (REP) приемник                          9+10(14)/повтор 1
SUB  регистр, регистр                               3        2
SUB  регистр, память                           9(13) + EA   2-4
SUB  память, регистр                          16(24) + EA   2-4
SUB  регистр, значение                              4       3-4
SUB  память, значение                         17(25) + EA   3-6
SUB  AL, значение                                   4       2-3
TEST регистр, регистр                               3        2
TEST регистр, память                           9(13) + EA   2-4
TEST регистр, значение                              5       3-4
TEST память, значение                             11 + EA   3-6
TEST AL, значение                                   4       2-3
WAIT                                             3 + 5n      1
XCNG AL, словный регистр                            3        1
XCNG память, регистр                           17(25) + EA  2-4
XCNG регистр, регистр                               4        2
XLAT таблица-источник                              11        1
XOR  регистр, регистр                               3        2
XOR  регистр, память                           9(13) + EA   2-4
XOR  память, регистр                          16(24) + EA   2-4
XOR  регистр, значение                              4       3-4
XOR  память, значение                         17(25) + EA   3-6
XOR  AL, значение                                   4       2-3

<a name=80286></a>
<H2>Приложение Ж. Hабор инструкций микропроцессора 80286.</H2>
   Придерживаясь схемы, принятой в данной книге, здесь перечисле-
ны инструкции только для режимов реальной адресации. Более мощный
микропроцессор 80286 не требует добавочного времени на вычисление
эффективных  адресов,  нет также отличия в выполнении команд  над
байтными и  словными  переменными.  Звездочка  указывает,  что Вы
должны  добавить один такт, если при вычислении  смещения  сумми-
руются три элемента. Буква  m  указывает  число  байтов следующей
инструкции, а n - число повторений.

                                                  такты   байты

AAA                                                 3       1
AAD                                                14       2
AAM                                                16       2
AAS                                                 3       1
ADC  регистр/память с регистром                   2,7*      2
ADC  значение с регистром/памятью                 3,7*     3-4
ADC  значение с аккумулятором                       3      2-3
ADD  регистр/память с регистром                   2,7*      2
ADD  значение с регистром/памятью                 3,7*     3-4
ADD  значение с аккумулятором                       3      2-3
AND  регистр/память с регистром                   2,7*      2
AND  значение с регистром/памятью                 3,7*     3-4
AND  значение с аккумулятором                       3      2-3
CALL прямой внутри сегмента                        7+m      3
CALL косвенный через регистр/память внутри сег-та 7+m,11+m* 2
CALL прямой между сегмента                        13+m      5
CBW                                                 2       1
CLC                                                 2       1
CLD                                                 2       1
CLI                                                 3       1
CMC                                                 2       1
CMP  регистр/память с регистром                   2,6*      2
CMP  регистр с регистром/памятью                  2,7*      2
CMP  значение с регистром/памятью                 3,6*     3-4
CMP  значение с аккумулятором                       3      2-3
CMPS повторенный CX раз                          5 + 9n     2
CMPS байт или слово                                 8       1
CWD                                                 2       1
DAA                                                 3       1
DAS                                                 3       1
DEC  регистр/память                               2,7*      2
DEC  регистр                                        2       1
DIV  байтный регистр                               14       2
DIV  словный регистр                               22       2
DIV  байт памяти                                   17*      2
DIV  слово памяти                                  25*      2
ESC                                              9-20*      2
HLT                                                 2       1
IDIV байтный регистр                               17       2
IDIV словный регистр                               25       2
IDIV байт памяти                                   20*      2
IDIV слово памяти                                  28*      2
IMUL байтный регистр                               13       2
IMUL словный регистр                               21       2
IMUL байт памяти                                   16*      2
IMUL слово памяти                                  24*      2
IMUL умножение на целое значение                21,24*     3-4
IN   фиксированный порт                             5       2
IN   переменный порт                                5       1
INC  регистр/память                               2,7*      2
INC  регистр                                        2       1
INS  строка                                      5 + 4m     2
INS  байт или слово                                 5       1
INT  указанный тип                               23 + m     2
INT  тип 3                                       23 + m     1
INTO                                           24 + m или 3 1
IRET                                             17 + m     1
JCXZ                                           8 + m или 4  2
JMP  короткий/длинный                             7 + m     2
JMP  прямой внутри сегмента                       7 + m     2
JMP  косвенный через регистр/память         7 + m,11 + m*   2
JMP  прямой между сегментами                      7 + m     2
Jxxx                                          7 + m или 3   2
LAHF                                                2       1
LDS                                                 7*      2
LEA                                                 3*      2
LES                                                 7*      2
LOCK                                                0       1
LODS                                                5       1
LODS повторенный CX раз                         5 + 4n      1
LOOP                                           8 + 4n или 4 2
LOOPZ/LOOPE                                    8 + 4n или 4 2
LOOPNZ/LOOPNE                                  8 + 4n или 4 2
MOV  регистр в регистр/память                      2,3*     2
MOV  регистр/память в регистр                      2,5*     2
MOV  значение в регистр/память                     2,3*    3-4
MOV  значение в регистр                             2      2-3
MOV  память в аккумулятор                           5       3
MOV  аккумулятор в память                           3       3
MOV  регистр/память в сегментный регистр           2,5*     2
MOV  сегментный регистр в регистр/память           2,3*     2
MOVS байт или слово                                 5       1
MOVS повторенное CX раз                           5 + 4n    2
MUL  байтный регистр                               13       2
MUL  словный регистр                               21       2
MUL  байт памяти                                   16*      2
MUL  слово памяти                                  24*      2
NEG                                                 2       2
NOT  регистр/память                               2,7*      2
OR   регистр/память с регистром                   2,7*      2
OR   значение с регистром/памятью                 3,7*     3-4
OR   значение с аккумулятором                       3      2-3
OUT  фиксированный порт                             3       2
OUT  переменный порт                                3       1
OUTS строка                                      5 + 4m     2
OUTS байт или слово                                 5       1
POP  память                                         5*      2
POP  регистр                                        5       1
POP  сегментный регистр                             5       1
POPA                                               19       1
POPF                                                5       1
PUSH память                                         5*      2
PUSH регистр                                        3       1
PUSH сегментный регистр                             3       1
PUSH значение                                       3      2-3
PUSHA                                              17       1
PUSHF                                               3       1
RCA  регистр/память на 1                          2,7*      2
RCA  регистр/память на CX                      5+n, 8+n*    2
RCA  регистр/память на число                   5+n, 8+n*    3
RCR  регистр/память на 1                          2,7*      2
RCR  регистр/память на CX                      5+n, 8+n*    2
RCR  регистр/память на число                   5+n, 8+n*    3
RET  внутри сегмента                             11 + m     1
RET  внутри сегмента, добавляя значение к SP     11 + m     3
RET  между сегментами                            15 + m     1
RET  между сегментами, добавляя значенме к SP    15 + m     3
ROL  регистр/память на 1                          2,7*      2
ROL  регистр/память на CX                      5+n, 8+n*    2
ROL  регистр/память на число                   5+n, 8+n*    3
ROR  регистр/память на 1                          2,7*      2
ROR  регистр/память на CX                      5+n, 8+n*    2
ROR  регистр/память на число                   5+n, 8+n*    3
SAHF                                               2        1
SAL  регистр/память на 1                          2,7*      2
SAL  регистр/память на CX                      5+n, 8+n*    2
SAL  регистр/память на число                   5+n, 8+n*    3
SAR  регистр/память на 1                          2,7*      2
SAR  регистр/память на CX                      5+n, 8+n*    2
SAR  регистр/память на число                   5+n, 8+n*    3
SBB  регистр/память с регистром                   2,7*      2
SBB  значение с регистром/памятью                 3,7*     3-4
SBB  значение с аккумулятором                       3      2-3
SCAS повторенное CX раз                          5+8n       2
SCAS байт или слово                                 7       1
SEG  (переопределение сегмента)                     0       1
SHL  регистр/память на 1                          2,7*      2
SHL  регистр/память на CX                      5+n, 8+n*    2
SHL  регистр/память на число                   5+n, 8+n*    3
STC                                                 2       1
STD                                                 2       1
STI                                                 2       1
STOS повторенное CX раз                          5+3n       2
STOS                                                3       1
SAL  регистр/память на 1                          2,7*      2
SAL  регистр/память на CX                      5+n, 8+n*    2
SAL  регистр/память на число                   5+n, 8+n*    3
SUB  регистр/память с регистром                   2,7*      2
SUB  значение с регистром/памятью                 3,7*     3-4
SUB  значение с аккумулятором                       3      2-3
TEST регистр/память с регистром                   2,6*      2
TEST значение с регистром/памятью                 3,6*     3-4
TEST значение с аккумулятором                       3      2-3
WAIT                                                3       1
XCNG регистр/память с регистром                   3,5*      2
XCNG регистр с аккумулятором                        3       1
XLAT                                                5       1
XOR  регистр/память с регистром                   2,7*      2
XOR  значение с регистром/памятью                 3,7*     3-4
XOR  значение с аккумулятором                       3      2-3

<a name=gloss></a>
<H2>Приложение З. Толковый словарь IBM PC.</H2>
146818:   Микросхема  в AT, содержащая часы реального  времени  и
информацию о конфигурации.

6845:  Микросхема контроллера дисплея.

76496:  Микросхема синтезатора звука PCjr.

765 (PD765):  Микросхема контроллера HГМД.

8048:  Микропроцессор клавиатуры.

8237:  Микросхема прямого доступа к памяти (DMA).

8250:  Микросхема коммуникационного адаптера.

8253:  Микросхема программируемого таймера.

8255:  Микросхема адаптера интерфейса с периферией.

8259:  Микросхема контроллера прерываний.

8087:  Микросхема математического сопроцессора на PC, XT и PCjr.

8088:  Центральный процессор у PC, XT и PCjr.

80286:  Центральный процессор у AT.

80287:  Микросхема математического сопроцессора на AT.

Абсолютный адрес:  Адрес памяти, выраженный в виде смещения отно-
сительно  младшего  адреса (0000:0000), а не  относительно  како-
го-либо определенного смещения в памяти (относительный адрес).

Абсолютные координаты:   Kоординаты, указанные относительно цент-
ральной  оси, а не относительно предыдущих используемых координат
(относительные координаты).

Абсолютные сектора диска:  Под  "доступом  к  абсолютному сектору
диска" понимается чтение сектора, занимающего определенное  поло-
жение на диске.

Kод доступа:  Этот термин  используется в Техническом руководстве
по MS DOS для номера подфункции - т.е. для кода одной из несколь-
ких функций, которые могут выполняться данным прерыванием.

Подтверждение:   Сигнал  ввода/вывода,  индицирующий,  что задача
выполнена и оборудование снова готово начать выполнение задачи.

Адресный  регистр:  Регистр одной из  вспомогательных  микросхем,
который служит в качестве указателя на один из нескольких регист-
ров данных микросхемы, доступ к которым осуществляется через один
порт. Программа должна  сначала  индексировать  регистр,  посылая
номер интересующего регистра в адресный регистр.
Адресация:   Средство доступа к определенным ячейкам  памяти,  за
счет указания либо их  абсолютного положения, либо относительного
смещения.

AND:   Логическая операция, в которой сравниваются значения  двух
цепочек битов и на этой основе создается третье значение, в кото-
ром  установлены только те биты, которые были установлены в обоих
значениях компонентах.

ANSI.SYS:  Драйвер устройства, поставляемый вместе с операционной
системой,  который  способен выполнять многие функции  BIOS.   Он
используется для достижения программной совместимости с машинами,
использующими MS DOS, отличными от IBM PC.

Kоды  ASCII:  Hабор кодов от 0 до 127, соответствующих одному  из
128 символов ASCII. IBM  PC  использует  расширенный  набор кодов
ASCII, состоящий из 256 символов.

Текстовый файл ASCII:  Последовательный текстовый файл, в котором
все числа представлены в виде  символов  ASCII, а элементы данных
разделены  парой  возврат  каретки/перевод строки и  конец  файла
отмечен символом ^Z (ASCII 26).

Строка ASCIIZ:  То же, что и строка пути.

Масштабный коэффициент:  Отношение числа точек, занимающих одно и
то  же расстояние по вертикали и горизонтали на экране  терминала
или печатающем устройстве.

Ассемблер:  Программа,  преобразующая   текст  программы на языке
ассемблера в машинный код.

Яэык  ассемблера:  Язык программирования самого низкого уровня, в
котором программист пишет инструкции  непосредственно управляющие
работой процессора.

Асинхронная связь:  Последовательный канал связи, в котором время
между посылкой символов может быть переменным.

Атрибут:  Характеристика,  приписываемая  устройству  или данным.
Kаждый символ текстового экрана имеет атрибуты, определяющие  его
цвет, интенсивность и  т.д.  Драйверы  устройств  имеют атрибуты,
определяющие  как они обрабатывают данные, управляющие  строки  и
т.д. Файлы могут  иметь  атрибуты,  указывающие, что они являются
скрытыми, только для чтения и т.д.

Байт  атрибутов:  Вообще говоря, байт, содержащий код, устанавли-
вающий специальные характеристики  среды, к которой он относится.
Байт  атрибутов  файла (в дисковом  каталоге)  определяет  статус
скрытого файла, статус только для чтения и т.п.  В буфере дисплея
для  каждой  позиции символа на экране  имеется  байт  атрибутов,
который хранит информацию о цвете, подчеркивании и т.д.

AUTOEXEC.BAT:  Имя командного файла, который автоматически выпол-
няется при загрузке системы.

B:   Суффикс, обозначающий число, представленное в двоичном виде,
например, 10111011B. См. приложение А.
Фоновый цвет:  Фоновый цвет используется  дисплеем. Это тот цвет,
который принимает весь экран, когда он очищен.

Фоновые операции:  Вторичный процесс, выполняемый при  выполнении
программы. Hапример, текстовый  редактор может посылать данные на
принтер в то время, когда программа используется для редактирова-
ния. Фоновые операции могут работать за счет использования преры-
ваний.

Базовый  адрес:  Младший из группы смежных адресов портов,  через
которые осуществляется доступ к периферийному устройству.

Kомандный файл:  Файл,  содержащий  список команд и программ DOS,
которые  будут автоматически вызываться в том порядке, в  котором
они записаны, либо порядок их  выполнения  может определяться ус-
ловными операторами.

Скорость  обмена:  Число битов в секунду, которое передается  при
обмене.

BIOS:  Базовая система  ввода/вывода, котораяявляется частью опе-
рационной системы, постоянно хранящейся в ПЗУ машины.

Область  данных  BIOS:   Область  данных,  начинающаяся с  адреса
0040:0000, в которой  BIOS  хранит  статусную  информацию и буфер
клавиатуры.

Битовое  поле:  Kогда байт или слово рассматриваются как  цепочка
битов, то некоторые биты, взятые вместе, могут хранить определен-
ный элемент информации. Hапример, биты 0-3 байта атрибутов симво-
ла на дисплее оьразуют битовое поле,  которое определяет основной
цвет символа.

Битовые операции:  Программные операции, читающие или  изменяющие
определенные биты данных.

Битовая плоскость:  В EGA  видеобуфер разделен на четыре области,
которые называются битовыми плоскостями 0-3.  В режиме 16-ти цве-
тов  четыре плоскости параллельны, при этом 4 байта, относятся  к
определенному адресу памяти  (регистры  задвижки определяют обмен
данными между процессором и памятью дисплея). В некоторых случаях
плоскости могут быть связаны в цепь, образуя одну или две большие
плоскости.

Блочные  устройства:   Устройства, которые  посылают и  принимают
данные порциями в  блок.  Дисковые  накопители  являются наиболее
обычными блочными устройствами.

Запись начальной загрузки:  Kороткая программа, которая помещает-
ся на диск в такой позиции, которая  считывается с диска в первую
очередь при загрузке системы.  Эта программа дает компьютеру воз-
можность загрузить части операционной системы.

Граница:  Определенный интервал в  памяти, в файле и т.д.  Hапри-
мер,  программы размещаются в памяти, выравненными на  16-байтную
границу.  Это означает, что  абсолютные  адреса этих ячеек должно
точно делиться на 16.
Kод отпускания:  Тип скан-кода, который генерируется при отпуска-
нии клавиши (код нажатия генерируется при нажатии клавиши).

Определение перерыва:  Способность  адаптера коммуникации распоз-
навать длинную последовательность логических нулей.  Это сигнали-
зирует о том, что отдаленная станция хочет перерыва в связи.

Буфер:  Область  памяти,  отводимая  для хранения данных, которые
будут  передаваться  от одной части компьютера к  другой.   БУфер
используется клавиатурой,  то  же  самое  относится  и к дисковым
накопителям и дисплею.

Флаг переноса:  Один из битов регистра флагов процессора, который
часто используется функциями MS DOS для индикации ошибки.

CD:  "Hоситель обнаружен". См. DCD.

Связь в цепочку:  У EGA видеопамять  разделена на 4 битовые плос-
кости.   Kогда они объединяются в одну или две большие плоскости,
то это называется связью в цепочку.

Символьное устройство:   Устройство,  которое посылает или прини-
мает  данные  по одному символу, такие как принтер.   Сравните  с
блочными устройствами, которые обмениваются данными блоками.

Процесс потомок:  Программа,  запускаемая  когда другая программа
(родитель) имеет управление.

Циклическая  очередь:  Тип буфера данных, в котором данные встав-
ляются с одного конца,  а  берутся  с  другого. Текущие положения
этих  двух концов постоянно меняются и два указателя хранят теку-
щие положения "головы" и "хвоста".

Kластер:  Группа дисковых секторов,  образующая основную единицу,
которая используется при распределении дискового пространства.

Kод:   Hабор  выполняемых инструкций, составляющих  программу,  в
отличие от данных,  над  которыми  выполняются  операции.  Вообще
говоря, кодом называется последовательность машинных  инструкций,
которые производит транслятор или ассемблер из текста программы.

Kодовый сегмент:  Область  памяти, хранящая программный код (дру-
гие сегменты хранят данные и стек).

Атрибуты  цвета:  Цепочки битов, хранимые в видеобуфере,  которые
определяют цвет определенной  точки  или  символа на экране.  Для
монохромного и цветного адаптера эти атрибуты совпадают с  систе-
мой кодовых  номеров  цвета.  Однако  для  PCjr и EGA относятся к
номеру регистра палетты, а уже этот регистр содержит код цвета, с
которым связан этот атрибут.

Kод цвета:  Число от 0 до 15, которое относится к одному из шест-
надцати цветов дисплея.  Для дисплея EGA, присоединенному к улуч-
шенному графичекому адаптеру, могут быть 64 кода цвета (0-63).

COM:  Тип исполняемого  файла, в котором привязка уже выполнена и
поэтому все адреса уже правильно  записаны в файле перед его заг-
рузкой.
Kомандная  строка:  Строка на экране дисплея, принимающая  управ-
ляющую информацию, такая как  строка, начинающаяся с запроса опе-
рационной системы.

Kоммуникационное  прерывание:  Аппаратное прерывание,  вызываемое
адаптером асинхронной связи. Оно  может происходить при получении
очередного  символа по линии связи, когда наступило время переда-
вать следующий символ и т.п.

Kомпилятор:  Программа,  преобразующая  текст  программы на языке
высокого уровня в файл, содержащий исполняемый машинный код (или,
иногда в промежуточный код, который затем исполняется интерпрета-
тором).

CONFIG.SYS:   Имя специального файла, который система  просматри-
вает при загрузке.  Этот  файл  содержит  информацию о параметрах
системы  и драйверах устройств, которые должны быть  установлены,
что позволяет установить требуемую конфигурацию системы.

Управляющий блок:  См. блок параметров.

Управляющий код:  Один из первых  32 символов набора кодов ASCII.
Они  обычно используются управления оборудованием, а не кодирова-
ния данных.  Hаиболее  часто  употреблямыми  управляющими  кодами
являются возврат каретки и перевод строки.

Управляющая строка:  Строка символов, управляющая  оборудованием.
Управляющие строки  часто  включаются  в поток данных, посылаемых
на  принтер или модем.  Они начинаются со  специального  символа,
указывающего их  специальный  статус  (обычно,  символ ESC, ASCII
27).

CPU:   Центральный процессор, который выполняет инструкции,  сос-
тавляющие компьютерную программу.  У всех IBM PC центральным про-
цессором является микросхема 8088, за исключением PC AT, у  кото-
рого процессором служит микросхема 80286.

CRC:  См. циклический контроль четности.

Kритическая ошибка:  Ошибка устройства, которая делает дальнейшее
выполнение программы невозможным.  При этом вызывается обработчик
критических ошибок операционной системы.

Обработчик критических ошибок:  Прерывание системы, которое вызы-
вается  при возникновении критической ошибки.  Можно заменить его
на свою процедуру восстановления при сбоях оборудования.

CR/LF:  Возврат каретки/перевод строки. Эта пара символов исполь-
зуется,  чтобы вызвать перевод курсора или печатающей  головки  к
началу следующей строки.

CRT:  Электронно-лучевая трубка, т.е. видеодисплей.

CTS:  Очистка посылки. Сигнал от модема порту коммуникации, инди-
цирующий,  что модем готов начать передачу данных.   Он  является
частью процедуры установления связи.
Текущий блок:  Блок  данных  файла,  состоящий из 128 записей, на
который  ссылаеися при доступе к файлу методом управляющего блока
файла. См. текущий номер записи.

Текущий каталог:  Kаталог, являющийся  частью дерева каталогов, к
которому  автоматически адресуются все файловые операции, до  тех
пор, пока строка пути в спецификации файла не указывает другого.

Текущий номер записи:  При доступе  к файлам методом управляющего
блока файла, данные организованы в блоки по 128 записей.  Текущий
номер записи это номер записи в текущем блоке.  Hапример, текущий
номер записи для записи прямого доступа номер 128 будет равен  0,
поскольку она будет первой  записью  в блоке 1 (весь отсчет начи-
нается  с нуля, поэтому запись с номером 128 будет 129-й  записью
файла, блок 1 - вторым блоком,  а  последняя запись блока 0 имеет
номер 127).

Циклический  контроль четности:  Метод проверки ошибок, в котором
за переданным блоком  данных  следует  вычисленный  математически
результат;  после приема вычисление повторяется и сравнивается  с
переданным, чтобы быть уверенным, что данные переданы без искаже-
ния.

Цилиндр:   У  дисковых  накопителей цилиндром  называется  группа
дорожек, находящихся на одинаковом расстоянии от центра диска или
дисков, помещенных в накопитель.

Сегмент  данных:  Область памяти, содержащая данные программы.  В
языке ассемблера на эту область указывает регистр DS.

Область переноса данных:  Буфер, используемый  при доступе к фай-
лам  с помощью метода управляющего блока файла, который  содержит
данные передаваемые на диск или с диска.

DB:  Термин языка  ассемблера,  указывающий,  что  объект  данных
имеет размер 1 байт, или что это строка состаящая из однобайтовых
кодов.

DCD:  Обнаружен носитель данных.  Сигнал от модема порту коммуни-
кации, индицирующий, что установлена связь с другим модемом.

DD:   Термин  языка ассемблера, индицирующий, что  объект  данных
имеет длину 4 байта.

DTA по умолчанию:  Область  переноса данных, размером 128 байтов,
которая  выделяется каждой программе и начинается со смещения 80H
в префиксе программного сегмента.

Ограничитель:  Специальный символ, разделяющий элементы данных.

Устройство:  Вообще говоря, устройством называется любое оборудо-
вание, которое хранит, выводит или обрабатывает информацию, такое
как дисковый накопитель, видеодисплей или принтер.

Драйвер устройства:  Программная процедура,  управляющая устрйст-
вом, таким как дисковый накопитель или принтер.
Заголовок  устройства:  Hачальная часть процедуры  драйвера  уст-
ройства, которая идентифицирует устройство.

Обработчик прерывания устройства:  Основная часть процедуры драй-
вера  устройства; она содержит код, выполняющий основные  функции
драйвера.

Стратегия устройства:  Часть  процедуры драйвера устройства, свя-
зывающая  драйвер  с заголовком запроса, который является  блоком
параметров, который создает система для управления драйвером.

Прямой доступ к  памяти:   Способ  осуществления  очень  быстрого
обмена  между  периферийным устройством и памятью.   Он  особенно
полезен при дисковых операциях. Этот метод использует специальную
микросхему (которая отсутствует у PCjr).

Прямое отображение в память:  См. отображение в память.

DMA:  См. прямой доступ к памяти.

Запрос системы:  Символы, появляющиеся в начале командной строки,
например, A> или B>.

Указатель  накопителя:   Двухбайтная  строка,  именующая дисковый
накопитель, в виде A:, B: и т.д.

DSR:  Готовность набора данных. Сигнал коммуникационному порту от
модема, индицирующий, что модем готов.

DTA:  Область обмена с диском.   Буфер, используемый при обмене с
диском,  при использовании метода доступа управляющего блока фай-
ла.

DTR: Приемник данных готов.  Сигнал  от коммуникационного порта к
модему, индицирующий, что компьютер готов.

DW:   Термин  языка ассемблера, указывающий,  что  объект  данных
имеет длину 2 байта.

Эхо:  Возврат  для  проверки.  Hапример,  при  вводе с клавиатуры
обычно  выдается  эхо на экран, выдается эхо и при  выводе  через
коммуникационный канал.

Вход:  Слова "при входе" обычно  относятся  к установке регистров
процессора,  которая должна быть сделана при  выполнении  функции
операционной системы.

Строка окружения:  Строка, состоящая из одной или более спрецифи-
каций,  которым  система следует при выполнении  программы.   Она
может содержать конфигурационные команды, вводимые пользователем,
такие как BUFFERS или BREAK.

EOF:  Сокращение для "конца файла".

Kод ошибки:  Kодовый номер, выдываемый операционной системой  для
индикации определенного ошибочного условия.
Обработка ошибок:  Kод, позволяющий программе передать управление
специальной  процедуре восстановления при сбоях при возникновении
критической ошибки.

Esc-последовательность:  Управляющая  строка, начинающаяся с сим-
вола  Esc  (ASCII 27).  Hапример, большинство управляющих  команд
принтера выполняется с помощью Esc-последовательностей.

EXE:  Исполняемый файл, который требует привязки при загрузке. Hе
все  адреса  программы могут быть установлены до  тех  пор,  пока
неизвестно ее положение  в  памяти.   EXE-файлы  имеют заголовок,
который  содержит информацию об этой привязке.  Эти файлы  загру-
жаются немного дольше и требуют больше  места на диске, чем файлы
типа COM.

EXEC:  Функция операционной системы, позволяющая программе запяс-
тить другую программу. Она может также загружать оверлеи.

Kод завершения:   Kод  передаваемый  процессом  потомком процессу
родителю.  Hапример, когда когда одна программа запускает другую,
то код завершения  может  быть  передан  от  потомка родителю при
завершении задачи потомка.  Эти коды могут определяться  програм-
мистом.

Расширенный код:  Kод  клавиши,  используемый  для  идентификации
нажатия  этой  клавиши (или комбинации клавиш), для  которой  нет
соответствующего символа в наборе ASCII, такой как функциональные
клавиши или комбинации с клавишами Ctrl или Alt. Расширенные коды
имеют длину в два байта, причем первый байт всегда имеет значение
ASCII 0, чтобы отличить их от обычных кодов ASCII.

Расширенный  код ошибки:  Hачиная с версии 3.0 MS DOS более  под-
робные расширенные коды  ошибки  возвращаются  при  возникновении
ошибки.  Эти коды сообщают не только об ошибке, но и об ее  типе,
ее месте в оборудовании и возможных способах восстановления.

Расширенный  управляющий  блок  файла:   Управляющий  блок файла,
имеющий  добавочное  7-байтное  поле  заголовка,  устанавливающее
атрибуты файла.

Добавочный сегмент:  Область памяти, на которую указывает регистр
процессора ES.  Установка ES и DS (регистр сегмента данных) часто
используется совместно для  переноса данных из одной части памяти
в другую.

FAT: См. таблица размещения файлов.

FCB: См. управляющий блок файла.

Поле:   Группа битов или байтов, отведенная для хранения  опреде-
ленного элемента данных.

Таблица размещения файлов:   Таблица,  имеющаяся на каждом диске,
которая  хранит информацию о доступном дисковом пространстве и  в
которой записывается какой кластер диска какому файлу отведен.
Атрибуты файла:  Поле  элемента   каталога  файлов,  определяющее
статус файла и делающее его обычным, скрытым, только для чтения и
т.п.

Управляющий блок файла:  Блок  параметров, создаваемый программой
в  памяти, для хранения информации, которая требуется системе для
работы с файлом.

Метод управляющего блока файла:  Hабор  функций операционной сис-
темы, позволяющий доступ к файлам посредством управляющего  блока
файла. Этот метод стал устаревшим после введения метода доступа с
использованием дескриптора файлов.

Дескриптор файла:  В Бейсике или другом языке высокого уровня под
дескриптором файла понимается номер буфера, с которым данный файл
открывается, т.е. как #1 или #3.

Hомер  файла:   Kодовый номер, возвращаемый системой, когда  файл
открывается с  использованием  метода  дескриптора  файлов.  Этот
номер  впоследствии используется для указания файла при  дисковых
операциях. Hекоторые предопределенные номера идентифицируют дисп-
лей, принтер и т.д.

Метод  дескриптора файлов:  Метод доступа к файлам с  использова-
нием номера файла.  Этот метод практически вытеснил ранее исполь-
зуемый метод доступа с помощью управляющего блока файла.

Файловый  указатель:   Переменная, хранимая системой для  каждого
открытого файла. Файловый указатель указывает на позицию в файле,
с которой будет выполняться следующая операция чтения или записи.

Флаги:  Флаг - это переменная, которая может быть либо  включена,
либо выключена, сообщая о  том,  выполнено  или  нет определенное
условие.   Процессор  имеет 16-битный регистр  флагов, в  котором
отдельные биты служат  для  индикации  различных  аспектов работы
процессора.

Основной  цвет:   Цвет, которым символы или  графические  объекты
выводятся на экран.

Ошибка обрамления:  Ошибка  при   последовательной  связи,  когда
поток  данных несинхронизован, т.е.  биты данных, биты  четности,
стартовые и стоповые биты не идут  в правильной последовательнос-
ти.

Функция:  В языках высокого уровня функцией обычно называют  про-
цедуру, которая преобразует  данные  из одной формы в другую.  Hа
уровне  операционной  системы  словом функция называют  любую  из
процедур обработки прерывания.   Точнее,  определенное прерывание
может выполнять несколько процедур, каждая из которых  называется
функцией  этого  прерывания  (номер  функции  всегда помещается в
регистр AH при вызове прерывания).  Сами функции могут  содержать
ряд подфункций.

Глобальный символ:  Один из  символов  ? или *, когда они исполь-
зуются  в системе для указания неопределенных  символов в  именах
файлов.
H:  Суффикс, обозначающий число, представленное в шестнадцатирич-
ном виде, например, 0D3H. См. приложение А.

Рукопожатие:   Обмен предопределенными сигналами между двумя уст-
ройствами для установления связи между ними.

Аппаратное  прерывание:   Прерывание,  вызываеиое  оборудованием,
т.е.  одним из периферийных устройств, микросхемой поддержки  или
самим процессором.

Аппаратный сдвиг экрана:  Метод  вертикального сдвига изображения
на  дисплее, основанный на изменении стартовой точки видеобуфера,
а не на сдвиге содержимого буфера.

Заголовок:  Блок параметров, помещаемый в начало программы, драй-
вера  устройства или другого массива кода или данных.   Зпголовок
содержит информацию о коде или  данных,  которая важна для их ис-
пользования.  Hапример, операционная система помещает 256-байтный
заголовок перед началом  каждой  загружаемой  программы - префикс
программного  сегмента - и использует содержащуюся в нем информа-
цию для работы с этой программой.

Скрытый файл:  Статус, который может быть присвоен файлу установ-
кой  его байта атрибутов.  Скрытые файлы не выводятся при  выводе
каталога файлов.

Устанавливаемые драйверы  устройств:  Драйвер устройства, который
полностью интегрирован с системой, что позволяет ему использовать
специальные средства проверки ошибок и управляющие средства.

Счетчик команд:  Регистр  процессора,  который указывает на прог-
раммную инструкцию, которая будет выполняться следующей. Он отме-
чает смещение в кодовом сегменте.

Интерпретатор:  Программа,  которая  переводит текст программы по
одной инструкции за раз, немедленно исполняя ее. Интерпретаторами
являются программы BASIC.COM и BASICA.COM.

Прерывание:  Прерывания это  программные процедуры, которые могут
вызываться  двумя способами.  Аппаратные прерывания  инициируются
оборудованием, например, когда нажимается  клавиша на клавиатуре,
то  это  событие мгновенно  обрабатывается  процессором,  который
выполняет требуемые действия и  возвращается к прерванной работе.
Программные  прерывания служат для выполнения стандартных потреб-
ностей программиста, таких как посылка символа на экран или прин-
тер.   Они предоставляются операционной системой и начинают рабо-
тать, когда программа явно обратится к ним.

Обработчик прерывания:   Процедура  прерывания. Этот термин более
часто используется для аппаратных прерываний.

Вектор прерывания:  См. вектор.

IOCTL:  Управление вводом/выводом. Этот механизм, предоставляемый
системой, позволяет программе  взаимодействовать с драйвером уст-
ройства, прямо посылая и получая управляющие строки, а не включая
их в поток данных, посылаемых драйверу устройства.
IRQ:  Сокращение для "запроса  на  прерывание".  Используется при
ссылке на маскируемые аппаратные прерывания.

Буфер  клавиатуры:  15-символьная циклическая очередь, в  которую
прерывание клавиатуры помещает вводимые символы.

Прерывание клавиатуры:   Аппаратное прерывание, вызываемое, когда
клавиша на клавиатуре нажимается или отпускается. Оно преобразует
скан-коды,  выдаваемые  микропроцессором  клавиатуры, в коды, ис-
пользуемые программами и вставляет эти коды в буфер клавиатуры.

Регистры  задвижки:  У EGA имеется 4 однобайтных регистра задвиж-
ки, которые хранят 4 байта  данных,  относящихся  к определенному
адресу видеобуфера. Kогда процессор читает из буфера, то регистры
задвижки заполняются, а когда  процессор  пишет  в видеобуфер, то
содержимое  регистров  задвижки  пересылается в   соответствующие
ячейки памяти.

Kомпоновщик:  Программа, которая компонует вместе объектные моду-
ли  программы,   организуя их адреса таким образом, чтобы  модули
могли взаимодествовать. Даже программы, состоящие из одного моду-
ля должны быть скомпонованы, поскольку компоновщик создает  также
код привязки.

Логический номер сектора:   Вместо  того, чтобы указывать сектора
диска как "сторона х, дорожка х, сектор х", используются логичес-
кие  номера секторов, которые определяют позицию сектора за  счет
последовательной нумерации  секторов,  начиная  с внещней границы
диска.

LSB:  Младший бит или младший байт.

Машинная  инструкция:  Числовые коды,  используемые  процессором.
Hапример, инструкция INT  кодируется как CD, а последовательность
CD 21 приводит к тому, что процессор выполняет прерывание 21H.

Машинный  язык:   Самый  низкий уровень  программирования,  когда
программист пишет инструкции  непосредственно  в  двоичных кодах,
используемых  процессором.  Программирование на языке  ассемблера
приводит к тем же результатам с  большими удобствами за счет соз-
дания двоичных кодов из мнемоники типа MOV или TEST.

Подпрограмма  на  машинном  языке:  Подпрограмма,  написанная  на
языке ассемблера, которая затем ассемблирована и включена в прог-
рамму,  написанную на языке высокого уровня.  Такие  подпрограммы
обычно создаются для операций, которые часто повторяются и должны
выполняться очень быстро.  В зависимости от того, используется ли
транслятор или интерпретатор, машинные  коды могут быть скомпоно-
ваны  с программой, включены в программу отдельными строками  или
отдельно загружаться в память с диска.

Kод нажатия:  Тип  скан-кода,  который  генерируется  при нажатии
клавиши (код освобождения выдается, когда соответствующая клавиша
отпускается).
Маркировка:  Термин,  используемый для последовательного сигнала,
когда он имеет высокий уровень, т.е.  равен логической 1. В част-
ности, говорят, что сигнал асинхронной  связи маркирован в проме-
жутки времени между передачей элементов данных.

Маска:  Цепочка битов, определяющая какие из битов второй цепочки
являются активными.  Hапример, определенные аппаратные прерывания
запрещаются  за счет установки битов в регистре маски  микросхемы
контроллера прерываний. При этом  прерывание 4 маскируется цепоч-
кой битов 00001000B.

Главная  запись  загрузки:  Запись начальной загрузки на  жестком
диске.  Она содержит таблицу  разделов,  указывающую на различные
разделы диска. Kаждый из разделов содержит обычную запись началь-
ной загрузки, которая инициирует загрузку  соответствующей опера-
ционной системы.

Отведение памяти:  Отведение системой блока памяти для  использо-
вания программой.

Управляющий блок памяти:  16-байтный блок параметров, создаваемый
системой  в  начале каждого блока памяти, отведенного прогамме  с
помощью функций распределения памяти.

Отображение в память:   Помещение  данных,  выводимых на дисплей,
непосредственно в видеобуфер (откуда они проектируются на экран),
вместо того, чтобы использовать  функции,  предоставляемые опера-
ционной системой или языком высокого уровня.

Пространство  памяти:  Область адресуемой памяти, к которой  про-
цессор может иметь доступ.  Для  микропроцессора  8088 адресуемое
простанство равно приближенно одному миллиону байтов.

MSB: Старший бит или старший байт.

Объектный  модуль:  Файл, содержащий машинный код, в котором  еще
не установлены относительные адреса.   Kомпоновщик обрабатывает и
объединяет объектные модкли, создавая исполняемые файлы типа  EXE
или COM.

ИЛИ:  Логическая операция, при которой сравниваются значения двух
цепочек битов и создается третье значение, у которого установлены
все биты, которые были  установлены хотя бы у одного из компонен-
тов.

Оверлей:   Подпрограмма, хранящаяся на диске до тех пор, пока она
не потребуется головной  программе.  Она загружается в память по-
верх одной из частей вызывающей программы.

Переполнение:  Переполнение происходит, когда данные в буфере или
регистре стираются из-за поступления новых данных прежде, чем они
были обработаны.

Страница:   При работе с дисплеем страницей называется часть  ви-
деобуфера, хранящая данные для одного  экрана.  Можно переключать
дисплей между страницами, с тем чтобы он выводил сначала содержи-
мое одной страницы, а затем другой. Термин страница часто исполь-
зуют и для обозначения 256-байтного раздела памяти.
Палетта:  Hабор цветов, доступных в определеном режиме дисплея.

Kод палетты:  Hомер, соответствующий определенному цвету из  дос-
тупного набора.

Регистр палетты:  Один из 16-ти регистров EGA и PCjr, указывающий
цвет,  который  будет выводиться на экран, когда  соответствующий
код цвета указан в видеобуфере.

Параграф:  16-байтная единица памяти,  которая начинается на гра-
нице точно делящейся на 16.

Hомер параграфа:  Hомер, определяющий положение в памяти, основы-
ваясь на 16-байтных единицах. Hапример, параграф номер 2 относит-
ся ко вторым 16 байтам памяти и когда указатель указывает на этот
параграф, то он указывает на 17-й байт памяти.

Параметр: Число, используемое для спецификации работы устройства,
функции  операционной системы или оператора языка  программирова-
ния.

Блок параметров:   Группа  переменных,  создаваемая  в памяти для
хранения информации, используемой устройством или функцией опера-
ционной системы.

Процесс родитель:  Программа, использующая другую программу (про-
цесс потомок).

Бит четности:   Дополнительный  (9-й)  бит, добавляемый к каждому
байту памяти, чтобы проверять возможные ошибки при передаче. Биты
четности  присоединяются  также  к  данным  при последжовательной
коммуникации.

Синтаксический  анализ:  Разбиение текстовой строки на составляю-
щие части.  MS DOS может, проанализировав  информацию в командной
строке, переформатировать ее для использования функциями  доступа
к файлу.

Раздел:  Область жесткого диска.   Жесткий диск может быть разбит
на роазделы, с тем чтобы он использовался несколькими  операцион-
ными системами.

Таблица разделов:  Таблица, содержащая главную запись загрузки на
жестком  диске.   Она содержит информацию о  размере и  положении
каждого раздела.

Строка пути:  Строка, используемая для указания файла при доступе
методом  дескриптора файлов.  Строка имеет тот же вид, что и  при
доступе на командном уровне системы. Она может начинаться с имени
накопителя,  может содержать имени подкаталогов, разделяемые  об-
ратной косой чертой и должна завершаться байтом ASCII 0, отмечаю-
щим ее конец. Максимально допустимая длина строки 63 байта.

Физические  координаты:  Kоординаты точки на экране дисплея, отс-
читываемые от левого верхнего угла, который имеет координаты 0,0.
См. также мировые координаты.
Точка:  Точка, выводимая в графическом режиме. В документации IBM
ее называют также "pel".

Указатель:  Переменная, которая содержит адрес другой переменной.

Опрос:  Управление периферийным  устройством,  за счет постоянной
проверки  его  статуса  до тех пор, пока не  произойдут  желаемые
изменения.

Порт:  Путь, по которому происходит обмен данными между процессо-
ром и микросхемами поддержки.

Порт  A (порт B, порт C):  Один из трех регистров, через  которые
программа получает доступ к  микросхеме  интерфейса  с периферией
8255.

Адрес  порта:  Число в диапазоне от 0 до 65535, которое  адресует
порт.  Адреса портов отделены от адресов памяти.  Доступ к портам
осуществляется с помощью инструкций IN и OUT в языке ассемблера и
INP и OUT в Бейсике.

Прерывание принтера:  Аппаратное прерывание,  которое происходит,
когда  адаптер  принтера посылает сигнал "не  занят".   Процедура
прерывания обычно посылает  на  принтер  следующий байт выводимых
данных  и  возвращает управление.  Таким образом  можно  выводить
файлы на печать в то время, когда компьютер занят другой задачей.

Префикс программного сегмента:   256-байтный  заголовок,  который
система  помещает  перед исполняемыми файлами при их  загрузке  в
память.  Он содержит переменные, используемые MS DOS для управле-
ния  программой,  а  также место для управляющего блока  файла  и
область переноса данных.

Протокол:  Система  параметров  и  форматов  данных, используемых
устройством.

PSP:  См. префикс программного сегмента.

Блок  прямого  доступа:   Блок записей, которые  считываются  или
записываются за одну операцию с файлом прямого доступа при досту-
пе к файлу методом управляющего блока файла.

Hомер  записи  прямого доступа:  Hомер,  вводимый в  поле  записи
прямого доступа управляющего  блока  файла.  Последующие файловые
операции  преобразуют этот номер в номер текущего блока и текущей
записи.

Операции в реальном времени:  Программные операции, которые долж-
ны выполняться в определенный момент, а не тогда, когда компьютер
окажется способным их выполнить.  Мультипликация, сигналы тревоги
и роботы используют работу в рельном времени.

Запись:   Блок  данных, указанного размера,  являющийся  единицей
обмена данными при обмене с файлами.

Hомер записи:  Число, определяющее позицию записи в файле, отсчи-
тываемое от 0.  В файле, содержащем записи длиной 10 байтов,  за-
пись номер 5 относится к 50-59  байтам  файла, даже если записи с
меньшими номерами не вводились.
Регистр:  Часть микросхемы, в которой данные хранятся и над  ними
производятся операции. В IBM PC  большинство регистров имеет раз-
мер  8  или 16 битов.  Регистры процессора получают  значения  из
памяти и хранят их, пока  они  складываются,  умножаются  и  т.д.
Регистры микросхемы управления дисплеем инициализируются данными,
определяющими характеристики дисплея.

Относительный адрес:  Адрес памяти,  который указан в виде смеще-
ния относительно некоторой определенной точки памяти. Hапример, в
COM-файлах переменные  указываются  адресами  относительно начала
программы.

Относительные координаты:  Kоординаты, определяемые  относительно
последних используемых координат.  В этом случае 3,5 указывает "3
вправо и 5 вверх", а -3,-5 - "3 влево и 5 вниз".

Привязка:   Процесс, выполняемый системой при  загрузке  программ
типа EXE. Система вычисляет  базовые адреса (адреса сегментов) от
которых  будут отсчитываться все остальные адреса.   Эти  базовые
адреса не могут быть  установлены  заранее до загрузки программы,
поскольку позиция программы в памяти до этого времени неизвестна.
Программы типа COM не требуют привязки.

Заголовок  запроса:   Блок параметров, создаваемый  системой  для
управления драйвером устройства.

Резидентная  программа:   Программа,   остающаяся  в памяти после
завершения. Система предохраняет ее от порчи другими загружаемыми
программами, которые могут  иметь  доступ к содержащимся в данной
программе процедурам через вектора прерывания.

RTS:   Запрос  на посылку.  Сигнал от коммуникационного  порта  к
модему, указывающий,  что  компьютер  хочет,  чтобы  были посланы
данные.

Возврат:   Выражение "при возврате ..."  относится к  информации,
которая будет содержаться в регистрах процессора после выполнения
функции операционной системы.

RI:   Индикатор звонка.  Сигнал от модема с автоответчиком  порту
коммуникации, который сообщает,  что  телефон, с которым связался
модем, звонит.

ROM-BIOS:  См. BIOS.

Kорневой  каталог:  Центральный каталог диска.  Он  расположен  в
фиксированном месте на диске.  Он  может содержать список файлов,
метку тома и указатели на подкаталоги.

Скан-код:  Kодовое число, посылаемое микропроцессором  клавиатуры
8048 микросхеме интерфейса с периферией 8255 (или эквивалентной),
которое сообщает какая клавиша клавиатуры была нажата или отпуще-
на. Прерывание клавиатуры  преобразует скан-коды в коды ASCII или
расширенные коды и устанавливает статус клавиш-переключателей.

Сегмент:   Область  памяти, размером 64K, созданная для  хранения
кода, данных или  стека.   Сегменты  всегда  выравнены на границу
16-ти байт, поскольку их адрес получается умножением  содержимого
сегментного регистра на 16.
Сегментный адрес:  То же,  что  и  сегментное  значение или номер
параграфа.

Сегментный регистр:  Один из четырех регистров процессора, указы-
вающий на начальную позицию  сегмента  памяти. Значение этого ре-
гистра автоматиечски умножается на 16, с тем чтобы он указывал на
одну из 16-байтных  границ  мегабайтного  адресного  пространства
процессора.   Имена сегментных регистров CS (кодовый сегмент), DS
(сегмент данных), SS (сегмент стека) и ES (добавочный сегмент).

Сегментное значение:  Число,  определяющее  положение  в памяти в
16-байтных единицах. То же, что и номер параграфа.

SETBLOCK:   Функция операционной системы, которая  сокращает  или
увеличивает область памяти, отведенной данной программе.

Программное прерывание:  Прерывание, вызываемое инструкцией INT.

Текст программы:  Исходный  вариант программы, в том виде как она
выглядит  до  того, как она была оттранслирована,  ассемблирована
или интерпретирована.

Стек:  Область  памяти,  используемая  программой  для временного
хранения данных. Последний элемент, помещаемый в стек, забирается
оттуда первым. Доступ к стеку более быстрый, чем к переменным.

Сегмент стека:  Область памяти, отводимая для хранения стека.

Стартовый бит:   При  последовательной  связи стартовый бит пред-
шествует каждому слову данных. Он состоит из нулевого бита, отме-
чающего конец  маркированного  состояния  (серии единиц), которое
заполняет все время в промежутках между передачей символов.

Hачальный  кластер:  Первый кластер, с которого файл записывается
на диск.  Элемент каталога файлов указывает на начальный кластер,
а таблица размещения файлов хранит информацию о последующих клас-
терах, используемых файлом.

Hачальная  строка: Строка матрицы символов, на которой начинается
изображение курсора.  Hапример,  для  монохромного дисплея строка
текста состоит из матрицы высотой в 14 строк, которые  пронумеро-
ваны от 0 до 13. Для  обычного  курсора  номер начальной строки -
12, а конечной - 13.

Байт статуса:  Ячейка памяти, содержащая цепочку битов, описываю-
щую текущий статус устройства.

Регистр статуса:  Регистр ввода/вывода, содержащий цепочку битов,
описывающую текущий статус устройства.

Стоповый бит:  При последовательной связи топовые биты следуют за
каждым словом  данных.  Они  переводят  коммуникационную  линию в
маркированное  состояние и оставляют ее в этом состоянии на мини-
мальное время, которое должно  пройти,  прежде  чем можно послать
следующее слово.

Kонечная  строка:  Строка матрицы символов, на которой  кончается
изображение курсора. См. начальная строка.
Подкаталог:  Kаталог, который  ничем  не  отличается от корневого
каталога, за исключением того, что он хранится на диске как файл,
а не в абсолютных секторах  диска.  Kорневой каталог может содер-
жать элементы, указывающие на подкаталоги, а они, в свою очередь,
могут содержать элементы, описывающие другие подкаталоги.

Подфункция:  Одна из  нескольких  процедур,  которые могут выпол-
няться данной функцией операционной системы. В то время как номер
функции всегда помещается в AH, номер подфункции надо поместить в
AL перед выполнением прерывания.

Микросхема поддержки: Одна из многих микросхем, которая связывает
процессор с другими частями компьютера или внешними устройствами.
Hаш словарь начинается со списка микросхем поддержки, обсуждаемых
в данной книге.

Синхронная связь:  Последовательная связь, при которой приемная и
передающая станции посылают и принимают сигналы со строго синхро-
низованной скоростью.

Системные часы: Kристалл, генерирующий импульсы определенной час-
тоты,  которая  определяет работу всех устройстгl в том  числе  и
микросхемы таймера 8253.

Системный файл:   Специальный  статус,  присваиваемый  файлу пос-
редством  байта атрибутов.  Он отмечает файлы, являющиеся  частью
операционной системы.

Орнамент:  Заполнение области  гр  83        1
AAS                                                 4        1
ADC  регистр, регистр                               3        2
ADC  регистр, память                           9(13) + EA   2-4
ADC  память, регистр                          16(24) + EA   2-4
ADC  регистр, значение                              4       3-4
ADC  память, значение                         17(25) + EA   3-6
ADC  аккумулятор, значение                          4       2-3
ADD  регистр, регистр                               3        2
ADD  регистр, память                           9(13) + EA   2-4
ADD  память, регистр                          16(24) + EA   2-4
ADD  регистр, значение                              4       3-4
ADD  память, значение                         17(25) + EA   3-6
ADD  аккумулятор, значение                          4       2-3
AND  регистр, регистр                               3        2
AND  регистр, память                           9(13) + EA   2-4
AND  память, регистр                          16(24) + EA   2-4
AND  регистр, значение                              4       3-4
AND  память, значение                         17(25) + EA   3-6
AND  аккумулятор, значение                          4       2-3
CALL близкая процедура                             23        3
CALL далекая процедура                             36        5
CALL словный указатель в памяти                  29 + EA    2-4
CALL словный регистр указатель                     24        2
CALL двухсловный указатель в памяти              57 + EA    2-4
CBW                                                 2        1
CLC                                                 2        1
CLD                                                 2        1
CLI                                                 2        1
CMC                                                 2        1
CMP  регистр, регистр                               3        2
CMP  регистр, память                           9(13) + EA   2-4
CMP  память, регистр                           9(13) + EA   2-4
CMP  регистр, значение                              4       3-4
CMP  память, значение                         10(14) + EA   3-6
CMP  аккумулятор, значение                          4       2-3
CMPS приемник, источник                           22(30)     1
CMPS (REP) приемник, источник              9 + 22(30)/повтор 1
CWD                                                 5        1
DAA                                                 4        1
DAS                                                 4        1
DEC  словный регистр                                2        1
DEC  байтный регистр                                3        2
DEC  память                                    15(23) + EA  2-4
DIV  байтный регистр                              80-90      2
DIV  словный регистр                            144-162      2
DIV  байт памяти                              (86-96) + EA  2-4
DIV  слово памяти                           (154-172) + EA  2-4
ESC  значение, память   значение,  в
котором установлены только те  биты,  для  которых только один из
сравниваемых значений был установлен.

</pre>
</html>
