<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)menures.html -->
<HTML><HEAD><TITLE>Ресурсы и меню</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3401" name=GENERATOR></HEAD>
<BODY background="../../bgrwhite.gif">
<p><div align="center"><b><font size="+1" face="Arial">Ресурсы и 
меню </font></b></div></p>


<P align=left><FONT>Я думаю не вызывает 
сомнений утверждение, что написание программ для Windows, не содержащих ресурсы 
и меню, связано не только с огромными трудностями, но и с тем, что мы не 
используем одно из основных удобств Windows. </FONT></P>
<P align=left><FONT>Ресурсы, представляют 
собой двоичные данные, хранящиеся внутри EXE или DLL файла программы. Команды 
меню, например, организованы как ресурсы, которые программа загружает во время 
выполнения. Ресурсы экономят время, сокращая объем подготовительных операций, 
выполняемых программой, и экономят память, так как двоичные ресурсы остаются на 
диске до тех пор, пока они не потребуются. </FONT></P>
<P align=left><FONT>С помощью редактора 
ресурсов, такого как Borland Resource Workshop, вы разрабатываете ресурсы вашей 
программы так, как если бы вы рисовали картинку, редактировали текстовый 
документ или чертили диаграмму. Borland Resource Workshop – интерактивный 
редактор ресурсов; то, что вы видите на экране, выглядит точно так же, как 
будут, в конечном счете, выглядеть ресурсы в законченной программе. </FONT></P>
<P align=left><FONT>В этой статье я не буду 
рассматривать процесс работы в Resource Workshop. Мы рассмотрим только некоторые 
моменты, которые нам понадобятся в дальнейшем. В Resource Workshop вы должны 
создать файл сценария ресурсов. Этот файл представляет собой обыкновенный 
текстовый документ, содержащий операторы исходного кода ресурсов приложения. 
Файлы сценария ресурсов имеют расширения .RC. </FONT></P>
<P align=left><FONT>Пример файла сценария 
ресурсов (<A 
href="menures.rc.rar">menures.rc</A>)</FONT></P>
<HR>

<P align=left><FONT color=#ff0033 
face="Times New Roman, Times, serif"><B>#include "menures.rh"<BR><BR>MENU_1 MENU 
<BR>{ <BR>POPUP "&amp;File" <BR>{ <BR>MENUITEM "&amp;First item", CM_FIRSTMENU 
<BR>MENUITEM "&amp;Second item", CM_SECONDMENU <BR>MENUITEM SEPARATOR 
<BR>MENUITEM "&amp;Third Menu", CM_THIRDMENU <BR>} <BR>POPUP "&amp;Exit" <BR>{ 
<BR>MENUITEM "&amp;Exit NOW", CM_EXIT <BR>} <BR>} </B></FONT></P>
<HR>

<P align=left><FONT>После того как ресурсы 
созданы, мы должны связать их с нашим приложением. Для этого Resource Workshop 
создает файлы идентификаторов ресурсов. Эти файлы имеют расширение .RH. 
</FONT></P>
<P align=left><FONT>Пример файлы 
идентификаторов ресурсов <A 
href="menures.rh.rar">(menures.rh</A>)</FONT></P>
<HR>

<P align=left><FONT color=#ff0033 
face="Times New Roman, Times, serif"><B>#define ICON_1 1 <BR>#define MENU_1 1 
<BR>#define CM_EXIT 104 <BR>#define CM_THIRDMENU 103 <BR>#define CM_SECONDMENU 
102 <BR>#define CM_FIRSTMENU 101 </B></FONT></P>
<HR>

<P align=left><FONT>Теперь, когда вы 
понимаете, что создает Resource Workshop, мы приступим к созданию файла 
ресурсов. Файл ресурсов представляет собой бинарный файл и присоединяется к 
нашему приложению в процессе компоновки. Файлы ресурсов имеют расширение .RES. 
<BR></FONT></P>
<P align=left><FONT>Для получения файла 
ресурсов вы можете использовать две программы: </FONT></P></DIV>
<UL>
  <LI>
  <DIV align=left><FONT color=#ff0033 
 >Resource Workshop. <BR>Borland Resource 
  Compiler. </FONT></DIV></LI></UL>
<DIV align=center>
<P align=left><FONT>Для создания файла 
ресурсов в Resource Workshop вы должны выбрать в меню File пункт Save As и 
сохранить ваши ресурсы как .RES файл. </FONT></P>
<P align=left><FONT>Для создания файла 
ресурсов с помощью Borland Resource Compiler вы должны просто запустить 
программу brcc.exe и как параметр передать ей путь и имя файла сценария 
ресурсов. </FONT></P>
<P align=left><FONT>Когда файл ресурсов 
создан, можно перейти к вопросу программирования. Для того, что бы Turbo 
Assembler понял файл идентификаторов ресурсов его надо немного переделать. 
Описания всех идентификаторов начинается с директивы <FONT 
color=#ff0033><B>#define</B></FONT>, так как подобной директивы в Turbo 
Assembler нет, мы должны подправить все объявления идентификаторов на идентичную 
директиве <FONT color=#ff0033><B>#define</B></FONT> директиву <FONT 
color=#ff0033><B>equ</B></FONT>. </FONT></P>
<P align=left><FONT>Например:<B> <FONT 
color=#ff0033>#define CM_EXIT 1</FONT></B> нужно заменить <FONT 
color=#ff0033><B>CM_EXIT equ 1</B></FONT></FONT> </P>
<P align=left><FONT>После того как вы 
преобразовали файл идентификаторов ресурсов, его надо подключить к основной 
программе. Для этого используйте директиву include. </FONT></P>
<P align=left><FONT color=green 
face="Times New Roman, Times, serif"><B>ВНИМАНИЕ</B></FONT><FONT 
face="Times New Roman, Times, serif">: Не все ресурсы могут иметь одинаковые 
идентификаторы. Однако только ресурсы типов <FONT 
color=#ff0033><B>DIALOG</B></FONT> и <FONT color=#ff0033><B>MENU</B></FONT> 
можно проигнорировать, так как их использование не связано с идентификатором, 
ресурсы остальных типов должны иметь уникальные идентификаторы. </FONT></P>
<P align=left><FONT>Пример программы (<A 
href="menures.asm.rar">menures.asm</A>)</FONT></P>
<HR>

<P align=left><FONT><STRONG><FONT 
color=#ff3333>locals</FONT></STRONG><FONT 
color=#ff3333><BR><STRONG>jumps</STRONG><BR><STRONG>.model large, WINDOWS 
PASCAL</STRONG></FONT><STRONG><BR></STRONG><STRONG></STRONG><FONT size=2>; 
Подключаем файл описания констант и структур API<BR></FONT><STRONG><FONT 
color=#ff3333>include windows.inc<BR></FONT></STRONG></FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2>; Подключаем файл описания 
идентификаторов ресурсов</FONT><STRONG></STRONG></FONT> <BR><FONT 
face="Times New Roman, Times, serif"><STRONG><FONT color=#ff3333>include 
windows.ri</FONT></STRONG></FONT><BR><FONT 
size=2>; Описываем используемые функции</FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2><BR></FONT><STRONG><FONT 
color=#ff3333>extrn BEGINPAINT:PROC<BR>extrn CREATEWINDOW:PROC<BR>extrn 
DEFWINDOWPROC:PROC<BR>extrn DISPATCHMESSAGE:PROC<BR>extrn ENDPAINT:PROC<BR>extrn 
GETMESSAGE:PROC<BR>extrn GETSTOCKOBJECT:PROC<BR>extrn INITAPP:PROC<BR>extrn 
INITTASK:PROC<BR>extrn LOADCURSOR:PROC<BR>extrn MESSAGEBOX:PROC<BR>extrn 
POSTQUITMESSAGE:PROC<BR>extrn REGISTERCLASS:PROC<BR>extrn 
SHOWWINDOW:PROC<BR>extrn TEXTOUT:PROC<BR>extrn TRANSLATEMESSAGE:PROC<BR>extrn 
UPDATEWINDOW:PROC<BR>extrn WAITEVENT:PROC<BR></FONT></STRONG><FONT 
color=#ff3333><BR><STRONG>.data<BR></STRONG></FONT><BR><FONT size=2>; Для 
Windows Task Manager'a<BR></FONT><STRONG><FONT color=#ff3333>freespace db 16 
dup(0)</FONT><BR></STRONG><FONT size=2>; HINSTANCE нашего 
приложения<BR></FONT><STRONG><FONT color=#ff3333>hInstance dw 
?</FONT><BR></STRONG><FONT size=2>; Параметр просмотра окна 
<BR></FONT><STRONG><FONT color=#ff3333>cmdShow dw ?</FONT><BR></STRONG><FONT 
size=2>; Структура PAINTSTRUCT<BR></FONT><STRONG><FONT color=#ff3333>lppaint 
PAINTSTRUCT &lt;0&gt;</FONT><BR></STRONG><FONT size=2>; Структура сообщения 
MSGSTRUCT<BR></FONT><STRONG><FONT color=#ff3333>msg MSGSTRUCT 
&lt;0&gt;</FONT><BR></STRONG><FONT size=2>; Структура описания 
окна<BR></FONT><STRONG><FONT color=#ff3333>wc WNDCLASS 
&lt;0&gt;</FONT><BR></STRONG><FONT size=2>; Заголовок 
окна<BR></FONT><STRONG><FONT color=#ff3333>lpszTitleName db 'Menu and Resources 
Window',0</FONT><BR></STRONG><FONT size=2>; Название класса 
окна<BR></FONT><STRONG><FONT color=#ff3333>lpszClassName db 
'ASMCLASS',0</FONT><BR></STRONG><FONT size=2>; Выводимая в окно 
строка<BR></FONT><STRONG><FONT color=#ff3333>lpszText db 'Hello 
World'</FONT><BR></STRONG><FONT size=2>; Длина строки 
lpszText<BR></FONT><STRONG><FONT color=#ff3333>lpszTextLength equ 
$-lpszText</FONT><BR></STRONG><FONT size=2>; Заголовок диалогового 
окна<BR></FONT><STRONG><FONT color=#ff3333>lpszMenuCaption db 'Menu 
Event',0</FONT><BR></STRONG><FONT size=2>; Идентификатор 
меню</FONT><STRONG><BR><FONT color=#ff0033>MenuString db 
'MENU_1',0</FONT><BR></STRONG><FONT size=2>; Сообщения диалогового 
окна<BR></FONT><STRONG><FONT color=#ff3333>lpszMenu1Msg db 'First menu item 
selected',0 <BR>lpszMenu2Msg db 'Second menu item selected',0 <BR>lpszMenu3Msg 
db 'Third menu item selected',0 <BR></FONT></STRONG><FONT 
color=#ff3333><BR><STRONG>.code<BR>.286</STRONG></FONT><STRONG><BR></STRONG><BR><FONT 
size=2>; Как говоритья в WarLords "Lets The War Begins"<BR></FONT><STRONG><FONT 
color=green>start:</FONT><BR></STRONG><FONT size=2>; Инициализируем сегмент 
данных<BR></FONT><STRONG><FONT color=#ff3333>mov ax, @data<BR>mov ds, 
ax</FONT><BR></STRONG><FONT size=2>; Инициализируем задачу и получаем входные 
параметры<BR></FONT><STRONG><FONT color=#ff3333>call INITTASK<BR>or 
ax,ax</FONT><BR></STRONG><FONT size=2>; Если инициализация прошла успешно 
<BR></FONT><STRONG><FONT color=#ff3333>jnz @@OK</FONT><BR></STRONG><FONT 
size=2>; Если ошибка <BR></FONT><STRONG><FONT color=#ff3333>jmp 
@@Fail</FONT><BR><FONT color=green>@@OK: </FONT><BR></STRONG><FONT size=2>; 
Сохраняем HINSTANCE<BR></FONT><STRONG><FONT color=#ff3333>mov 
[hInstance],di</FONT><BR></STRONG><FONT size=2>; Сохраняем параметр просмотра 
окна<BR></FONT><STRONG><FONT color=#ff3333>mov 
[cmdShow],dx</FONT><BR></STRONG><FONT size=2>; Инициализируем 
приложение<BR></FONT><STRONG><FONT color=#ff3333>call INITAPP,hInstance<BR>or 
ax,ax<BR>jnz @@InitOK</FONT><BR><FONT 
color=green>@@Fail:</FONT><BR></STRONG><FONT size=2>; Если инициализация 
завершилась неудачно<BR></FONT><STRONG><FONT color=#ff3333>mov ax, 4CFFh<BR>int 
21h</FONT><BR><FONT color=green>@@InitOK:</FONT><BR></STRONG><FONT size=2>; 
Заполняем структуру описания окна<BR></FONT><STRONG><FONT color=#ff3333>mov 
[wc.clsStyle],0<BR>mov word ptr [wc.clsLpfnWndProc],offset WndProc<BR>mov word 
ptr [wc.clsLpfnWndProc+2],seg WndProc<BR>mov [wc.clsCbClsExtra],0<BR>mov 
[wc.clsCbWndExtra],0<BR>mov ax,[hInstance]<BR>mov 
[wc.clsHInstance],ax<BR></FONT></STRONG><FONT 
face="Times New Roman, Times, serif"><FONT size=2>; Загружаем пиктограмму ICON_1 
и вствляем его в структуру</FONT></FONT><FONT color=#ff3333><BR><B>call 
LOADICON,ax,ICON_1 <BR>mov [wc.clsHIcon],ax </B><BR></FONT><FONT size=2>; 
Загружаем курсор IDC_ARROW и вставляем его в структуру<BR></FONT><STRONG><FONT 
color=#ff3333>xor ax,ax<BR>call LOADCURSOR,ax IDC_ARROW<BR>mov 
[wc.clsHCursor],ax</FONT><BR></STRONG><FONT size=2>; Загружаем цвет белого фона 
и вставляем его в структуру<BR></FONT><STRONG><FONT color=#ff3333>call 
GETSTOCKOBJECT,WHITE_BRUSH<BR>mov [wc.clsHbrBackground],ax<BR>mov word ptr 
[wc.clsLpszMenuName],offset MenuString<BR>mov word ptr 
[wc.clsLpszMenuName+2],ds<BR>mov word ptr [wc.clsLpszClassName],offset 
lpszClassName<BR>mov word ptr 
[wc.clsLpszClassName+2],ds</FONT><BR></STRONG><FONT size=2>; Регистрируем 
структуру описания окна<BR></FONT><STRONG><FONT color=#ff3333>call 
REGISTERCLASS,ds offset wc</FONT><BR></STRONG><FONT size=2>; Создаем 
окно<BR></FONT><STRONG><FONT color=#ff3333>xor ax,ax<BR>mov 
bx,CW_USEDEFAULT<BR>call CREATEWINDOW,ds offset lpszClassName,ds offset 
lpszTitleName\ 
,WS_OVERLAPPEDWINDOW,ax,bx,bx,bx,bx,ax,ax,\<BR>[hInstance],ax,ax</FONT><BR></STRONG><FONT 
size=2>; Показываем окно<BR></FONT><STRONG><FONT color=#ff3333>push ax<BR>call 
SHOWWINDOW,ax,cmdShow</FONT><BR></STRONG><FONT size=2>; Обновляем 
окно<BR></FONT><STRONG><FONT color=#ff3333>pop ax<BR>call 
UPDATEWINDOW,ax</FONT><BR></STRONG><FONT size=2>; Цикл обработки 
сообщений<BR></FONT><STRONG><FONT 
color=green>msg_loop:</FONT><BR></STRONG><FONT size=2>; Получаем 
сообщение<BR></FONT><STRONG><FONT color=#ff3333>call GETMESSAGE,ds offset 
msg,0,0,0</FONT><BR></STRONG><FONT size=2>; Проверяем на наличие сообщения 
WM_QUIT (AX=0)<BR></FONT><STRONG><FONT color=#ff3333>cmp ax,0<BR>je 
end_loop</FONT><BR></STRONG><FONT size=2>; Обрабатываем 
сообщение<BR></FONT><STRONG><FONT color=#ff3333>call TRANSLATEMESSAGE,ds offset 
msg<BR>call DISPATCHMESSAGE,ds offset msg</FONT><BR></STRONG><FONT size=2>; 
Обрабатываем следующее сообщение<BR></FONT><STRONG><FONT color=#ff3333>jmp 
msg_loop</FONT><BR><FONT color=green>end_loop:</FONT><BR></STRONG><FONT 
size=2>; Выходим из программы<BR></FONT><STRONG><FONT color=#ff3333>mov 
ax,[msg.msWPARAM]<BR>mov ah,4Ch<BR>int 21h</FONT><BR></STRONG><FONT 
size=2>;<BR>; Процедура обработки сообщений<BR>;<BR></FONT><STRONG><FONT 
color=#ff3333>WndProc PROC<BR>ARG 
hwnd:WORD,wmsg:WORD,wparam:WORD,lparam:DWORD<BR></FONT></STRONG><BR><STRONG><FONT 
color=#ff3333>cmp [wmsg],WM_DESTROY</FONT><BR></STRONG><FONT size=2>; Если 
получили сообщение WM_DESTROY (получено сообщение "на 
выход")<BR></FONT><STRONG><FONT color=#ff3333>je wmdestroy </FONT><FONT 
color=#ff3333><BR>cmp [wmsg],WM_CREATE</FONT><BR></STRONG><FONT size=2>; Если 
получили сообщение WM_CREATE (получено сообщение "создать 
окно")<BR></FONT><STRONG><FONT color=#ff3333>je wmcreate<BR>cmp 
[wmsg],WM_PAINT</FONT><BR></STRONG><FONT size=2>; Если получили сообщение 
WM_PAINT (получено сообщение "нарисуйся")<BR></FONT><STRONG><FONT 
color=#ff3333>je wmpaint</FONT><BR><FONT color=#ff0033>cmp [wmsg],WM_COMMAND 
</FONT><BR></STRONG><FONT size=2>; Если получили сообщение WM_COMMAND (получено 
сообщение от меню) </FONT><BR><FONT color=#ff0033><B>je wmcommand 
</B></FONT><BR><FONT size=2>; Если мы не обрабатываем ни одно из 
вышеперечисленных сообщений передаем<BR>; управление стандартному 
обработчику<BR></FONT><STRONG><FONT color=#ff3333>jmp 
defwndproc</FONT><BR></STRONG><FONT size=2>; <BR>; Обработка сообщения 
WM_PAINT<BR>;<BR></FONT><STRONG><FONT 
color=green>wmpaint:</FONT><BR></STRONG><FONT size=2>; Начинаем рисование и 
получаем указатель на текущий DC<BR></FONT><STRONG><FONT color=#ff3333>call 
BEGINPAINT,hwnd,ds offset lppaint</FONT><BR></STRONG><FONT size=2>; AX содержит 
контекст устройства вывода DC, полученный после вызова 
BEGINPAINT<BR></FONT><STRONG></STRONG><FONT size=2>; Вызываем TEXTOUT для вывода 
строки lpszText<BR></FONT><STRONG><FONT color=#ff3333>call TEXTOUT,ax,5,5,ds 
offset lpszText,lpszTextLength</FONT><BR></STRONG><FONT size=2>; Заканчиваем 
рисование<BR></FONT><STRONG><FONT color=#ff3333>call ENDPAINT,hwnd,ds offset 
lppaint</FONT><BR></STRONG><FONT size=2>; Обнуляем AX и на 
выход<BR></FONT><STRONG><FONT color=#ff3333>xor ax,ax<BR>jmp 
finish</FONT><BR></STRONG><FONT size=2>;<BR>; Обработка сообщения 
WM_CREATE<BR>;<BR></FONT><STRONG><FONT 
color=green>wmcreate:</FONT><BR></STRONG><FONT size=2>; Обнуляем AX и на 
выход<BR></FONT><STRONG><FONT color=#ff3333>xor ax,ax<BR>jmp 
finish</FONT><BR></STRONG><FONT size=2>;<BR>; Вызов стандартного обработчика 
сообщений <BR>;<BR></FONT><STRONG><FONT 
color=green>defwndproc:</FONT><BR><FONT color=#ff3333>call 
DEFWINDOWPROC,hwnd,wmsg,wparam,lparam<BR>jmp finish</FONT><BR></STRONG><FONT 
size=2>;<BR>; Обработка сообщения WM_DESTROY<BR>;<BR></FONT><STRONG><FONT 
color=green>wmdestroy:</FONT><BR></STRONG><FONT size=2>; Вызываем 
POSTQUITMESSAGE<BR></FONT><STRONG><FONT color=#ff3333>call 
POSTQUITMESSAGE,0</FONT><BR></STRONG><FONT size=2>; Обнуляем AX и на 
выход<BR></FONT><STRONG><FONT color=#ff3333>xor ax,ax<BR>jmp 
finish<BR></FONT></STRONG><FONT size=2>; <BR>; Обработка сообщения WM_COMMAND 
<BR>; <BR></FONT><FONT color=green><B>wmcommand:</B></FONT><FONT size=2><FONT 
color=green> </FONT><BR>; Если выбран первый пункт меню File <BR></FONT><FONT 
color=#ff0033><B>cmp [wparam],CM_FIRSTMENU <BR>jne wmcommand1 </B></FONT><FONT 
color=#cc0033><BR></FONT><FONT size=2>; Выводим на экран диалоговое окно 
<BR></FONT><FONT color=#ff0033><B>call MESSAGEBOX,0,ds offset lpszMenu1Msg,ds 
offset lpszMenuCaption,0 </B></FONT><FONT size=2><BR>; Выход из обработчика 
WM_COMMAND <BR></FONT><FONT color=#ff0033><B>jmp exit_wmcommand </B></FONT><FONT 
size=2><FONT color=#ff0033><BR></FONT></FONT><FONT color=#ff0033><B><FONT 
color=green>wmcommand1: </FONT></B></FONT><FONT size=2><BR>; Если выбран 
второй пункт меню File <BR></FONT><FONT color=#ff0033><B>cmp 
[wparam],CM_SECONDMENU </B><BR><B>jne wmcommand2 </B></FONT><FONT size=2><BR>; 
Выводим на экран диалоговое окно <BR></FONT><FONT color=#ff0033><B>call 
MESSAGEBOX,0,ds offset lpszMenu2Msg,ds offset lpszMenuCaption,0 </B></FONT><FONT 
size=2><BR>; Выход из обработчика WM_COMMAND <BR></FONT><FONT 
color=#ff0033><B>jmp exit_wmcommand<BR><FONT color=green>wmcommand2: 
</FONT></B></FONT><FONT size=2><BR>; Если выбран третий пункт меню File 
<BR></FONT><FONT color=#ff0033><B>cmp [wparam],CM_THIRDMENU <BR>jne wmcommand3 
</B></FONT><FONT size=2><BR>; Выводим на экран диалоговое окно <BR></FONT><FONT 
color=#ff0033><B>call MESSAGEBOX,0,ds offset lpszMenu3Msg,ds offset 
lpszMenuCaption,0 </B></FONT><FONT size=2><BR>; Выход из обработчика WM_COMMAND 
<BR></FONT><FONT color=#ff0033><B>jmp exit_wmcommand <BR><FONT 
color=green>wmcommand3: </FONT></B></FONT><FONT size=2><BR>; Если выбран пункт 
Exit NOW меню Exit <BR></FONT><FONT color=#ff0033><B>cmp [wparam],CM_EXIT 
</B></FONT><FONT size=2><BR>; Вызываем POSTQUITMESSAGE <BR></FONT><FONT 
color=#ff0033><B>call POSTQUITMESSAGE,0 </B></FONT><FONT size=2><BR>; Выход из 
обработчика WM_COMMAND <BR></FONT><FONT color=#ff0033><B>jmp exit_wmcommand 
</B></FONT><FONT size=2><BR>; Выход из обработчкиа WM_COMMAND<BR></FONT><FONT 
color=#ff0033><B><FONT color=green>exit_wmcommand: </FONT></B></FONT><FONT 
size=2><FONT color=#ff0033><B><BR></B></FONT></FONT></FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2></FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2>;</FONT></FONT> <FONT 
size=2>Выходим из обработчика WM_COMMAND <BR></FONT><FONT color=#ff0033><B>xor 
ax,ax <BR>jmp finish<BR></B></FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2>;</FONT></FONT><FONT 
color=#ff0033><B><BR></B></FONT></FONT><FONT 
face="Times New Roman, Times, serif"><FONT size=2>; "Финишная 
прямая"<BR>;<BR></FONT><STRONG><FONT 
color=green>finish:</FONT><BR></STRONG><FONT size=2>; Обнуляем DX и на 
выход<BR></FONT><STRONG><FONT color=#ff3333>xor dx,dx<BR>ret<BR>WndProc 
ENDP<BR></FONT></STRONG><FONT color=#ff3333><BR><STRONG>end 
start</STRONG></FONT></FONT></P>
<HR>

<P align=left><FONT>В этой программе я 
использовал два типа ресурсов <FONT color=#ff0033><B>MENU</B></FONT> и <FONT 
color=#ff0033><B>ICON</B></FONT>. Подключение ресурса <FONT 
color=#ff0033><B>ICON</B></FONT> выглядит очень наглядно, и объяснять его я не 
буду. Однако подключение ресурса <FONT color=#ff0033><B>MENU</B></FONT> 
осуществляется немного по-другому. </FONT></P>
<P align=left><FONT>Ресурсы типа <FONT 
color=#ff0033><B>DIALOG</B></FONT> и <FONT color=#ff0033><B>MENU</B></FONT> 
подключаются не через идентификаторы ресурсов, а через их текстовые имена, 
которые они имели при создании в Resource Workshop. В нашем случае ресурс <FONT 
color=#ff0033><B>MENU</B></FONT> имеет имя "MENU_1". Вы просто должны объявить 
строку, содержащую имя ресурса и заканчивающуюся символом 0. </FONT></P>
<P align=left><FONT>Например: </FONT></P>
<P align=left><FONT color=#ff0033 
face="Times New Roman, Times, serif"><B>lpszMenu db 'MENU_1',0 </B></FONT></P>
<P align=left><FONT>Все остальные типы 
ресурсов (кроме <FONT color=#ff0033><B>MENU</B></FONT> и <FONT 
color=#ff0033><B>DIALOG</B></FONT>) подключаются по методу подключения ресурсы 
ICON. </FONT></P>
<P align=left><FONT>Теперь рассмотрим 
подробнее функцию <FONT color=#ff0033><B>WndProc</B></FONT>. По сравнению с 
предыдущей статьей она стала немного сложнее. Это связано с тем, что теперь наше 
приложение обрабатывает все пункты меню. Когда вы нажимаете на какой-либо пункт 
меню, Windows посылает программе сообщение <FONT 
color=#ff0033><B>WM_COMMAND</B></FONT>. Через параметр wParam передается 
идентификатор нажатого пункта меню. Так на нашем примере, если вы нажимаете на 
кнопку Second Item в меню файл, то приложению передается сообщение <FONT 
color=#ff0033><B>WM_COMMAND</B></FONT> с <FONT 
color=#ff0033><B>wParam=CM_SECONDITEM</B></FONT>. Т.е. со значением которые вы 
присвоили данному пункту меню во время создания ресурса <FONT 
color=#ff0033><B>MENU</B></FONT> в Resource Workshop. </FONT></P>
<P align=left><FONT>Теперь опишем еще раз 
процесс создания приложения, содержащего ресурсы: </FONT></P></DIV>
<UL>
  <LI>
  <DIV align=left><FONT>Создаем файл 
  сценария ресурсов (.RC) и файл идентификатора ресурсов (.RH) в Resource 
  Workshop. <BR><FONT color=#ff0033><B>menures.rc, menures.rh 
  </B></FONT><BR>Преобразуем файл сценария ресурсов (.RC) в файл ресурсов 
  (.RES), с помощью Resource Workshop или программы brcc.exe. <BR><FONT 
  color=#ff0033><B>brcc.exe menures.rc </B></FONT><BR>Преобразуем файл 
  идентификаторов ресурсов (.RH) в язык, понятный Turbo Assembler. (.RI) 
  Компилируем приложение <BR><FONT color=#ff0033><B>tasm.exe menures.asm 
  </B></FONT><BR>Компонуем приложение <BR><FONT color=#ff0033><B>tlink.exe 
  menures.obj,menures.exe,menures.map,import.lib,menures.def,menures.res.</B></FONT></FONT></DIV></LI></UL>
<P><FONT>Нажмите на ссылку, что бы скачать 
файлы статьи </FONT></P>
<P><FONT><A 
href="menures.asm.rar">menures.asm</A><BR><A 
href="menures.def.rar">menures.def</A><BR><A 
href="menures.rc.rar">menures.rc</A><BR><A 
href="menures.rh.rar">menures.rh</A><BR><A 
href="menures.ri.rar">menures.ri</A><BR><A 
href="menures.res.rar">menures.res</A> 
</FONT></P>

<P><FONT>Ну вот и все про ресурсы и меню. 
  <p><div align="center"><a href="index.htm">	<img src="../../soder.gif" width=120 height=31 border=0 alt=""></a></div></p>
</BODY></HTML>
