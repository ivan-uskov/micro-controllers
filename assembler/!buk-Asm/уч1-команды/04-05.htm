<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Dmitry L. Smirnoff (C) 2001">
<link REL="stylesheet" HREF="(Styles).css" TYPE="text/css">
<title>4.5. Режимы адресации данных</title>
</head>

<body background="(Фон).gif">

<hr>

<p>Рассмотрим конкретные режимы адресации
операндов, не касаясь пока вопросов адресации в
командах передачи управления.</p>

<h1>1. Неявная адресация</h1>

<p>Операнд адресуется неявно, если в команде, нет
специальных полей для его определения, т.е.
операнд задается кодом операции. В ассемблерных
командах с неявной адресацией поле операнда
пустое. Примерами команд с неявной адресацией
могут служить:</p>

<pre>
	aaa	;Скорректировать регистр AL после сложения

	ctc	;Инвертировать флажок переноса

	std	;Установить в 1 фпажок направления</pre>

<h1>2. Регистровая адресация</h1>

<p>В командах с таким режимом адресации операнд(ы)
находится в регистре процессора. Регистровые
операнды в ассемблерных командах указываются
именами регистров в поле операнда. Отметим, что
не все регистры являются допустимыми операндами
во всех командах. Например, невозможно
произвести инкремент сегментного регистра или
сохранить в памяти системные регистры
управления, отладки и проверки. Наиболее часто в
командах манипуляций данными участвуют 8-, 16- и
32-битные регистры общего назначения.</p>

<p>Привлекаемые в командах регистры определяются
полями <em>reg</em> и <em>mod r /m</em> (при <em>mod</em> = 11b). В
сокращенных формах команд регистры могут
указываться в поле кода операции; особенно это
относится к регистрам-аккумуляторам EAX/AX/AL.
Сегментные регистры в командах загрузки и
сохранения идентифицируются полями <em>sreg2</em> (2-х
битное поле, задает регистры CS, SS, DS и ES) или <em>sreg3</em>
(3-х битное поле, задает регистры CS, SS, DS, ES, а также
FS и GS) занимающими место поля <em>reg</em> в байте <em>mod
r/m</em>. </p>

<p>Примеры команд с регистровой адресацией:</p>

<pre>
	inc ESI		;Инкремент регистра

	sub ECX,ECX	;Сбросить регистр ЕСХ

	mov EAX,CR0	;Передать в ЕАХ содержимое CR0

	add AL,DL	;Прибавить к AL содержимое регистра DL

	movsx EAX,DH	;Переслать в EAX байт из DH со знаковым расширением</pre>

<h1>3. Непосредственная адресация</h1>

<p>В этом режиме операнд находится в самой
команде, т.е. хранится вместе с командой в
сегменте кода. Из-за этого изменить
непосредственный операнд невозможно, им может
быть только константа как операнд-источник.
Допускаются непосредственные операнды длиной 8,
16 и 32 бита; они всегда находятся в конце команды.
Использование непосредственных операндов
обычно определяется неявно, а байт <em>mod r/m</em>
задает операнд-получатель.</p>

<p>Примеры команд с непосредственной адресацией:</p>

<pre>
	mov EAX,0F0F0F0F0h	;Загрузить константу в ЕАХ

	and AL,0Fh		;Выделить младшую тетраду регистра AL

	bt  EDI,3		;Передать в CF бит 3 регистра EDI</pre>

<h1>4. Адресация ввода-вывода</h1>

<p>Процессоры семейства i80x86 могут обращаться к
устройствам ввода-вывода двумя способами.
Регистры периферийных устройств могут быть
отображены на память или иметь свои адреса в
пространстве ввода-вывода. Процессор
поддерживает б4К адресов ввода-вывода, обычно
называемых портами ввода-вывода.</p>

<p>В командах ввода-вывода источником или
получателем всегда служит аккумулятор EAX/AX/AL, а
порт определяется как непосредственный операнд
(фиксированный порт) или содержимое регистра DX
(переменный порт).</p>

<p>Примеры команд ввода-вывода:</p>

<pre>
	in  AL,40h	;Ввод байта из фиксированного порта

	out 20h,AX	;Вывод слова в фиксированный порт

	in  AX,DX	;Ввод слова из переменного порта

	out DX,EAX	;Вывод двойного слова в переменный порт</pre>

<h1>5. Адресация операндов в памяти</h1>

<p>Напомним, что эффективный адрес задает
смещение (т.е. расстояние) от начала
соответствующего сегмента. Адрес <em>0</em> есть
адрес первого байта в сегменте, адрес <em>1</em> -
второго байта и т.д. независимо от физического
начального или базового адреса сегмента. В
большинстве команд обработки данных по
умолчанию привлекается сегмент, адресуемый
регистром DS, но с помощью префикса замены
сегмента можно обращаться к любому другому
сегменту.</p>

<h2>5.1. Прямая адресация</h2>

<p>Это простейший режим адресации (он называется
также абсолютной адресацией), так как
эффективный адрес содержится в самой команде.
Местонахождение операнда задается смещением в
текущем сегменте, которое следует считать
константой. Численное значение адреса в
ассемблерных командах заключается в квадратные
скобки.</p>

<p>Примеры команд с прямой адресацией:</p>

<pre>
	mov AL,[2000h]		;Передать байт в регистр AL

	shl [word 1Fh]		;Сдвинуть слово на 5 бит влево

	inc [dword 123456h]	;Инкремент двойного слова в памяти</pre>

<p>Отметим, что во второй и третьей командах
применяется ключевые слова &quot;word&quot; (слово) и
&quot;dword&quot; (двойное слово) для указания длины
операнда, так как без них невозможно определить,
с какими данными должна работать команда.</p>

<p>При программировании прямая адресация
применяется редко и только для обращения к
ячейкам памяти с фиксированными адресами.
Например, во всех IBM-совместимых персональных
компью- терах в начале памяти размещается
область данных базовой системы ввода-вывода (BIOS -
Basic Input/Output System). В этой области по фиксированным
адресам хранится такая системная информация, как
список оборудования, буфер клавиатуры, ячейки с
текущим временем и т.п. Обращаться к этой
информации можно командами с прямой адресацией.</p>

<p>Среда программирования предоставляет в
распоряжение программиста ассемблеры и
компиляторы, которые позволяют именовать ячейки
памяти и использовать в программах не
абсолютные, а символические адреса.
Символическая адресация оказывается более
удобной и содержательной. Кроме того, ассемблер
может учитывать типы данных и контролировать
правильность их использования. Например, команда
инкремента с мнемоникой <em>inc</em> может произвести
инкремент байта, слова или двойного слова. При
определении символической переменной ассемблер
сможет выбрать правильный код операции.
Последнюю из приведенных выше команд можно
изменить следующим образом: </p>

<pre>
label	Temp    dword	 ;Определение двойного слова в памяти
	dd 7

	...

	inc [Temp]	;Инкремент двойного слова в памяти</pre>

<h2>5.2. Базовая адресация</h2>

<p>В этом режиме эффективный адрес операнда
находится в любом регистре, общего назначения
процессора кроме регистра ESP, т.е. этот режим
относится к косвенной регистровой адресации.
Отметим, что при использовании в качестве
базового регистра ЕВР эффективный адрес
считается смещением в текущем сегменте стека и
начальный адрес сегмента определяется регистром
SS. Такой прием упрощает доступ к переменным в
стеке, например к параметрам подпрограмм.
Использование регистра для адресации
указывается заключением его имени в квадратные
скобки.</p>

<p>Примеры команд с базовой адресацией:</p>

<pre>
	mov AL,[ECX]		;Передать в AL байт по адресу из ЕСХ

	dec [word ESI]		;Декремент слова по адресу из ESI

	xchg EAX,[EBX]		;Обмен значений регистра EAX и двойного слова
				;с адресом в регистре EBX</pre>

<h2>5.3. Базовая адресация со смещением</h2>

<p>Этот режим, называемый еще &quot;база плюс
смещение&quot; является обобщением предыдущего и
предназначен для обращения к соседним ячейкам
памяти относительно эффективного адреса в
базовом регистре. Он очень удобен для доступа к
элементам структур данных и переменным,
находящимся в стеке. Смещения считаются целыми
двоичными числами со знаком. Их длина может
составлять 8, 16 и 32 бита; при необходимости
короткие смещения расширяются со знаком.</p>

<p>Примеры команд с этим режимом адресации:</p>

<pre>
	mov EAX,[ESI+4]		;Передать двойное слово из памяти

	add [ECX+10h],DX		;Прибавить значение регистра DX к слову в памяти</pre>

<h2>5.4. Индексная адресация со смещением</h2>

<p>Индексирование реализуется, как и базовая
адресация, посредством использования
содержимого регистра общего назначения в
качестве компоненты эффективного адреса.
Индексным регистром может быть любой регистр
общего назначения кроме ESP. Индексная адресация
наиболее удобна при работе с массивами: прямой
адрес определяет начало массива, а индекс -
текущий элемент массива, например:</p>

<pre>
	sub  Array[ESI],2	;Вычесть 2 из элемента массива

	imul Vector[ECX]	;Умножить EAX на элемент массива
				;(результат будет в паре регистров EDX:EAX)</pre>

<p>В общем, индексная адресация со смещением очень
похожа на базовую адресацию со смещением. Однако
индексирование обладает интересной и удобной
возможностью, которой нет у базовой адресации.
Начиная с процессора i80386 легко производятся
операции с массивами, элементы которых имеют
размер 1, 2, 4 или 8 байт. Если индексной переменной
служит <em>i</em>, то для получения адреса <em>i</em>-го
элемента массива значение <em>i</em> необходимо
умножить на размер элемента массива. Например,
для массива V, состоящего из двойных слов, адрес
третьего элемента V[3] равен: V+4*3=V+12. Процессор
может автоматически произвести коррекцию
индекса для получения адреса памяти. Такая
коррекция называется масштабированием; она
показывается в ассемблерных командах с помощью
операции умножения.</p>

<p>Следующий фрагмент показывает суммирование
квадратов элементов массива V двойных слов, число
элементов которого находится в переменной Vmax.
Сумма образуется в регистре EDX.</p>

<pre>
	xor  ECX,ECX		;Обнуляем счетчик в регистре ECX
	xor  EDX,EDX		;Обнуляем сумму в регистре EDX
Next:
	cmp  ECX,[Vmax]		;Счетчик больше максимального индекса элемента в массиве?
	jge  Done		;Да, конец суммирования

	mov  EAX,V[ECX*4]	;Нет, загрузить текущий элемент в EAX
	imul EAX		;Возвести в квадрат
	add  EDX,EAX		;Учесть в сумме

	inc  ECX		;Увеличить счетчик
	jmp  Next		;Повтор цикла

Done:				;Конец фрагмента программы</pre>

<h2>5.5. Базово-индексная адресация со смещением</h2>

<p>Это наиболее сложный режим адресации. Он
применяется для доступа к структурам данных в
стеке и к массивам, базовые адреса которых
находятся в регистре. Значение индекса
разрешается масштабировать, как в предыдущем
режиме адресации.</p>

<p>Примеры команд с данным режимом адресации:</p>

<pre>
	mov EAX,[EBP+8][ESI]		;Нассив в стеке, начиная с ЕВР+8

	inc [word EBX-10h][EAX*2]	;Инкремент слова</pre>

<p>Когда регистр ЕВР указывается как <em>индексный
регистр с масштабированием</em>, он <strong>не
вызывает обращения к сегменту стека</strong>, как это
было при использовании его в качестве базового
регистра. Если в команде <em>определяются базовый
и индексный регистры и одним из них является
регистр ЕВР</em>, он считается <strong>базовым
регистром</strong> <em>при отсутствии у него
масштабного коэффициента</em>; при наличии же
масштабного коэффициента регистр ЕВР считается <strong>индексным
регистром</strong>. Получаются следующие четыре
варианта использования регис- тра ЕВР:</p>

<pre>
	inc [word ECX][EBP]		;EBP - база, используется сегмент стека SS

	mov AX,Array[EBP]		;EBP - база, используется сегмент стека SS

	mov EAX,[ECX][EBP*4]		;EBP - индекс, используется сегмент данных DS

	inc [byte ECX*8][EBP]		;EBP - база, используется сегмент стека SS</pre>

<p>Отметим, что в отличие от процессора i8086, где в
зависимости от сложности адресации вычисление
адреса требует от 5 до 17 тактов синхронизации,
процессоры i80486 и Pentium не расходуют
дополнительного времени на вычисление
эффективного адреса. Только при одновременном
указании в команде базового и индексного
регистров время выполнения команды
увеличивается на один такт синхронизации.</p>

<h2>5.6. Стековая адресация</h2>

<p>Во всех современных процессорах аппаратно
поддерживается стек, т.е. область оперативной
памяти, предназначенная для временного хранения
любой информации. Для стека характерны две
операции: <em>push</em> - включение (&quot;вталкивание&quot;)
в стек и <em>pop</em> - извлечение (&quot;выталкивание&quot;)
из стека. Включения и извлечения производятся с
одного конца, называемого вершиной стека (<em>Top Of
Stack - TOS</em>, или <em>Stack Top - ST</em>), таким образом, что
последнее включенное в стек значение
извлекается из него первым. Такая дисциплина
называется LIFO - &quot;последний пришел - первый
ушел&quot; (Last In - First Out). Команды процессора <em>push, pushfd,
pushad, call</em> и <em>int N</em> осуществляют включение в
стек, а команды <em>pop, popfd, popad, ret и iret</em> производят
извлечение из стека.</p>

<p>Предполагается, что область памяти для стека
находится в сегменте стека, база которого
определяется регистром SS. Текущую вершину стека
адресует регистр указателя стека ESP/SP. При
включении в стек вначале проверяется, содержит
ли ESP значение, которое не меньше четырех. Если
это условие не удовлетворяется, генерируется
особый случай нарушения стека. Если же ESP
содержит больше четырех, производится декремент
ESP на четыре и операнд сохраняется по адресу SS:[ESP].
Такое предварительное уменьшение ESP иногда
называется преддекрементом. В стек можно
включить содержимое регистра, ячейки памяти или
константу (процессор i8086 включать в стек
константы не может). </p>

<p>При выполнении извлечения из стека содержимое
ESP сравнивается с пределом сегмента стека. Если
обращение оказывается вне предела, формируется
особый случай нарушения стека. Когда обращение
оказывается разрешенным, считываются данные по
адресу SS:[ESP] и осуществляется инкремент ESP на
четыре (иногда это действие называется
постинкрементом). Извлечь данные из стека можно в
регистр или ячейку памяти.</p>

<p>Примеры стековых операций:</p>

<pre>
	push ECX	;Включить в стек содержимое регистра ECX

	pushfd		;Включить в стек содержимое регистра флажков EFLAGS

	push 4000h	;Включить в стек константу

	pop EDX		;Извлечь из стека значение в регистр EDX

	popfd		;Извлечь из стека данные в регистр EFLAGS

	pop [dword ESI] ;Извлечь из стека двойное слово в ячейку памяти
			;с адресом в ESI</pre>

<hr>

<p>Следующий раздел - “<a href="05-00.htm">Глава V. Система команд процессоров i80x86</a>”</p>
</body>
</html>
