<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Dmitry L. Smirnoff (C) 2001">
<link REL="stylesheet" HREF="(Styles).css" TYPE="text/css">
<title>5.1. Команды передачи данных</title>
</head>

<body background="(Фон).gif">

<hr>

<p>Команды этой самой обширной группы
предназначены для пересылок байт, слов и двойных
слов из памяти в регистр, из регистра в память и
из регистра в регистр. Их удобно разделить на
следующие подгруппы: 

<ol>
  <li>Общие передачи данных.</li>
  <li>Преобразования данных.</li>
  <li>Передачи данных с привлечением стека.</li>
  <li>Передачи адресных объектов.</li>
  <li>Передачи ввода-вывода.</li>
  <li>Флажковые передачи.</li>
  <li>Новые команды передач данных процессоров 80386 и
    i80486.</li>
</ol>

<p>Отличительная особенность команд передач
данных заключается в том, что они не модифицируют
состояний флажков. Команды передач, которые
прямо воздействуют на регистр флажков,
рассмотрены в п.5.?.</p>

<h1>1. Команды общих передач данных</h1>

<h2>1.1. Команда <i>mov</i></h2>

<p>Наиболее мощной среди команд передачи данных
является команда <i>mov</i> (от англ. <i>move</i> - передать,
переслать). Она может передать все, что угодно
(байт, слово, двойное слово), откуда угодно (из
регистра, памяти, непосредственные данные) и куда
угодно (в регистр, память). Команда <i>mov</i>
эквивалентна оператору присваивания в языках
программирования высокого уровня и имеет
следующее общее представление:</p>

<pre>
	mov dst,src
</pre>

<p>В результате выполнения команды <i>mov</i>
содержимое источника src (source) передается в
получатель dst (destination). О широких возможностях
команды <i>mov</i> свидетельствуют ее допустимые
формы:</p>

<pre>
	mov reg,imm		-Загрузка любой константы в регистр

	mov reg/mem,imm	-Загрузка любой константы в регистр или память

	mov reg/mem,reg	-Передача из регистра в регистр/память

	mov reg,reg/mem	-Передача из памяти/регистра в регистр

	mov sreg,reg/meml6	-Загрузка сегментного регистра

	mov reg/meml6,sreg	-Сохранение сегментного регистра
</pre>

<p>Отметим некоторые особенности команды <i>mov</i>. 

<ul>
  <li>Только с помощью команды <i>mov</i> (и стековых
    команд - см. далее) можно загружать и сохранять
    сегментные регистры.</li>
  <li>Только в команде <i>mov</i> с регистровой адресацией
    разрешается указывать системные регистры
    управления CR<sub>i</sub>, отладки DR<sub>i</sub> и проверки TR<sub>i</sub>.</li>
  <li>С помощью команды <i>mov</i> нельзя загружать
    константы в сегментные регистры; здесь требуется
    промежуточный регистр общего назначения, в
    качестве которого обычно привлекается регистр
    АХ.</li>
  <li>Когда в команде <i>mov</i> указан один из
    аккумуляторов EAX/AX/AL, ее длина сокращается на один
    байт по сравнению с общей формой; именно поэтому
    как промежуточный регистр рекомендуется
    использовать аккумулятор.</li>
  <li>В защищенном режиме команда загрузки любого
    сегментного регистра инициирует считывание в
    теневой регистр дескриптора нужного сегмента,
    поэтому время выполнения команды увеличивается
    и могут фиксироваться особые случаи нарушения
    общей защиты, нарушения стека и др. Отметим, что
    загрузка пустого селектора в регистр SS сразу же
    регистрируется особым случаем.</li>
  <li>При выполнении команды “<i>mov SS,src</i>” процессор
    запрещает восприятие аппаратных прерываний
    (включая и немаскированное прерывание по входу
    NMI) на время выполнения следующей команды, так как
    предполагается, что ей будет команда “<i>mov (E)SP,src</i>”,
    и необходимо обеспечить правильную работу с
    новым стеком.</li>
</ul>

<h2>1.2. Команда <i>xchg</i></h2>

<p>В подгруппу общих передач данных обычно
включают команду обмена <i>xchg</i> (от англ. <i>exchange</i> -
обменять), имеющую такую общую форму:</p>

<pre>
	xchg dst,src
</pre>

<p>и более конкретные представления:</p>

<pre>
	xchg reg,mem/reg

	xchg mera/reg,reg
</pre>

<p>Здесь одной командой производится обмен
содержимого источника и получателя. Без команды <i>xchg</i>
для обмена потребовались бы три команды <i>mov</i> (и
дополнительный регистр для временного хранения)
или три команды, реализующие обмен через стек.
Команда обмена обычно применяется для проверки
семафоров в памяти, показывающих состояние
(занят - свободен) разделенного ресурса в
мультипроцессорных системах. С учетом этого
процессоры i80386 и i80486 при выполнении команды <i>xchg</i>
всегда формируют сигнал LOCK# блокировки шины. Он
гарантирует, что между двумя обращениями к
памяти в команде <i>xchg</i> другие процессоры не
получат доступ к семафору. Кроме того, команда <i>xchg</i>
ускоряет такие алгоритмы сортировки, в которых
требуется обмен двух элементов массива в памяти,
нарушающих порядок.</p>

<h1>2. Команда преобразования <i>xlat</i></h1>

<p>Однобайтная команда преобразования <i>xlat</i> (от
англ. <i>translate</i> - преобразовать) заменяет
содержимое аккумулятора AL на байт из 256-байтной
таблицы, начальный адрес которой находится в
регистре (Е)ВХ (см. рис.1). Другими словами,
содержимое AL используется как индекс таблицы,
адресуемой регистром (Е)ВХ в сегменте данных.</p>

<h3><img src="05-10-рис01.gif"><br>
Рис.1. Действие команды преобразования <i>xlat</i></h3>

<p>Выполнение команды <i>xlat</i> состоит из двух
действий: 

<ol>
  <li>прибавить содержимое AL к содержимому регистра
    (Е)ВХ;</li>
  <li>использовать результат как смещение в сегменте
    данных и поместить адресуемый байт из памяти в
    регистр AL.</li>
</ol>

<p>Обычно команда <i>xlat</i> применяется для
преобразования данных из одного символьного
кода в другой. Программист создает 256- байтную
таблицу, содержащую значения результирующего
кода, и с помощью команды <i>xlat</i> осуществляет
быстрое и удобное преобразование. Эта же команда
часто применяется для классификации символов в
программах, интерпретирующих входные символьные
цепочки. Для этого требуется таблица, содержащая
коды классификации символов. Например, всем
прописным буквам назначается код 1, всем строчным
буквам код 2, всем цифрам код 3 и т.д. С помощью
команды <i>xlat</i> и простых команд сравнений и
условных переходов легко определить класс
символа и предпринять соответствующую
обработку.</p>

<h1>3. Команды работы со стеком</h1>

<p>Стек это область оперативной памяти, которая
находится в текущем сегменте стека и
предназначена для временного хранения любых
данных. При желании стек можно считать
расширением внутренних регистров процессора.
Начало сегмента стека определяет регистр SS, а
регистр ESP/SP адресует вершину стека. Все стековые
операции сопровождаются автоматической
модификацией регистра ESP/SP, т.е. стек работает с
подвижной вершиной.</p>

<h2>3.1. Команда <i>push</i></h2>

<p>Операция включения (проталкивания) в стек
производится командой “<i>push src</i>” и имеет такое
описание на псевдокоде:</p>

<pre>
IF Размер операнда - слово THEN
   Вычесть 2 из ESP/SP
   Передать слово src в вершину стека SS:[ESP/SP]
ELSE /*Размер операнда двойное слово*/
   Вычесть 4 из ESP/SP
   Передать двойное слово src в вершину стека SS:[ESP/SP]
</pre>

<p>В качестве источника можно указывать
сегментный регистр, 16/32-разрядный регистр общего
назначения, 16/32-разрядную ячейку памяти или
16/32-разрядную непосредственную константу.
Следует иметь в виду три особенности команды <i>push</i>.

<ol>
  <li>При выполнении команды <i>push SP</i> в процессоре i8086
    в стек включается измененное содержимое SP
    (уменьшенное на 2), а в более старших процессорах в
    стек включается содержимое ESP/SP до декремента.</li>
  <li>При работе с 32-разрядным стеком (например, в
    защищенном режиме) включение в стек 16-битного
    слова нарушает выравнивание памяти стека по
    границам двойных слов. Поэтому следует расширить
    операнд с 16 до 32 бит и включить его в стек как
    двойное слово (соответствующие команды
    расширения рассматриваются далее).</li>
  <li>При нехватке стекового пространства (например,
    когда выполняется команда <i>push AX</i>, a регистр
    ESP содержит значение 1) процессоры i80386 и i80486
    переходят в состояние отключения (shutdown).</li>
</ol>

<h2>3.2. Команды <i>pusha</i> и <i>pushad</i></h2>

<p>В процессоре i80186 появилась и была сохранена в
последующих процессорах удобная для разработки
процедур команда включения в стек содержимого
всех восьми 16-битных регистров общего назначения
<i>pusha</i> (от англ. <i>push all</i> - протолкнуть все). В
32-разрядных процессорах (начиная с i80386) она была
дополнена командой <i>pushad</i>, которая включает в
стек восемь 32-битных регистра общего назначения.
В этих командах регистры включаются в стек в
следующем порядке: ЕАХ/АХ, ЕСХ/СХ, EDX/DX, ЕВХ/ВХ, ESP/SP,
ЕВР/ВР, ESI/SI, EDI/DI. Для регистра ESP/SP включается то
его значение, которое было в нем до выполнения
команды включения в стек. Таким образом, одна
команда <i>pusha</i> или <i>pushad</i> заменяет собой восемь
обычных команд <i>push</i>.</p>

<h2>3.3. Команда <i>pop</i></h2>

<p>Операция извлечения (выталкивания) из стека
инициируется командой “<i>push dst</i>”, действия
которой описывает такой псевдокод:</p>

<pre>
IF Размер операнда - слово THEN
   Передать слово из вершины стека в dst
   Прибавить 2 к регистру ESP/SP
ELSE /*Размер операнда двойное слово*/
   Передать двойное слово из вершины стека в dst
   Прибавить 4 к регистру ESP/SP
</pre>

<p>В качестве получателя dst можно указывать
сегментный регистр, 16/32-разрядный регистр общего
назначения, 16/32-разрядную ячейку памяти. Отметим,
что при выполнении команды <i>push SS</i> процессор
запрещает аппаратные прерывания на время
выполнения следующей команды с расчетом на то,
что она будет загружать регистр ESP/SP для
правильной адресации стека. В защищенном режиме
извлечение значения из стека в любой сегментный
регистр производит считывание в теневой регистр
дескриптора соответствующего сегмента, поэтому
время выполнения команды увеличивается по
сравнению с другими получателями. При этом могут
возникнуть несколько особых случаев. Следует
учитывать также, что извлечение 16-битных слов
может нарушить выравнивание памяти стека по
границам двойных слов.</p>

<h2>3.4. Команды <i>popa</i> и <i>popad</i></h2>

<p>Команды <i>popa</i> и <i>popad </i>являются парными для
команд <i>pusha</i> и <i>pushad</i>. Они производят
извлечение из стека восемь регистров общего
назначения, эффективно заменяя при этом восемь
обычных команд <i>pop</i>. Отметим, что извлекаемое из
стека значение для регистра ESP/SP игнорируется
процессором.</p>

<h1>4. Команда загрузки эффективного адреса</h1>

<p>Команда загрузки эффективного адреса <i>lea</i> (от
англ. <i>load effective address</i>) отличается от других
команд пересылки данных тем, что при ее
выполнении в адресуемый регистр загружаются не
собственно данные, а их адрес. Основное
применение этой команды связано с заданием
значений регистров-указателей для адресации
структур данных в памяти.</p>

<p>Команда <i>lea</i> для загрузки эффективного адреса
имеет следующие допустимые формы:</p>

<pre>
	lеа regl6,meml6

	lea reg32,meml6

	lеа regl6,mem32

	lea reg32,mem32
</pre>

<p>При выполнении этой команды вычисляется
эффективный адрес памяти (т.е. смещение в
сегменте) и загружается в регистр. Обращения к
памяти при этом не производится. В двух ситуациях
размеры регистра и адреса памяти не совпадают
(это две средние формы команды <i>lea</i>). При
загрузке 16-разрядного адреса (meml6) в 32-разрядный
регистр (reg32) он расширяется с нулем до 32 бит, а при
загрузке 32-разрядного адреса (mem32) в 16-разрядный
регистр (regl6) берутся только младшие 16 бит
эффективного адреса.</p>

<p>Для задания адреса ячейки памяти (meml6 и mem32)
допустим любой режим адресации памяти. Так как
при этом производятся только сдвиги и сложения
содержимого базового и индексного регистров
внутри процессора, команду <i>lea</i> можно
использовать для выполнения простого умножения,
например:</p>

<pre>
	lea EAX,[EAX*2]		;Умножение ЕАХ на 2

	lea EAX,[EAX + EAX*2]		;Умножение ЕАХ на 3

	lea EAX,[EAX*4]		;Умножение ЕАХ на 4

	lea EAX,[EAX + EAX*4]		;Умножение ЕАХ на 5

	lea EAX,[EAX*8]		;Умножение ЕАХ на 8

	lea EAX,[EAX + EAX*8]		;Умножение ЕАХ на 9
</pre>

<p>Каждая из приведенных команд выполняется
быстрее команды умножения.</p>

<p>С помощью команды <i>lea</i> можно производить и
другие простые операции. Например, команда</p>

<pre>
	lea ЕСХ,[ЕАХ+ESI+5]
</pre>

<p>эквивалентна следующим трем командам:</p>

<pre>
	mov ECX,EAX
	add ECX,ESI
	add ECX,5
</pre>

<h1>5. Команды загрузки далекого адреса</h1>

<p>Пять команд “<i><b>L</b>sreg reg,mem</i>” загрузки полного
указателя предназначены для одновременной
загрузки в любой регистр общего назначения (reg) и
один из сегментных регистров (sreg обозначает один
из сегментных регистров SS, DS, ES, FS, GS) полного
указателя типа “сегмент:смещение”. Отметим, что
смещение может быть 16- или 32-битным.</p>

<p>Команды загрузки полного указателя имеют
следующие общие формы:</p>

<pre>
	Lsreg reg16,mem32

	Lsreg reg32,mem48
</pre>

<p>Как обычно, в защищенном режиме загрузка
селектора в сегментный регистр сопровождается
считыванием дескриптора соответствующего
сегмента в теневой регистр, что увеличивает
время выполнения команды. При этом могут
возникнуть несколько особых случаев. Основное
применение команд <i>Lsreg</i> связано с подготовкой
cегментного регистра данных и одного из
индексных регистров для работы с новым блоком
данных в памяти, например перед цепочечными
командами. Команда LSS используется для
инициализации указателя стека ESP/SP одновременно
с инициализацией сегментного регистра SS.</p>

<h1>6. Команды ввода-вывода</h1>

<p>Команды <i>in</i> (ввода) и <i>out</i> (вывода)
предназначены для обращения к портам в адресном
пространстве ввода-вывода, которое изолировано
от адресного пространства памяти. Эти команды
имеют следующие общие формы:</p>

<pre>
	in ACC,Port		;Ввод из фиксированного порта

	in ACC,DX		;Ввод из переменного порта, заданного в регистре DX

	out Port,ACC		;Вывод в фиксированный порт

	out DX,ACC		;Вывод в переменный порт, заданный в регистре DX
</pre>

<p>Здесь ACC обозначает аккумулятор EAX/AX/AL, a Port -
8-битное непосредственное значение imm8, которое
считается адресом порта и при выполнении команды
расширяется с нулем до 16 бит. При указании в
команде регистра DX 16-битный адрес порта берется
из этого регистра.</p>

<p>Команда <i>in</i> применяется для получения, а
команда <i>out</i> для выдачи одного байта, слова или
двойного слова в порт периферийного устройства.
Обычно устройство имеет несколько портов
(сложные устройства - десятки портов),
предназначенных для приема команд, выдачи
состояния (или статуса - status) устройства и для
обмена данными. Управление устройством
реализуется записью информации в командный порт
и чтением информации из портов состояния.
Передача собственно данных производится через
порты обмена данными.</p>

<p>Отметим, что в защищенном режиме команды <i>in</i> и
<i>out</i> являются привилегированными командами,
поэтому операционная система всегда
перехватывает инструкции ввода-вывода в
прикладных программах.</p>

<h1>7. Флажковые передачи</h1>

<p>Эта подгруппа содержит несколько простых
команд, которые обеспечивают доступ к флажкам
процессора.</p>

<p><b>Команда <i>lahf</i></b> загрузки флажков в
регистр АН (от англ. <i>load АН with Flags</i>) копирует
младший байт регистра EFLAGS в регистр АН, где
флажки можно изменить, проверить или сохранить.
Эта команда была оставлена в процессоре i8086 для
совместимости с 8-битным микропроцессором i8080 и в
программах для последующих процессоров почти не
применяется. В редких случаях ее можно
использовать для условных переходов по таким
комбинациям флажков, которые не перекрываются
стандартными командами условных переходов <i>j??</i>.
Необходимо учитывать, что неиспользуемые биты 1, 3
и 5 в регистре АН приходится маскировать.</p>

<p><b>Команда <i>sahf</i></b> сохранения регистра АН
во флажках (от англ. <i>store АН into Flags</i>) передает
содержимое регистра АН в младший байт регистра
EFLAGS (остальные биты регистра флажков не
изменяются). В основном, команда <i>sahf</i>
применяется для передачи кода условия от
устройства с плавающей точкой в регистр флажков
для последующего условного перехода по
результату численной команды.</p>

<p><b>Команды <i>pushf, pushfd, popf</i> и <i>popfd</i></b> позволяют
включить в стек и извлечь из стека содержимое
регистра EFLAGS/FLAGS. Обычно эти команды применяются
в начале (<i>pushf, pushfd</i>) и в конце (<i>popf</i> и <i>popfd</i>)
вызываемых процедур. Отметим, что в защищенном
режиме выполнение команд <i>popf</i> и <i>popfd</i> связано
с проверкой защиты по привилегиям.</p>

<h1>8. Новые команды</h1>

<p>В процессорах i80386 и i80486 появилось несколько
новых команд передач данных, предназначенных для
упрощения программирования типичных задач.</p>

<h2>8.1. Команды передачи с расширением размера
операнда</h2>

<p>Команды <i>movsx</i> и <i>movsx</i> передачи со
знаковым/нулевым расширением (от англ. <i>move with
Sign/Zero extension</i>) в процессе пересылки производят
расширение размера операнда. Эти команды имеет
следующие основные формы (для получения
мнемоники команды вместо знака ? следует
использовать символы <i>s</i> или <i>z</i>):</p>

<pre>
	mov?x reg16,reg/mem8		;Расширение байта до слова

	mov?x reg32,reg/meml6		;Расширение слова до двойного слова

	mov?x reg32,reg/mem8		;Расширение байта до двойного слова
</pre>

<p>Команда <i>movsx</i> передает 8-битный источник в 16-
или 32-битный получатель или 16-битный источник в
32-битный получатель с дублированием старшего
(знакового) бита источника в старшие биты
получателя. В качестве источника может быть
указан операнд в регистре или в памяти с любым
режимом адресации, а получателем может быть
только регистр общего назначения. Если
операнд-источник представлен в дополнительном
коде, то операция расширения со знаком не
изменяет численного значения операнда.</p>

<p>Команда <i>movzx</i> полностью аналогична команде <i>movsx</i>,
но она дублирует в старшие биты получателя нули.
Действие этой команды не изменяет численного
значения операнда, если его рассматривать как
целое беззнаковое число.</p>

<p>Обычно команды <i>movsx</i> и <i>movsx</i> применяется при
подготовке регистра общего назначения для
дальнейших вычислений.</p>

<h2>8.2. Команда обмена данными с системными
регистрами</h2>

<p>Действие универсальной команды <i>mov</i>
расширено на новые регистры управления, проверки
и отладки (появившиеся в процессорах i80386 и i80486):</p>

<pre>
	mov reg32,CRn

	mov reg32,DRn

	mov reg32,TRn

	mov CRn,reg32

	mov DRn,reg32

	mov TRn,reg32
</pre>

<p>Отметим, что в этих командах вместе с системным
регистром может быть указан только 32-битный
регистр общего назначения.</p>

<h2>8.3. Команда установки значения байта по условию</h2>

<p>Команда <i>set??</i> для установки байта по условию
предназначена для того, чтобы сохранить
зафиксированное флажками условие (заданное
знаками ??) для дальнейших вычислений. Она имеет
такую общую форму:</p>

<pre>
	set?? reg/mem8
</pre>

<p>Если проверяемое в команде условие,
представленное флажками в регистре EFLAGS,
удовлетворяется, в байт reg/mem8 помещается код 01h, а
когда условие не удовлетворяется, код 00h. Условие
кодируется в мнемонике команды и полностью
соответствует условиям, используемым в командах
условного перехода <i>j??</i> (см. п.5.4).</p>

<p>Команда <i>set??</i> часто применяется для
построения таблиц по результатам нескольких
сравнений или вычитании. Такие таблицы удобны в
таких программах, где требуется обработка
вложенных уровней условий.</p>

<hr>

<p>Следующий раздел - “<a href="05-20.htm">5.2.
Арифметические команды</a>”</p>
</body>
</html>
